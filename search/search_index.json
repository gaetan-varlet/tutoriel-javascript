{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tutoriel JavaScript Cours d\u00e9p\u00f4t GitHub : https://github.com/gaetan-varlet/tutoriel-javascript Les bases de JavaScript Introduction D\u00e9boguer votre code Premiers pas Les variables Les conditions Les boucles Les fonctions Les objets et les tableaux Vraiment bien comprendre JavaScript Les variables Les scopes Les fonctions Les objets D\u00e9veloppement moderne Javascript et ES6, ES7 Nouveaut\u00e9s ES6 Classes ES6 Modules ES6 Nouveaut\u00e9s ES7 D\u00e9veloppement moderne Javascript Npm Webpack Babel Objets et fonctions utiles Javascript L'Objet Math L'Objet Date Expressions R\u00e9guli\u00e8res SetTimeout et SetInterval Fonctions de String Fonctions de Array L'Objet JSON Javascript d\u00e9barque dans le navigateur Introduction Le DOM Les \u00e9v\u00e9nements Les requ\u00eates HTTP Ajax Les biblioth\u00e8ques et frameworks JavaScript (TODO) D\u00e9couverte des principaux frameworks JavaScript Modeler vos pages web (RECUP DES CHOSES PUIS SUPPRIMER) Manipuler le code HTML (partie 1/2) Manipuler le code HTML (partie 2/2) Les \u00e9v\u00e9nements Les formulaires Exercices Jeu du snake (version avec webpack) d\u00e9p\u00f4t page Web Application World Bucket List d\u00e9p\u00f4t page Web","title":"Accueil"},{"location":"#tutoriel-javascript","text":"","title":"Tutoriel JavaScript"},{"location":"#cours","text":"d\u00e9p\u00f4t GitHub : https://github.com/gaetan-varlet/tutoriel-javascript","title":"Cours"},{"location":"#les-bases-de-javascript","text":"Introduction D\u00e9boguer votre code Premiers pas Les variables Les conditions Les boucles Les fonctions Les objets et les tableaux","title":"Les bases de JavaScript"},{"location":"#vraiment-bien-comprendre-javascript","text":"Les variables Les scopes Les fonctions Les objets","title":"Vraiment bien comprendre JavaScript"},{"location":"#developpement-moderne-javascript-et-es6-es7","text":"Nouveaut\u00e9s ES6 Classes ES6 Modules ES6 Nouveaut\u00e9s ES7 D\u00e9veloppement moderne Javascript Npm Webpack Babel","title":"D\u00e9veloppement moderne Javascript et ES6, ES7"},{"location":"#objets-et-fonctions-utiles-javascript","text":"L'Objet Math L'Objet Date Expressions R\u00e9guli\u00e8res SetTimeout et SetInterval Fonctions de String Fonctions de Array L'Objet JSON","title":"Objets et fonctions utiles Javascript"},{"location":"#javascript-debarque-dans-le-navigateur","text":"Introduction Le DOM Les \u00e9v\u00e9nements Les requ\u00eates HTTP Ajax","title":"Javascript d\u00e9barque dans le navigateur"},{"location":"#les-bibliotheques-et-frameworks-javascript-todo","text":"D\u00e9couverte des principaux frameworks JavaScript","title":"Les biblioth\u00e8ques et frameworks JavaScript (TODO)"},{"location":"#modeler-vos-pages-web-recup-des-choses-puis-supprimer","text":"Manipuler le code HTML (partie 1/2) Manipuler le code HTML (partie 2/2) Les \u00e9v\u00e9nements Les formulaires","title":"Modeler vos pages web (RECUP DES CHOSES PUIS SUPPRIMER)"},{"location":"#exercices","text":"","title":"Exercices"},{"location":"#jeu-du-snake-version-avec-webpack","text":"d\u00e9p\u00f4t page Web","title":"Jeu du snake (version avec webpack)"},{"location":"#application-world-bucket-list","text":"d\u00e9p\u00f4t page Web","title":"Application World Bucket List"},{"location":"developpementModerneJavascript/","text":"D\u00e9veloppement Moderne JavaScript Nouveaut\u00e9s ES6 Rappels Dans la partie pr\u00e9c\u00e9dente ont d\u00e9j\u00e0 \u00e9t\u00e9 vu des nouveaut\u00e9s ES6 : les nouveaux mots cl\u00e9s let et var pour d\u00e9clarer une variable les scopes de bloc quand utiliser var , let et const les fonctions fl\u00e9ch\u00e9s le concept de classe Les param\u00e8tres par d\u00e9faut On peut maintenant utiliser des param\u00e8tres par d\u00e9faut dans les fonctions. Quand il y a une valeur par d\u00e9faut \u00e0 un param\u00e8tre, si on renseigne une valeur pour ce param\u00e8tre, la valeur sp\u00e9cifi\u00e9e sera prise en compte. Si aucune valeur n'est sp\u00e9cif\u00e9e, la valeur par d\u00e9faut est prise en compte. function nomComplet(prenom, nom){ console.log(prenom + \" \" + nom) } nomComplet(\"Brad\",\"Pitt\") // affiche Brad Pitt function nomComplet(prenom, nom){ console.log(prenom + \" \" + nom) } nomComplet(\"Brad\") // affiche Brad undefined function nomComplet(prenom, nom=\"Cruise\"){ console.log(prenom + \" \" + nom) } nomComplet(\"Brad\") // affiche Brad Cruise nomComplet(\"Brad\",\"Pitt\") // affiche Brad Pitt Les arguments sont \u00e9valu\u00e9s de gauche \u00e0 droite, il faut donc mettre les param\u00e8tres avec des valeurs par d\u00e9faut en dernier. function nomComplet(prenom=\"Brad\", nom){ console.log(prenom + \" \" + nom) } nomComplet(\"Pitt\") // affiche Pitt undefined function nomComplet(nom, prenom=\"Brad\"){ console.log(prenom + \" \" + nom) } nomComplet(\"Pitt\") // affiche Brad Pitt On peut utiliser des variables d\u00e9finies dans le scope global dans les param\u00e8tres par d\u00e9faut const nomActeur = \"Pitt\" function nomComplet(prenom, nom=nomActeur){ console.log(prenom + \" \" + nom) } nomComplet(\"Brad\") // affiche Brad Pitt Les param\u00e8tres Rest L'id\u00e9e est de sp\u00e9cifier des param\u00e8tres \u00e0 une fonction et que ces param\u00e8tres soient stock\u00e9es dans un tableau. Le nombre de ces param\u00e8tres est libre. Il faut pour cela utiliser ... Exemple sans les param\u00e8tres Rest o\u00f9 il faut donner un tableau const mesNombres = [1, 2, 3, 4] function faireSomme(nombres){ let somme = 0 for(let i =0 ; i < nombres.length ; i++){ somme += nombres[i] } return somme } console.log(faireSomme(mesNombres)) // affiche 10 Exemple avec les param\u00e8tres Rest o\u00f9 l'on peut fournir des valeurs libres qui sont stock\u00e9es dans un tableau gr\u00e2ce aux ... function faireSomme(...nombres){ console.log(nombres) // affiche [1, 2, 3, 4] let somme = 0 for(let i =0 ; i < nombres.length ; i++){ somme += nombres[i] } return somme } console.log(faireSomme(1, 2, 3, 4)) // affiche 10 L'op\u00e9ration Spread L'op\u00e9rateur Spread est l'inverse des param\u00e8tres Rest. Les param\u00e8tres Rest prennent des valeurs libres et les transforment en tableau. L'op\u00e9rateur Spread prend un tableau et le transforme en valeurs libres. Il s'utilise comme pour les param\u00e8tres Rest avec ... . Ce qui va les diff\u00e9rencier est quand on les utilise : si on lui donne des valeurs libres, il va les regrouper dans un tableau, et inversement. const mesNombres = [1, 2, 3] function faireSomme3Nombres(nb1, nb2, nb3){ console.log(nb1) // affiche [1, 2, 3] console.log(nb2) // affiche undefined console.log(nb3) // affiche undefined return nb1 + nb2 + nb3 } console.log(faireSomme3Nombres(mesNombres)) Cet exemple ne fonctionne pas, il faudrait fournir chaque \u00e9l\u00e9ment du tableau \u00e0 la fonction en faisant : console.log(faireSomme3Nombres(mesNombres[0], mesNombres[1], mesNombres[2])) On peut le faire plus simplement en utilisant l'op\u00e9rateur Spread : const mesNombres = [1, 2, 3] function faireSomme3Nombres(nb1, nb2, nb3){ console.log(nb1) // affiche 1 console.log(nb2) // affiche 2 console.log(nb3) // affiche 3 return nb1 + nb2 + nb3 } console.log(faireSomme3Nombres(...mesNombres)) // affiche 6 On peut aussi utiliser l'op\u00e9rateur Spread ailleurs que dans une fonction, par exemple pour regrouper deux tableaux en un. const fruits = [\"Pomme\", \"Melon\"] const legumes = [\"Tomate\", \"Concombre\"] // en faisant \u00e7a, on aura un tableau qui contient 2 tableaux de 2 \u00e9l\u00e9ments et pas un seul tableau de 4 \u00e9l\u00e9ments. const fruitsEtLegumes = [fruits, legumes] console.log(fruitsEtLegumes) // ici, on \u00e9clate nos 2 tableaux en valeurs libres pour recr\u00e9er un unique tableau const fruitsEtLegumesSpread = [...fruits, ...legumes] console.log(fruitsEtLegumesSpread) // affiche [\"Pomme\", \"Melon\", \"Tomate\", \"Concombre\"] // on peut aussi ajouter une valeur libre au milieu const fruitsEtLegumesSpread2 = [...fruits, \"Banane\", ...legumes] console.log(fruitsEtLegumesSpread2) // affiche [\"Pomme\", \"Melon\", \"Banane\", \"Tomate\", \"Concombre\"] L'op\u00e9rateur Spread est utile pour cr\u00e9er un nouveau tableau \u00e0 partir d'un ancien en changeant la r\u00e9f\u00e9rence de celui-ci. Sans l'op\u00e9rateur Spread, en faisant comme \u00e7a, ajouter un \u00e9l\u00e9ment \u00e0 un deux deux tableaux l'ajoute aux deux tableaux car fruits et fruits2 poitent vers le m\u00eame tableau. const fruits = [\"Pomme\", \"Melon\"] const fruits2 = fruits fruits2.push(\"Banane\") console.log(fruits) // affiche [\"Pomme\", \"Melon\", \"Banane\"] console.log(fruits2) // affiche [\"Pomme\", \"Melon\", \"Banane\"] Avec l'op\u00e9rateur Spread, un nouveau tableau fruits2 est cr\u00e9\u00e9 qui a une r\u00e9f\u00e9rence diff\u00e9rente que le premier tableau. Un changement sur l'un n'impactera pas l'autre. const fruits = [\"Pomme\", \"Melon\"] const fruits2 = [...fruits] fruits2.push(\"Banane\") console.log(fruits) // affiche [\"Pomme\", \"Melon\"] console.log(fruits2) // affiche [\"Pomme\", \"Melon\", \"Banane\"] for of Pour passer sur les \u00e9l\u00e9ments d'un tableau, on peut utiliser une boucle for classique. Avec ES6, une nouvelle syntaxe permet de parcourir les tableaux : le for of . Exemple en ES5 : const fruits = [\"Pomme\", \"Melon\", \"Fraise\"] for(let i = 0 ; i < fruits.length ; i++){ console.log(fruits[i]) } // affiche Pomme, puis Melon, puis Fraise Exemple avec for of qui fait exactement la m\u00eame chose. Il faut nommer une variable qui correspond \u00e0 la valeur courante du tableau que l'on parcourt. const fruits = [\"Pomme\", \"Melon\", \"Fraise\"] for(let fruit of fruits){ console.log(fruit) } // affiche Pomme, puis Melon, puis Fraise Les Template Literals ou Template String Les template literals permettent de simplifier la concat\u00e9nation. Il faut utiliser les back tilt (Alt Gr + 7) \u00e0 la place des guillemets dans le console.log() et mettre la variable entre accolades avec un dollar devant \u00e0 la place des plus. Exemple de concat\u00e9nation classique : const nom = \"Louis\" console.log(\"Je m'appelle \" + nom + \" !\") Exemple avec le template literal : const nom = \"Louis\" console.log(`Je m'appelle ${nom} !!!`) L'avantage est que l'on peut aussi cr\u00e9er des string multiligne : const maString = `Je suis sur la ligne 1 Je suis sur la ligne 3 Je suis sur la ligne 4` console.log(maString) Destructuring Arrays Si on veut cr\u00e9er des variables \u00e0 partir des valeurs d'un tableau, il faut pr\u00e9ciser pour chaque variable quel \u00e9l\u00e9ment du tableau on souhaite r\u00e9cup\u00e9rer. Avec l'ES6, il est possible de d\u00e9structurer le tableau pour simplifier la r\u00e9cup\u00e9ration des valeurs d'un tableau. Exemple en ES5 : const nombres = [1, 2, 3] const a = nombres[0] const b = nombres[1] console.log(a) // affiche 1 console.log(b) // affiche 2 Exemple en ES6 qui fait la m\u00eame chose : const nombres = [1, 2, 3] const [a,b] = nombres console.log(a) console.log(b) Il est possible de faire d'autres choses : const nombres = [1, 2, 3] const [a,b,c,d] = nombres console.log(a) console.log(b) console.log(c) console.log(d) // affiche undefined const nombres = [1, 2, 3] const [a,b,c,d=10] = nombres console.log(a) console.log(b) console.log(c) console.log(d) // affiche 10 const nombres = [1, 2, 3] const [a, ...b] = nombres console.log(a) // affiche 1 console.log(b) // affiche [2, 3] const nombres = [1, 2, 3] const [a, ,b] = nombres console.log(a) // affiche 1 console.log(b) // affiche 3 On peut aussi intervertir la valeur de 2 variables sans passer par une troisi\u00e8me variable (ne fonctionne pas sur mon poste) : let a = 1 let b = 2 [b,a] = [a,b] console.log(a) //affiche 2 console.log(b) // affiche 1 Destructuring Objects Il aussi possible de d\u00e9structurer un objet. La diff\u00e9rence avec le destructuring de tableau est qu'il est bas\u00e9 sur l'ordre des valeurs dans le tableau alors qu'avec les objets, il faut que les variables aient le m\u00eame nom que les propri\u00e9t\u00e9s de l'objet, sinon la variable ne sera pas renseign\u00e9e. const myObject ={ name:\"Louis\", age: 0 } const {name, age} = myObject console.log(name) // affiche Louis console.log(age) // affiche 0 const {name1, age1} = myObject console.log(name1) // affiche undefined console.log(age1) // affiche undefined Si on veut donner un nom diff\u00e9rent que le nom des propri\u00e9t\u00e9s de l'objet, il faut utiliser les alias : const myObject ={ name:\"Louis\", age: 0, present: function(){console.log(\"Hello\")} } const {name, age:age1, present:hello} = myObject console.log(name) // affiche Louis console.log(age1) // affiche 0 hello() // affiche Hello Les classes (ES6) La notion de classe Comme vu dans la partie pr\u00e9c\u00e9dente, pour construire un objet, au lieu de faire une fonction constructeur et ajouter des m\u00e9thodes sur le prototype, on peut cr\u00e9er une classe. L'h\u00e9ritage (Inheritance) Si on veut d\u00e9finir une classe qui a les m\u00eames propri\u00e9t\u00e9s qu'une autre classe avec une propri\u00e9t\u00e9 en plus, on peut h\u00e9riter de cette classe plut\u00f4t que de la red\u00e9finir de z\u00e9ro, ce qui \u00e9vitera une duplication de code. le mot cl\u00e9 extends permet de dire de quelle clase on h\u00e9rite le mot cl\u00e9 super dans le constructeur permet d'ex\u00e9cuter le constructeur de la classe parent il est aussi possible d'ex\u00e9cuter une m\u00e9thode parent dans une m\u00e9thode enfant avec super en faisant super.nomMethodeParent() il est possible d'utiliser les m\u00e9thodes parent sans les d\u00e9finir dans la classe enfant class Person { constructor(name, age){ this.name = name this.age = age } present(){ console.log(`Hello my name is ${this.name}`) } } class Hero extends Person{ constructor(name, age, power){ super(name, age) // ex\u00e9cute le constructeur de la classe parent avec ses param\u00e8tres this.power = power } usePower(){ console.log(`I am using my power ${this.power}`) } presentHero(){ super.present() console.log(`My power is ${this.power}`) } } let louis = new Person(\"Louis\", 0) louis.present() // affiche : Hello my name is Louis //louis.usePower() // il y aura une erreur car on ne peut utiliser la m\u00e9thode de Hero avec un objet Person let superman = new Hero(\"Superman\", 30, \"fly\") superman.present() // affiche : Hello my name is Superman superman.usePower() // affiche : I am using my power fly superman.presentHero() // affiche : Hello my name is Superman, puis affiche : My power is fly Etendre les objets int\u00e9gr\u00e9s (Extend Built-In Objects) Depuis ES6, on peut aussi \u00e9tendre des objets int\u00e9gr\u00e9s \u00e0 JavaScript comme Array ou Function Par exemple, on va cr\u00e9er une classe qui h\u00e9rite d' Array et qui d\u00e9finit une m\u00e9thode qui renvoit un tableau avec tous les \u00e9l\u00e9ments en majuscules : class UpperCaseArray extends Array{ upperCase(){ let newArray = [] this.forEach(element => {newArray.push(element.toUpperCase())}) return newArray } } const myArray = new UpperCaseArray() myArray.push(\"louis\") myArray.push(\"k\u00e9vin\") myArray.push(\"Thibaut\") console.log(myArray.upperCase()) // affiche : [\"LOUIS\", \"K\u00c9VIN\", \"THIBAUT\"] M\u00e9thodes Statiques On peut aussi utiliser les classes pour regrouper les fonctions qui concernent un m\u00eame sujet. Par exemple, on peut faire une classe Mathematiques : class Mathematique{ addition(number1, number2){ return number1 + number2 } multiplication(number1, number2){ return number1 * number2 } } const myMath = new Mathematique() console.log(myMath.addition(2,3)) // affiche 5 console.log(myMath.multiplication(2,3)) // affiche 6 C'est inutile dans ce cas de cr\u00e9er une instance de classe pour utiliser les m\u00e9thodes, car rien n'est li\u00e9 \u00e0 une m\u00e9thode sp\u00e9cifique. Pour faire cela, on va d\u00e9clarer nos m\u00e9thodes static et on pourra utiliser les m\u00e9thodes sans instancier la classe. class Mathematique{ static addition(number1, number2){ return number1 + number2 } static multiplication(number1, number2){ return number1 * number2 } } console.log(Mathematique.addition(2,3)) console.log(Mathematique.multiplication(2,3)) Get et Set De base, rien n'emp\u00eache d'acc\u00e9der et de modifier les propri\u00e9t\u00e9s de nos objets : class Person{ constructor(name){ this.name = name } } let louis = new Person(\"Louis\") console.log(louis.name) // affiche : Louis louis.name = \"Loulou\" // modifie le nom de l'objet louis console.log(louis.name) // affiche : Loulou Pour \u00e9viter cela, on peut utiliser get et set pour contr\u00f4ler l'acc\u00e8s aux propri\u00e9t\u00e9s de nos objets, choisir ce qu'on renvoit et dans quelle condition la propri\u00e9t\u00e9 peut \u00eatre modifi\u00e9e : class Person{ constructor(name){ this._name = name // par convention, on met un _ devant les propri\u00e9t\u00e9s que l'on veut rendre \"semi priv\u00e9\" } get name(){ return `b\u00e9b\u00e9 ${this._name}` } set name(value){ if(value.length > 2){ this._name = value } } } let louis = new Person(\"Louis\") console.log(louis.name) // affiche : b\u00e9b\u00e9 Louis louis.name = \"Lo\" console.log(louis.name) // affiche : b\u00e9b\u00e9 Louis, la modification n'a pas eu lieu car la taille du nom soumis n'est pas sup\u00e9rieur \u00e0 2 louis.name = \"Loulou\" console.log(louis.name) // affiche : b\u00e9b\u00e9 Loulou // On peut toujours acc\u00e9der \u00e0 la propri\u00e9t\u00e9 _name et la modifier directement console.log(louis._name) // affiche : Loulou louis._name = \"az\" console.log(louis._name) // affiche : az console.log(louis.name) // affiche : b\u00e9b\u00e9 az Les modules (ES6) Modules Sur des gros projets, il faut organiser le code JavaScript en plusieurs fichiers. Pour charger les diff\u00e9rents fichiers JavaScript, on peut les charger chacun un tag <script src=\"script.js\"></script> dans la page html. // script1.js const myLog = message => console.log(`** My Log ** : ${message}`) // script2.js myLog(\"Hello !\") // index.html <!DOCTYPE html> <html> <head> <title>Modules JavaScript</title> </head> <body> <script src=\"script1.js\"></script> <script src=\"script2.js\"></script> </body> </html> // affiche dans la console : ** My Log ** : Hello ! Cette solution n'est pas id\u00e9ale pour plusieurs raisons : - \u00e0 chaque tag script , une nouvelle requ\u00eate est faite au serveur pour r\u00e9cup\u00e9rer le fichier - il faut faire attention \u00e0 l'ordre des fichiers en mettant d'abord les fichiers avec du code qui sert dans les fichiers suivant, sinon \u00e7a ne fonctionnera pas - tous les fichiers partagent le m\u00eame scope global, on s'expose donc aux accidents de variables si par exemple des variables ont le m\u00eame nom dans diff\u00e9rents fichiers ce qui fait que des variables vont s'\u00e9craser Pour r\u00e9pondre \u00e0 ces probl\u00e8mes, ES6 a amen\u00e9 les modules . Chaque module peut exporter certaines de ces fonctionnalit\u00e9s et importer des fonctionnalit\u00e9s d'autres modules. La probl\u00e8me est que la plupart des navigateurs ne supportent pas encore les modules ES6. Avec Chrome, il faut au moins la version 60 et aller dans l'url chrome://flags/ et activer Experimental Web Platform features . Avec Firefox en version 61 (et peut-\u00eatre les versions plus anciennes ?), les modules sont pris en charge nativement. Dans le script 1, il faut exporter la fonction avec le mot cl\u00e9 export et dans le script 2, il faut l'importer. Dans le fichier html, on laisse qu'un seul script JavaScript, notre fichier point d'entr\u00e9e script2.js et on ajoute le type module dans la balise script. Le r\u00e9sultat sera le m\u00eame. // script1.js export const myLog = message => console.log(`** My Log ** : ${message}`) // script2.js import {myLog} from \"./script1.js\" myLog(\"Hello !\") // index.html <!DOCTYPE html> <html> <head> <title>Modules JavaScript</title> <meta charset=\"UTF-8\"> </head> <body> <script type=\"module\" src=\"script2.js\"></script> </body> </html> Import et Export Avec les modules, l'import et l'export se fait par r\u00e9f\u00e9rence, c'est-\u00e0-dire qu'on ne cr\u00e9e pas une nouvelle variable mais on importe la variable de l'autre module. Pour exporter plusieurs choses d'un m\u00eame module, on fait deux exports et on fait les deux imports sur une seule ligne // script1.js export const myLog = message => console.log(`** My Log ** : ${message}`) export let myVariable = \"Coucou !\" // script2.js import {myLog, myVariable} from \"./script1.js\" myLog(myVariable) On peut aussi faire l'export \u00e0 la fin du fichier au lieu de le faire au moment de la d\u00e9claration. // script1.js const myLog = message => console.log(`** My Log ** : ${message}`) let myVariable = \"Coucou !\" export {myLog, myVariable} Une variante de l'export et l' export default . Il ne peut y en avoir qu'un par fichier. Lorsqu'on l'importe, on ne met pas les accolades et on lui donne le nom qu'on veut car lorsqu'on ne met pas les accolades, c'est forc\u00e9ment lque \u00e7a correspond \u00e0 l'export default. // script1.js const myLog = message => console.log(`** My Log ** : ${message}`) let myVariable = \"Coucou !\" let myVariable2 = \"Important\" export {myLog, myVariable} export default myVariable2 // script2.js import {myLog, myVariable} from \"./script1.js\" import myVariable2 from \"./script1.js\" myLog(myVariable) myLog(myVariable2) Exemple en renommant la variable de l'export default dans l'import : // script2.js import toto, {myLog, myVariable} from \"./script1.js\" myLog(myVariable) myLog(toto) // correspond \u00e0 l'export default de myVariable2 On peut aussi utiliser des alias pour renommer les export classiques : // script2.js import toto, {myLog as myLogImported, myVariable} from \"./script1.js\" myLogImported(myVariable) myLogImported(toto) Lorsqu'il y a plusieurs \u00e9l\u00e9ments \u00e0 importer, on peut utiliser l'\u00e9toile pour tout importer. // script2.js import * as external from \"./script1.js\" external.myLog(external.myVariable) Les nouveaut\u00e9s ES7 Array.prototype.includes Lorsqu'on veut v\u00e9rifier la pr\u00e9sence d'un \u00e9l\u00e9ment dans un tableau, il faut utiliser la m\u00e9thode indexOf() qui renvoie la position de l'\u00e9l\u00e9ment dans le tableau, ou -1 si l'\u00e9l\u00e9ment est absent. const fruits = [\"pomme\", \"banane\", \"orange\"] console.log(fruits.indexOf(\"banane\")) // affiche 1 console.log(fruits.indexOf(\"melon\")) // affiche -1 const monFruit = \"banane\" if(fruits.indexOf(monFruit)>-1){ console.log(`${monFruit} est dans le tableau`) } else { console.log(`${monFruit} n'est pas dans le tableau`) } En ES7, on peut utiliser la m\u00e9thode includes() qui renvoie true ou false si l'\u00e9l\u00e9ment est pr\u00e9sent ou non dans le tableau. const fruits = [\"pomme\", \"banane\", \"orange\"] console.log(fruits.includes(\"banane\")) // affiche true console.log(fruits.includes(\"melon\")) // affiche false const monFruit = \"banane\" if(fruits.includes(monFruit)){ console.log(`${monFruit} est dans le tableau`) } else { console.log(`${monFruit} n'est pas dans le tableau`) } L'op\u00e9rateur d'exponentiation (op\u00e9rateur de puissance) l'ES7 am\u00e8ne un nouvel op\u00e9rateur qui est la puissance qui se note avec deux \u00e9toiles sous la forme x ** y pour x puissance y. Avant l'ES7, il fallait utiliser l'objet Math. const calcul = Math.pow(2,3) // 2*2*2 console.log(calcul) // affiche : 8 const newCalcul = 2 ** 3 console.log(newCalcul) // affiche : 8 On peut aussi utiliser ce nouvel op\u00e9rateur comme les op\u00e9rateurs classiques. let myVar = 2 myVar **= 3 // \u00e9quivaut \u00e0 myVar = myVar ** 3 console.log(myVar) // affiche 8 Les outils pour le d\u00e9veloppement moderne JavaScript Tous les navigateurs ne supportent pas encore ces nouveaut\u00e9s. Il existe des outils qui permettent de coder en ES6 et ES7 et que le code soit support\u00e9 par tous les navigateurs. Npm Les bases de Npm Npm pour Node Package Manager va nous permettre de g\u00e9rer nos paquets JavaScript. Pour l'utiliser, il faut t\u00e9l\u00e9charger Node.js Pour v\u00e9rifier qu'il est bien install\u00e9 et v\u00e9rifier la version, tpaer la commande node -v puis npm -v . Jusqu'\u00e0 pr\u00e9sent, pour utiliser une biblioth\u00e8que externe comme JQuery, il faut t\u00e9l\u00e9charger la biblioth\u00e8que et l'ajouter dans le fichier HTML. Avec Npm, il est possible de t\u00e9l\u00e9charger la biblioh\u00e8que tr\u00e8s facilement, en faisant npm install jquery . Un dossier node_modules est cr\u00e9\u00e9 avec un sous-dossier jquery . Il faut ensuite l'ajouter au fichier HTML en pointant dans le sous-dossier dist (pour distribution) et on peut utiliser jquery dans le projet. <!DOCTYPE html> <html> <head> <title>NPM</title> <meta charset=\"UTF-8\"> </head> <body> <script src=\"./node_modules/jquery/dist/jquery.js\"></script> <script type=\"module\" src=\"script.js\"></script> </body> </html> // script.js import {myLog} from \"./external.js\" myLog(\"Hello !\") jQuery(document).ready(function(){ console.log(\"jQuery est pr\u00eat !\"); }); // external.js export const myLog = message => console.log(`** My Log ** : ${message}`) On peut d\u00e9sinstaller la biblioth\u00e8que avec la commande npm uninstall jquery , ce qui supprime le dossier jquery du dossier node_modules . On peut mettre \u00e0 jour la version de jquery avec la commande npm update jquery . Le fichier package.json G\u00e9n\u00e9ralement on a beaucoup de d\u00e9pendances, ce qui deviendrait lourd \u00e0 g\u00e9rer avec les commandes vues ici. Avec le fichier package.json , on va pouvoir noter toutes les d\u00e9pendances ainsi que leur version. Cela permettra aussi de reproduire le projet sur un autre poste sans y inclure toutes les d\u00e9pendances mais uniquement ce fichier. En lan\u00e7ant la commande npm install , toutes les d\u00e9pendances inscrites dans le fichier package.json seront install\u00e9es dans la version sp\u00e9cifi\u00e9. Ce fichier est un fichier de configuration, il sert \u00e9galement \u00e0 d'autres choses. Pour le cr\u00e9er, il faut ex\u00e9cuter la commande npm init . Lorsqu'on installe ou d\u00e9sinstalle une d\u00e9pendance, elle n'est pas renseign\u00e9e dans le fichier package.json . Pour que ce soit le cas il faut ajouter --save , par exemple npm install jquery --save et jquery sera inscrit dans les d\u00e9pendances avec son num\u00e9ro de version. Il y a deux types de d\u00e9pendances : - les d\u00e9pendances classiques dont notre code a besoin, comme par exemple jquery . Elles sont rensiegn\u00e9es donc dependencies - les d\u00e9pendances de d\u00e9veloppement qui correspond aux outils de d\u00e9veloppement, par exemple webpack que l'on verra au prochain chapitre. Elles sont rensiegn\u00e9es donc devDependencies . Pour cela, il faut utiliser la commande --save-dev , par exemple npm install --save-dev webpack webpack-cli En installant webpack , il y a maintenant plein de d\u00e9pendances dans node_modules car webpack a besoin d'autres d\u00e9pendances qui ont \u00e9t\u00e9 install\u00e9 \u00e9galement. Webpack Qu'est-ce que Webpack Il est principalement utilis\u00e9 comme module bundler , c'est-\u00e0-dire qu'il va prendre tous nos fichiers pour faire un seul gros fichier. Ce fichier pourra \u00eatre inclus dans le fichier HTML, ce qui permet d'utiliser les modules ES6 directement avec webpack tout en \u00e9tant compatible avec les navigateurs anciens. Il faut cr\u00e9er un fichier de configuration webpack.config.js module.exports = { entry: \"./script.js\", // dit \u00e0 webpack le point d'entr\u00e9e de notre projet output: { filename: \"bundle.js\" // dit \u00e0 webpack le nom du fichier produit } } Il faut ensuite indiquer dans le fichier HTML que le fichier de script \u00e0 utiliser est celui cr\u00e9\u00e9 par webpack. On peut aussi enlever la d\u00e9pendance jquery du fichier HTML et l'importer dans le script o\u00f9 on l'utilise, webpack l'embarquera dans le fichier bundle.js qu'il va g\u00e9n\u00e9rer dans un dossier dist (pour distribution). <!DOCTYPE html> <html> <head> <title>NPM</title> <meta charset=\"UTF-8\"> </head> <body> <script src=\"./dist/bundle.js\"></script> </body> </html> // script.js import {myLog} from \"./external.js\" import jQuery from \"jquery\" myLog(\"Hello !\") jQuery(document).ready(function(){ console.log(\"jQuery est pr\u00eat !\"); }); // external.js export const myLog = message => console.log(`** My Log ** : ${message}`) Ex\u00e9cuter Webpack On va lancer l'ex\u00e9cutable de webpack. Dans le dossier .bin de node_modules, il y a tous les ex\u00e9cutables. Pour lancer webpack, on va ex\u00e9cuter la commande node_modules/.bin/webpack . Le fichier bundle.js a \u00e9t\u00e9 cr\u00e9\u00e9 en enpaquetant nos fichiers javscript. On peut lancer notre page HTML et \u00e7a fonctionne comme avant san utiliser les modules. Pour \u00e9viter de lancer la commande node_modules/.bin/webpack \u00e0 chaque fois, on va cr\u00e9er une t\u00e2che dans le fichier package.json que l'on pourra ex\u00e9cuter \u00e0 la place de cette commande. Pour exc\u00e9cuter la t\u00e2che, on lancera la commande npm run build // package.json \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"build\": \"webpack\" // ajout de la t\u00e2che build qui cr\u00e9e notre fichier bundle.js } ``` On peut faire mieux en disant \u00e0 webpack d'observer notre code et de recompiler le code pour recr\u00e9er *bundle.js* quand il observe des modifications sans relancer la commande de build. Pour cela, on va ajouter une propri\u00e9t\u00e9 dans le fichier de configuration de webpack. Lorsqu'on fait une modification et que l'on sauvegarde, il n'y a plus qu'\u00e0 rafra\u00eechir la page HTML pour voir le changement. ```js // webpack.config.js module.exports = { watch: true, // ajout de cette prori\u00e9t\u00e9 pour que webpack observe notre code et recompile lorsqu'il y a des changements entry: \"./script.js\", output: { filename: \"bundle.js\" } } Serveur local Webpack Pour \u00e9viter d'avoir \u00e0 recharger la page HTML \u00e0 chaque modification du code JavaScript, on va mettre en place un serveur de d\u00e9veloppement local. On va installer un nouveau paquet avec la commande npm install --save-dev webpack-dev-server . On va ex\u00e9cuter la commande node_modules/.bin/webpack-dev-server qui compile notre code et le met \u00e0 disposition \u00e0 l'adresse localhost:8080 . En faisant des modifications dans le code et que l'on enregistre, la page est relanc\u00e9 automatiquement. On peut cr\u00e9er une t\u00e2che dans les scripts dans le fichier package.json : \"start\": \"webpack-dev-server --open\" . --open permet de lancer la page HTML dans le navigateur avec la commannde npm run start . Architecture des fichiers Pour le moment, tous les fichiers sont mis \u00e0 la racine du projet. On va r\u00e9organiser tout \u00e7a un dossier src qui contient le code de d\u00e9veloppement, les fichiers sources JavaScript un dossier dist qui contient le code de distribution que voit le public, le fichier index.html et le fichier bundle.js Il faut mettre \u00e0 jour le fichier de configuration de webpack pour que \u00e7a fonctionne bien // webpack.config.js const path = require(\"path\") // permet de cr\u00e9er des chemins absolus \u00e0 partir des chemins relatifs car webpack attend \u00e0 certains endroits des chemins absolus module.exports = { watch: true, entry: \"./src/script.js\", // dit \u00e0 webpack le point d'entr\u00e9e de notre projet output: { path: path.resolve(__dirname, \"dist\"), filename: \"bundle.js\" // dit \u00e0 webpack le nom du fichier produit }, devServer: { contentBase: path.resolve(__dirname, \"dist\"), // dit au serveur de nous servir ce qu'il y a dans le dossier dist au lieu de la racine du projet open: true // lance le navigateur automatiquement au lancement du serveur, ce qui \u00e9vite de mettre --open dans la t\u00e2che } } // index.html <!DOCTYPE html> <html> <head> <title>NPM</title> <meta charset=\"UTF-8\"> </head> <body> <script src=\"bundle.js\"></script> </body> </html> Babel Qu'est-ce que Babel Babel est un transpileur qui va traduire notre code ES6-ES7 en ES5 \u00e9quivalent, ce qui nous permettra d'\u00eatre compatible avec les anciennes versions des navigateurs. Babel loader C'est une fonctionnalit\u00e9 de webpack qui va permettre de transpiler le code en ES5 au moment de la cr\u00e9ation du fichier bundle.js . Il faut commencer par installer les d\u00e9pendances n\u00e9cessaires npm install --save-dev babel-loader babel-core babel-preset-env . Il faut ensuite mettre \u00e0 jour le fichier de configuration de webpack en ajoutant une partie. // webpack.config.js module: { rules: [ { // on teste si c'est un fichier JS test: /\\.js$/, // on ne traite pas les fichiers dans node_modules exclude: /node_modules/, use: { loader: \"babel-loader\", options: { presets: [\"env\"] } } } ] } Babel polyfill ES6-ES7 n'apportent pas que de la nouvelle syntaxe mais aussi de nouveaux \u00e9l\u00e9ments. Quand on utilise un nouvel \u00e9l\u00e9ment ES6, on ne peut pas le traduire en ES5, ce qui peut poser des probl\u00e8mes de compatibilit\u00e9 avec les anciens navigateurs. Dans ce cas, on peut utiliser un polyfill , qui est un bout de code qui contient ces nouveaux \u00e9l\u00e9ments, ce qui permet d'ajouter les \u00e9l\u00e9ments manquants au navigateur. On va utiliser Babel polyfill. Il faut commencer par l'installer avec la commande npm install --save babel-polyfill . Il faut ensuite mettre \u00e0 jour le fichier de configuration de webpack en ajoutant babel-polyfill dans les fichiers en entr\u00e9e. Il faut aussi importer babel-polyfill dans le fichier d'entr\u00e9e JavaScript. // webpack.config.js module.exports = { watch: true, entry: [\"babel-polyfill\", \"./src/script.js\"], // dit \u00e0 webpack le point d'entr\u00e9e de notre projet output: { path: path.resolve(__dirname, \"dist\"), filename: \"bundle.js\" // dit \u00e0 webpack le nom du fichier produit } // script.js import \"babel-polyfill\" import {myLog} from \"./external.js\" myLog(\"Hello !\")","title":"D\u00e9v moderne"},{"location":"developpementModerneJavascript/#developpement-moderne-javascript","text":"","title":"D\u00e9veloppement Moderne JavaScript"},{"location":"developpementModerneJavascript/#nouveautes-es6","text":"","title":"Nouveaut\u00e9s ES6"},{"location":"developpementModerneJavascript/#rappels","text":"Dans la partie pr\u00e9c\u00e9dente ont d\u00e9j\u00e0 \u00e9t\u00e9 vu des nouveaut\u00e9s ES6 : les nouveaux mots cl\u00e9s let et var pour d\u00e9clarer une variable les scopes de bloc quand utiliser var , let et const les fonctions fl\u00e9ch\u00e9s le concept de classe","title":"Rappels"},{"location":"developpementModerneJavascript/#les-parametres-par-defaut","text":"On peut maintenant utiliser des param\u00e8tres par d\u00e9faut dans les fonctions. Quand il y a une valeur par d\u00e9faut \u00e0 un param\u00e8tre, si on renseigne une valeur pour ce param\u00e8tre, la valeur sp\u00e9cifi\u00e9e sera prise en compte. Si aucune valeur n'est sp\u00e9cif\u00e9e, la valeur par d\u00e9faut est prise en compte. function nomComplet(prenom, nom){ console.log(prenom + \" \" + nom) } nomComplet(\"Brad\",\"Pitt\") // affiche Brad Pitt function nomComplet(prenom, nom){ console.log(prenom + \" \" + nom) } nomComplet(\"Brad\") // affiche Brad undefined function nomComplet(prenom, nom=\"Cruise\"){ console.log(prenom + \" \" + nom) } nomComplet(\"Brad\") // affiche Brad Cruise nomComplet(\"Brad\",\"Pitt\") // affiche Brad Pitt Les arguments sont \u00e9valu\u00e9s de gauche \u00e0 droite, il faut donc mettre les param\u00e8tres avec des valeurs par d\u00e9faut en dernier. function nomComplet(prenom=\"Brad\", nom){ console.log(prenom + \" \" + nom) } nomComplet(\"Pitt\") // affiche Pitt undefined function nomComplet(nom, prenom=\"Brad\"){ console.log(prenom + \" \" + nom) } nomComplet(\"Pitt\") // affiche Brad Pitt On peut utiliser des variables d\u00e9finies dans le scope global dans les param\u00e8tres par d\u00e9faut const nomActeur = \"Pitt\" function nomComplet(prenom, nom=nomActeur){ console.log(prenom + \" \" + nom) } nomComplet(\"Brad\") // affiche Brad Pitt","title":"Les param\u00e8tres par d\u00e9faut"},{"location":"developpementModerneJavascript/#les-parametres-rest","text":"L'id\u00e9e est de sp\u00e9cifier des param\u00e8tres \u00e0 une fonction et que ces param\u00e8tres soient stock\u00e9es dans un tableau. Le nombre de ces param\u00e8tres est libre. Il faut pour cela utiliser ... Exemple sans les param\u00e8tres Rest o\u00f9 il faut donner un tableau const mesNombres = [1, 2, 3, 4] function faireSomme(nombres){ let somme = 0 for(let i =0 ; i < nombres.length ; i++){ somme += nombres[i] } return somme } console.log(faireSomme(mesNombres)) // affiche 10 Exemple avec les param\u00e8tres Rest o\u00f9 l'on peut fournir des valeurs libres qui sont stock\u00e9es dans un tableau gr\u00e2ce aux ... function faireSomme(...nombres){ console.log(nombres) // affiche [1, 2, 3, 4] let somme = 0 for(let i =0 ; i < nombres.length ; i++){ somme += nombres[i] } return somme } console.log(faireSomme(1, 2, 3, 4)) // affiche 10","title":"Les param\u00e8tres Rest"},{"location":"developpementModerneJavascript/#loperation-spread","text":"L'op\u00e9rateur Spread est l'inverse des param\u00e8tres Rest. Les param\u00e8tres Rest prennent des valeurs libres et les transforment en tableau. L'op\u00e9rateur Spread prend un tableau et le transforme en valeurs libres. Il s'utilise comme pour les param\u00e8tres Rest avec ... . Ce qui va les diff\u00e9rencier est quand on les utilise : si on lui donne des valeurs libres, il va les regrouper dans un tableau, et inversement. const mesNombres = [1, 2, 3] function faireSomme3Nombres(nb1, nb2, nb3){ console.log(nb1) // affiche [1, 2, 3] console.log(nb2) // affiche undefined console.log(nb3) // affiche undefined return nb1 + nb2 + nb3 } console.log(faireSomme3Nombres(mesNombres)) Cet exemple ne fonctionne pas, il faudrait fournir chaque \u00e9l\u00e9ment du tableau \u00e0 la fonction en faisant : console.log(faireSomme3Nombres(mesNombres[0], mesNombres[1], mesNombres[2])) On peut le faire plus simplement en utilisant l'op\u00e9rateur Spread : const mesNombres = [1, 2, 3] function faireSomme3Nombres(nb1, nb2, nb3){ console.log(nb1) // affiche 1 console.log(nb2) // affiche 2 console.log(nb3) // affiche 3 return nb1 + nb2 + nb3 } console.log(faireSomme3Nombres(...mesNombres)) // affiche 6 On peut aussi utiliser l'op\u00e9rateur Spread ailleurs que dans une fonction, par exemple pour regrouper deux tableaux en un. const fruits = [\"Pomme\", \"Melon\"] const legumes = [\"Tomate\", \"Concombre\"] // en faisant \u00e7a, on aura un tableau qui contient 2 tableaux de 2 \u00e9l\u00e9ments et pas un seul tableau de 4 \u00e9l\u00e9ments. const fruitsEtLegumes = [fruits, legumes] console.log(fruitsEtLegumes) // ici, on \u00e9clate nos 2 tableaux en valeurs libres pour recr\u00e9er un unique tableau const fruitsEtLegumesSpread = [...fruits, ...legumes] console.log(fruitsEtLegumesSpread) // affiche [\"Pomme\", \"Melon\", \"Tomate\", \"Concombre\"] // on peut aussi ajouter une valeur libre au milieu const fruitsEtLegumesSpread2 = [...fruits, \"Banane\", ...legumes] console.log(fruitsEtLegumesSpread2) // affiche [\"Pomme\", \"Melon\", \"Banane\", \"Tomate\", \"Concombre\"] L'op\u00e9rateur Spread est utile pour cr\u00e9er un nouveau tableau \u00e0 partir d'un ancien en changeant la r\u00e9f\u00e9rence de celui-ci. Sans l'op\u00e9rateur Spread, en faisant comme \u00e7a, ajouter un \u00e9l\u00e9ment \u00e0 un deux deux tableaux l'ajoute aux deux tableaux car fruits et fruits2 poitent vers le m\u00eame tableau. const fruits = [\"Pomme\", \"Melon\"] const fruits2 = fruits fruits2.push(\"Banane\") console.log(fruits) // affiche [\"Pomme\", \"Melon\", \"Banane\"] console.log(fruits2) // affiche [\"Pomme\", \"Melon\", \"Banane\"] Avec l'op\u00e9rateur Spread, un nouveau tableau fruits2 est cr\u00e9\u00e9 qui a une r\u00e9f\u00e9rence diff\u00e9rente que le premier tableau. Un changement sur l'un n'impactera pas l'autre. const fruits = [\"Pomme\", \"Melon\"] const fruits2 = [...fruits] fruits2.push(\"Banane\") console.log(fruits) // affiche [\"Pomme\", \"Melon\"] console.log(fruits2) // affiche [\"Pomme\", \"Melon\", \"Banane\"]","title":"L'op\u00e9ration Spread"},{"location":"developpementModerneJavascript/#for-of","text":"Pour passer sur les \u00e9l\u00e9ments d'un tableau, on peut utiliser une boucle for classique. Avec ES6, une nouvelle syntaxe permet de parcourir les tableaux : le for of . Exemple en ES5 : const fruits = [\"Pomme\", \"Melon\", \"Fraise\"] for(let i = 0 ; i < fruits.length ; i++){ console.log(fruits[i]) } // affiche Pomme, puis Melon, puis Fraise Exemple avec for of qui fait exactement la m\u00eame chose. Il faut nommer une variable qui correspond \u00e0 la valeur courante du tableau que l'on parcourt. const fruits = [\"Pomme\", \"Melon\", \"Fraise\"] for(let fruit of fruits){ console.log(fruit) } // affiche Pomme, puis Melon, puis Fraise","title":"for of"},{"location":"developpementModerneJavascript/#les-template-literals-ou-template-string","text":"Les template literals permettent de simplifier la concat\u00e9nation. Il faut utiliser les back tilt (Alt Gr + 7) \u00e0 la place des guillemets dans le console.log() et mettre la variable entre accolades avec un dollar devant \u00e0 la place des plus. Exemple de concat\u00e9nation classique : const nom = \"Louis\" console.log(\"Je m'appelle \" + nom + \" !\") Exemple avec le template literal : const nom = \"Louis\" console.log(`Je m'appelle ${nom} !!!`) L'avantage est que l'on peut aussi cr\u00e9er des string multiligne : const maString = `Je suis sur la ligne 1 Je suis sur la ligne 3 Je suis sur la ligne 4` console.log(maString)","title":"Les Template Literals ou Template String"},{"location":"developpementModerneJavascript/#destructuring-arrays","text":"Si on veut cr\u00e9er des variables \u00e0 partir des valeurs d'un tableau, il faut pr\u00e9ciser pour chaque variable quel \u00e9l\u00e9ment du tableau on souhaite r\u00e9cup\u00e9rer. Avec l'ES6, il est possible de d\u00e9structurer le tableau pour simplifier la r\u00e9cup\u00e9ration des valeurs d'un tableau. Exemple en ES5 : const nombres = [1, 2, 3] const a = nombres[0] const b = nombres[1] console.log(a) // affiche 1 console.log(b) // affiche 2 Exemple en ES6 qui fait la m\u00eame chose : const nombres = [1, 2, 3] const [a,b] = nombres console.log(a) console.log(b) Il est possible de faire d'autres choses : const nombres = [1, 2, 3] const [a,b,c,d] = nombres console.log(a) console.log(b) console.log(c) console.log(d) // affiche undefined const nombres = [1, 2, 3] const [a,b,c,d=10] = nombres console.log(a) console.log(b) console.log(c) console.log(d) // affiche 10 const nombres = [1, 2, 3] const [a, ...b] = nombres console.log(a) // affiche 1 console.log(b) // affiche [2, 3] const nombres = [1, 2, 3] const [a, ,b] = nombres console.log(a) // affiche 1 console.log(b) // affiche 3 On peut aussi intervertir la valeur de 2 variables sans passer par une troisi\u00e8me variable (ne fonctionne pas sur mon poste) : let a = 1 let b = 2 [b,a] = [a,b] console.log(a) //affiche 2 console.log(b) // affiche 1","title":"Destructuring Arrays"},{"location":"developpementModerneJavascript/#destructuring-objects","text":"Il aussi possible de d\u00e9structurer un objet. La diff\u00e9rence avec le destructuring de tableau est qu'il est bas\u00e9 sur l'ordre des valeurs dans le tableau alors qu'avec les objets, il faut que les variables aient le m\u00eame nom que les propri\u00e9t\u00e9s de l'objet, sinon la variable ne sera pas renseign\u00e9e. const myObject ={ name:\"Louis\", age: 0 } const {name, age} = myObject console.log(name) // affiche Louis console.log(age) // affiche 0 const {name1, age1} = myObject console.log(name1) // affiche undefined console.log(age1) // affiche undefined Si on veut donner un nom diff\u00e9rent que le nom des propri\u00e9t\u00e9s de l'objet, il faut utiliser les alias : const myObject ={ name:\"Louis\", age: 0, present: function(){console.log(\"Hello\")} } const {name, age:age1, present:hello} = myObject console.log(name) // affiche Louis console.log(age1) // affiche 0 hello() // affiche Hello","title":"Destructuring Objects"},{"location":"developpementModerneJavascript/#les-classes-es6","text":"","title":"Les classes (ES6)"},{"location":"developpementModerneJavascript/#la-notion-de-classe","text":"Comme vu dans la partie pr\u00e9c\u00e9dente, pour construire un objet, au lieu de faire une fonction constructeur et ajouter des m\u00e9thodes sur le prototype, on peut cr\u00e9er une classe.","title":"La notion de classe"},{"location":"developpementModerneJavascript/#lheritage-inheritance","text":"Si on veut d\u00e9finir une classe qui a les m\u00eames propri\u00e9t\u00e9s qu'une autre classe avec une propri\u00e9t\u00e9 en plus, on peut h\u00e9riter de cette classe plut\u00f4t que de la red\u00e9finir de z\u00e9ro, ce qui \u00e9vitera une duplication de code. le mot cl\u00e9 extends permet de dire de quelle clase on h\u00e9rite le mot cl\u00e9 super dans le constructeur permet d'ex\u00e9cuter le constructeur de la classe parent il est aussi possible d'ex\u00e9cuter une m\u00e9thode parent dans une m\u00e9thode enfant avec super en faisant super.nomMethodeParent() il est possible d'utiliser les m\u00e9thodes parent sans les d\u00e9finir dans la classe enfant class Person { constructor(name, age){ this.name = name this.age = age } present(){ console.log(`Hello my name is ${this.name}`) } } class Hero extends Person{ constructor(name, age, power){ super(name, age) // ex\u00e9cute le constructeur de la classe parent avec ses param\u00e8tres this.power = power } usePower(){ console.log(`I am using my power ${this.power}`) } presentHero(){ super.present() console.log(`My power is ${this.power}`) } } let louis = new Person(\"Louis\", 0) louis.present() // affiche : Hello my name is Louis //louis.usePower() // il y aura une erreur car on ne peut utiliser la m\u00e9thode de Hero avec un objet Person let superman = new Hero(\"Superman\", 30, \"fly\") superman.present() // affiche : Hello my name is Superman superman.usePower() // affiche : I am using my power fly superman.presentHero() // affiche : Hello my name is Superman, puis affiche : My power is fly","title":"L'h\u00e9ritage (Inheritance)"},{"location":"developpementModerneJavascript/#etendre-les-objets-integres-extend-built-in-objects","text":"Depuis ES6, on peut aussi \u00e9tendre des objets int\u00e9gr\u00e9s \u00e0 JavaScript comme Array ou Function Par exemple, on va cr\u00e9er une classe qui h\u00e9rite d' Array et qui d\u00e9finit une m\u00e9thode qui renvoit un tableau avec tous les \u00e9l\u00e9ments en majuscules : class UpperCaseArray extends Array{ upperCase(){ let newArray = [] this.forEach(element => {newArray.push(element.toUpperCase())}) return newArray } } const myArray = new UpperCaseArray() myArray.push(\"louis\") myArray.push(\"k\u00e9vin\") myArray.push(\"Thibaut\") console.log(myArray.upperCase()) // affiche : [\"LOUIS\", \"K\u00c9VIN\", \"THIBAUT\"]","title":"Etendre les objets int\u00e9gr\u00e9s (Extend Built-In Objects)"},{"location":"developpementModerneJavascript/#methodes-statiques","text":"On peut aussi utiliser les classes pour regrouper les fonctions qui concernent un m\u00eame sujet. Par exemple, on peut faire une classe Mathematiques : class Mathematique{ addition(number1, number2){ return number1 + number2 } multiplication(number1, number2){ return number1 * number2 } } const myMath = new Mathematique() console.log(myMath.addition(2,3)) // affiche 5 console.log(myMath.multiplication(2,3)) // affiche 6 C'est inutile dans ce cas de cr\u00e9er une instance de classe pour utiliser les m\u00e9thodes, car rien n'est li\u00e9 \u00e0 une m\u00e9thode sp\u00e9cifique. Pour faire cela, on va d\u00e9clarer nos m\u00e9thodes static et on pourra utiliser les m\u00e9thodes sans instancier la classe. class Mathematique{ static addition(number1, number2){ return number1 + number2 } static multiplication(number1, number2){ return number1 * number2 } } console.log(Mathematique.addition(2,3)) console.log(Mathematique.multiplication(2,3))","title":"M\u00e9thodes Statiques"},{"location":"developpementModerneJavascript/#get-et-set","text":"De base, rien n'emp\u00eache d'acc\u00e9der et de modifier les propri\u00e9t\u00e9s de nos objets : class Person{ constructor(name){ this.name = name } } let louis = new Person(\"Louis\") console.log(louis.name) // affiche : Louis louis.name = \"Loulou\" // modifie le nom de l'objet louis console.log(louis.name) // affiche : Loulou Pour \u00e9viter cela, on peut utiliser get et set pour contr\u00f4ler l'acc\u00e8s aux propri\u00e9t\u00e9s de nos objets, choisir ce qu'on renvoit et dans quelle condition la propri\u00e9t\u00e9 peut \u00eatre modifi\u00e9e : class Person{ constructor(name){ this._name = name // par convention, on met un _ devant les propri\u00e9t\u00e9s que l'on veut rendre \"semi priv\u00e9\" } get name(){ return `b\u00e9b\u00e9 ${this._name}` } set name(value){ if(value.length > 2){ this._name = value } } } let louis = new Person(\"Louis\") console.log(louis.name) // affiche : b\u00e9b\u00e9 Louis louis.name = \"Lo\" console.log(louis.name) // affiche : b\u00e9b\u00e9 Louis, la modification n'a pas eu lieu car la taille du nom soumis n'est pas sup\u00e9rieur \u00e0 2 louis.name = \"Loulou\" console.log(louis.name) // affiche : b\u00e9b\u00e9 Loulou // On peut toujours acc\u00e9der \u00e0 la propri\u00e9t\u00e9 _name et la modifier directement console.log(louis._name) // affiche : Loulou louis._name = \"az\" console.log(louis._name) // affiche : az console.log(louis.name) // affiche : b\u00e9b\u00e9 az","title":"Get et Set"},{"location":"developpementModerneJavascript/#les-modules-es6","text":"","title":"Les modules (ES6)"},{"location":"developpementModerneJavascript/#modules","text":"Sur des gros projets, il faut organiser le code JavaScript en plusieurs fichiers. Pour charger les diff\u00e9rents fichiers JavaScript, on peut les charger chacun un tag <script src=\"script.js\"></script> dans la page html. // script1.js const myLog = message => console.log(`** My Log ** : ${message}`) // script2.js myLog(\"Hello !\") // index.html <!DOCTYPE html> <html> <head> <title>Modules JavaScript</title> </head> <body> <script src=\"script1.js\"></script> <script src=\"script2.js\"></script> </body> </html> // affiche dans la console : ** My Log ** : Hello ! Cette solution n'est pas id\u00e9ale pour plusieurs raisons : - \u00e0 chaque tag script , une nouvelle requ\u00eate est faite au serveur pour r\u00e9cup\u00e9rer le fichier - il faut faire attention \u00e0 l'ordre des fichiers en mettant d'abord les fichiers avec du code qui sert dans les fichiers suivant, sinon \u00e7a ne fonctionnera pas - tous les fichiers partagent le m\u00eame scope global, on s'expose donc aux accidents de variables si par exemple des variables ont le m\u00eame nom dans diff\u00e9rents fichiers ce qui fait que des variables vont s'\u00e9craser Pour r\u00e9pondre \u00e0 ces probl\u00e8mes, ES6 a amen\u00e9 les modules . Chaque module peut exporter certaines de ces fonctionnalit\u00e9s et importer des fonctionnalit\u00e9s d'autres modules. La probl\u00e8me est que la plupart des navigateurs ne supportent pas encore les modules ES6. Avec Chrome, il faut au moins la version 60 et aller dans l'url chrome://flags/ et activer Experimental Web Platform features . Avec Firefox en version 61 (et peut-\u00eatre les versions plus anciennes ?), les modules sont pris en charge nativement. Dans le script 1, il faut exporter la fonction avec le mot cl\u00e9 export et dans le script 2, il faut l'importer. Dans le fichier html, on laisse qu'un seul script JavaScript, notre fichier point d'entr\u00e9e script2.js et on ajoute le type module dans la balise script. Le r\u00e9sultat sera le m\u00eame. // script1.js export const myLog = message => console.log(`** My Log ** : ${message}`) // script2.js import {myLog} from \"./script1.js\" myLog(\"Hello !\") // index.html <!DOCTYPE html> <html> <head> <title>Modules JavaScript</title> <meta charset=\"UTF-8\"> </head> <body> <script type=\"module\" src=\"script2.js\"></script> </body> </html>","title":"Modules"},{"location":"developpementModerneJavascript/#import-et-export","text":"Avec les modules, l'import et l'export se fait par r\u00e9f\u00e9rence, c'est-\u00e0-dire qu'on ne cr\u00e9e pas une nouvelle variable mais on importe la variable de l'autre module. Pour exporter plusieurs choses d'un m\u00eame module, on fait deux exports et on fait les deux imports sur une seule ligne // script1.js export const myLog = message => console.log(`** My Log ** : ${message}`) export let myVariable = \"Coucou !\" // script2.js import {myLog, myVariable} from \"./script1.js\" myLog(myVariable) On peut aussi faire l'export \u00e0 la fin du fichier au lieu de le faire au moment de la d\u00e9claration. // script1.js const myLog = message => console.log(`** My Log ** : ${message}`) let myVariable = \"Coucou !\" export {myLog, myVariable} Une variante de l'export et l' export default . Il ne peut y en avoir qu'un par fichier. Lorsqu'on l'importe, on ne met pas les accolades et on lui donne le nom qu'on veut car lorsqu'on ne met pas les accolades, c'est forc\u00e9ment lque \u00e7a correspond \u00e0 l'export default. // script1.js const myLog = message => console.log(`** My Log ** : ${message}`) let myVariable = \"Coucou !\" let myVariable2 = \"Important\" export {myLog, myVariable} export default myVariable2 // script2.js import {myLog, myVariable} from \"./script1.js\" import myVariable2 from \"./script1.js\" myLog(myVariable) myLog(myVariable2) Exemple en renommant la variable de l'export default dans l'import : // script2.js import toto, {myLog, myVariable} from \"./script1.js\" myLog(myVariable) myLog(toto) // correspond \u00e0 l'export default de myVariable2 On peut aussi utiliser des alias pour renommer les export classiques : // script2.js import toto, {myLog as myLogImported, myVariable} from \"./script1.js\" myLogImported(myVariable) myLogImported(toto) Lorsqu'il y a plusieurs \u00e9l\u00e9ments \u00e0 importer, on peut utiliser l'\u00e9toile pour tout importer. // script2.js import * as external from \"./script1.js\" external.myLog(external.myVariable)","title":"Import et Export"},{"location":"developpementModerneJavascript/#les-nouveautes-es7","text":"","title":"Les nouveaut\u00e9s ES7"},{"location":"developpementModerneJavascript/#arrayprototypeincludes","text":"Lorsqu'on veut v\u00e9rifier la pr\u00e9sence d'un \u00e9l\u00e9ment dans un tableau, il faut utiliser la m\u00e9thode indexOf() qui renvoie la position de l'\u00e9l\u00e9ment dans le tableau, ou -1 si l'\u00e9l\u00e9ment est absent. const fruits = [\"pomme\", \"banane\", \"orange\"] console.log(fruits.indexOf(\"banane\")) // affiche 1 console.log(fruits.indexOf(\"melon\")) // affiche -1 const monFruit = \"banane\" if(fruits.indexOf(monFruit)>-1){ console.log(`${monFruit} est dans le tableau`) } else { console.log(`${monFruit} n'est pas dans le tableau`) } En ES7, on peut utiliser la m\u00e9thode includes() qui renvoie true ou false si l'\u00e9l\u00e9ment est pr\u00e9sent ou non dans le tableau. const fruits = [\"pomme\", \"banane\", \"orange\"] console.log(fruits.includes(\"banane\")) // affiche true console.log(fruits.includes(\"melon\")) // affiche false const monFruit = \"banane\" if(fruits.includes(monFruit)){ console.log(`${monFruit} est dans le tableau`) } else { console.log(`${monFruit} n'est pas dans le tableau`) }","title":"Array.prototype.includes"},{"location":"developpementModerneJavascript/#loperateur-dexponentiation-operateur-de-puissance","text":"l'ES7 am\u00e8ne un nouvel op\u00e9rateur qui est la puissance qui se note avec deux \u00e9toiles sous la forme x ** y pour x puissance y. Avant l'ES7, il fallait utiliser l'objet Math. const calcul = Math.pow(2,3) // 2*2*2 console.log(calcul) // affiche : 8 const newCalcul = 2 ** 3 console.log(newCalcul) // affiche : 8 On peut aussi utiliser ce nouvel op\u00e9rateur comme les op\u00e9rateurs classiques. let myVar = 2 myVar **= 3 // \u00e9quivaut \u00e0 myVar = myVar ** 3 console.log(myVar) // affiche 8","title":"L'op\u00e9rateur d'exponentiation (op\u00e9rateur de puissance)"},{"location":"developpementModerneJavascript/#les-outils-pour-le-developpement-moderne-javascript","text":"Tous les navigateurs ne supportent pas encore ces nouveaut\u00e9s. Il existe des outils qui permettent de coder en ES6 et ES7 et que le code soit support\u00e9 par tous les navigateurs.","title":"Les outils pour le d\u00e9veloppement moderne JavaScript"},{"location":"developpementModerneJavascript/#npm","text":"","title":"Npm"},{"location":"developpementModerneJavascript/#les-bases-de-npm","text":"Npm pour Node Package Manager va nous permettre de g\u00e9rer nos paquets JavaScript. Pour l'utiliser, il faut t\u00e9l\u00e9charger Node.js Pour v\u00e9rifier qu'il est bien install\u00e9 et v\u00e9rifier la version, tpaer la commande node -v puis npm -v . Jusqu'\u00e0 pr\u00e9sent, pour utiliser une biblioth\u00e8que externe comme JQuery, il faut t\u00e9l\u00e9charger la biblioth\u00e8que et l'ajouter dans le fichier HTML. Avec Npm, il est possible de t\u00e9l\u00e9charger la biblioh\u00e8que tr\u00e8s facilement, en faisant npm install jquery . Un dossier node_modules est cr\u00e9\u00e9 avec un sous-dossier jquery . Il faut ensuite l'ajouter au fichier HTML en pointant dans le sous-dossier dist (pour distribution) et on peut utiliser jquery dans le projet. <!DOCTYPE html> <html> <head> <title>NPM</title> <meta charset=\"UTF-8\"> </head> <body> <script src=\"./node_modules/jquery/dist/jquery.js\"></script> <script type=\"module\" src=\"script.js\"></script> </body> </html> // script.js import {myLog} from \"./external.js\" myLog(\"Hello !\") jQuery(document).ready(function(){ console.log(\"jQuery est pr\u00eat !\"); }); // external.js export const myLog = message => console.log(`** My Log ** : ${message}`) On peut d\u00e9sinstaller la biblioth\u00e8que avec la commande npm uninstall jquery , ce qui supprime le dossier jquery du dossier node_modules . On peut mettre \u00e0 jour la version de jquery avec la commande npm update jquery .","title":"Les bases de Npm"},{"location":"developpementModerneJavascript/#le-fichier-packagejson","text":"G\u00e9n\u00e9ralement on a beaucoup de d\u00e9pendances, ce qui deviendrait lourd \u00e0 g\u00e9rer avec les commandes vues ici. Avec le fichier package.json , on va pouvoir noter toutes les d\u00e9pendances ainsi que leur version. Cela permettra aussi de reproduire le projet sur un autre poste sans y inclure toutes les d\u00e9pendances mais uniquement ce fichier. En lan\u00e7ant la commande npm install , toutes les d\u00e9pendances inscrites dans le fichier package.json seront install\u00e9es dans la version sp\u00e9cifi\u00e9. Ce fichier est un fichier de configuration, il sert \u00e9galement \u00e0 d'autres choses. Pour le cr\u00e9er, il faut ex\u00e9cuter la commande npm init . Lorsqu'on installe ou d\u00e9sinstalle une d\u00e9pendance, elle n'est pas renseign\u00e9e dans le fichier package.json . Pour que ce soit le cas il faut ajouter --save , par exemple npm install jquery --save et jquery sera inscrit dans les d\u00e9pendances avec son num\u00e9ro de version. Il y a deux types de d\u00e9pendances : - les d\u00e9pendances classiques dont notre code a besoin, comme par exemple jquery . Elles sont rensiegn\u00e9es donc dependencies - les d\u00e9pendances de d\u00e9veloppement qui correspond aux outils de d\u00e9veloppement, par exemple webpack que l'on verra au prochain chapitre. Elles sont rensiegn\u00e9es donc devDependencies . Pour cela, il faut utiliser la commande --save-dev , par exemple npm install --save-dev webpack webpack-cli En installant webpack , il y a maintenant plein de d\u00e9pendances dans node_modules car webpack a besoin d'autres d\u00e9pendances qui ont \u00e9t\u00e9 install\u00e9 \u00e9galement.","title":"Le fichier package.json"},{"location":"developpementModerneJavascript/#webpack","text":"","title":"Webpack"},{"location":"developpementModerneJavascript/#quest-ce-que-webpack","text":"Il est principalement utilis\u00e9 comme module bundler , c'est-\u00e0-dire qu'il va prendre tous nos fichiers pour faire un seul gros fichier. Ce fichier pourra \u00eatre inclus dans le fichier HTML, ce qui permet d'utiliser les modules ES6 directement avec webpack tout en \u00e9tant compatible avec les navigateurs anciens. Il faut cr\u00e9er un fichier de configuration webpack.config.js module.exports = { entry: \"./script.js\", // dit \u00e0 webpack le point d'entr\u00e9e de notre projet output: { filename: \"bundle.js\" // dit \u00e0 webpack le nom du fichier produit } } Il faut ensuite indiquer dans le fichier HTML que le fichier de script \u00e0 utiliser est celui cr\u00e9\u00e9 par webpack. On peut aussi enlever la d\u00e9pendance jquery du fichier HTML et l'importer dans le script o\u00f9 on l'utilise, webpack l'embarquera dans le fichier bundle.js qu'il va g\u00e9n\u00e9rer dans un dossier dist (pour distribution). <!DOCTYPE html> <html> <head> <title>NPM</title> <meta charset=\"UTF-8\"> </head> <body> <script src=\"./dist/bundle.js\"></script> </body> </html> // script.js import {myLog} from \"./external.js\" import jQuery from \"jquery\" myLog(\"Hello !\") jQuery(document).ready(function(){ console.log(\"jQuery est pr\u00eat !\"); }); // external.js export const myLog = message => console.log(`** My Log ** : ${message}`)","title":"Qu'est-ce que Webpack"},{"location":"developpementModerneJavascript/#executer-webpack","text":"On va lancer l'ex\u00e9cutable de webpack. Dans le dossier .bin de node_modules, il y a tous les ex\u00e9cutables. Pour lancer webpack, on va ex\u00e9cuter la commande node_modules/.bin/webpack . Le fichier bundle.js a \u00e9t\u00e9 cr\u00e9\u00e9 en enpaquetant nos fichiers javscript. On peut lancer notre page HTML et \u00e7a fonctionne comme avant san utiliser les modules. Pour \u00e9viter de lancer la commande node_modules/.bin/webpack \u00e0 chaque fois, on va cr\u00e9er une t\u00e2che dans le fichier package.json que l'on pourra ex\u00e9cuter \u00e0 la place de cette commande. Pour exc\u00e9cuter la t\u00e2che, on lancera la commande npm run build // package.json \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"build\": \"webpack\" // ajout de la t\u00e2che build qui cr\u00e9e notre fichier bundle.js } ``` On peut faire mieux en disant \u00e0 webpack d'observer notre code et de recompiler le code pour recr\u00e9er *bundle.js* quand il observe des modifications sans relancer la commande de build. Pour cela, on va ajouter une propri\u00e9t\u00e9 dans le fichier de configuration de webpack. Lorsqu'on fait une modification et que l'on sauvegarde, il n'y a plus qu'\u00e0 rafra\u00eechir la page HTML pour voir le changement. ```js // webpack.config.js module.exports = { watch: true, // ajout de cette prori\u00e9t\u00e9 pour que webpack observe notre code et recompile lorsqu'il y a des changements entry: \"./script.js\", output: { filename: \"bundle.js\" } }","title":"Ex\u00e9cuter Webpack"},{"location":"developpementModerneJavascript/#serveur-local-webpack","text":"Pour \u00e9viter d'avoir \u00e0 recharger la page HTML \u00e0 chaque modification du code JavaScript, on va mettre en place un serveur de d\u00e9veloppement local. On va installer un nouveau paquet avec la commande npm install --save-dev webpack-dev-server . On va ex\u00e9cuter la commande node_modules/.bin/webpack-dev-server qui compile notre code et le met \u00e0 disposition \u00e0 l'adresse localhost:8080 . En faisant des modifications dans le code et que l'on enregistre, la page est relanc\u00e9 automatiquement. On peut cr\u00e9er une t\u00e2che dans les scripts dans le fichier package.json : \"start\": \"webpack-dev-server --open\" . --open permet de lancer la page HTML dans le navigateur avec la commannde npm run start .","title":"Serveur local Webpack"},{"location":"developpementModerneJavascript/#architecture-des-fichiers","text":"Pour le moment, tous les fichiers sont mis \u00e0 la racine du projet. On va r\u00e9organiser tout \u00e7a un dossier src qui contient le code de d\u00e9veloppement, les fichiers sources JavaScript un dossier dist qui contient le code de distribution que voit le public, le fichier index.html et le fichier bundle.js Il faut mettre \u00e0 jour le fichier de configuration de webpack pour que \u00e7a fonctionne bien // webpack.config.js const path = require(\"path\") // permet de cr\u00e9er des chemins absolus \u00e0 partir des chemins relatifs car webpack attend \u00e0 certains endroits des chemins absolus module.exports = { watch: true, entry: \"./src/script.js\", // dit \u00e0 webpack le point d'entr\u00e9e de notre projet output: { path: path.resolve(__dirname, \"dist\"), filename: \"bundle.js\" // dit \u00e0 webpack le nom du fichier produit }, devServer: { contentBase: path.resolve(__dirname, \"dist\"), // dit au serveur de nous servir ce qu'il y a dans le dossier dist au lieu de la racine du projet open: true // lance le navigateur automatiquement au lancement du serveur, ce qui \u00e9vite de mettre --open dans la t\u00e2che } } // index.html <!DOCTYPE html> <html> <head> <title>NPM</title> <meta charset=\"UTF-8\"> </head> <body> <script src=\"bundle.js\"></script> </body> </html>","title":"Architecture des fichiers"},{"location":"developpementModerneJavascript/#babel","text":"","title":"Babel"},{"location":"developpementModerneJavascript/#quest-ce-que-babel","text":"Babel est un transpileur qui va traduire notre code ES6-ES7 en ES5 \u00e9quivalent, ce qui nous permettra d'\u00eatre compatible avec les anciennes versions des navigateurs.","title":"Qu'est-ce que Babel"},{"location":"developpementModerneJavascript/#babel-loader","text":"C'est une fonctionnalit\u00e9 de webpack qui va permettre de transpiler le code en ES5 au moment de la cr\u00e9ation du fichier bundle.js . Il faut commencer par installer les d\u00e9pendances n\u00e9cessaires npm install --save-dev babel-loader babel-core babel-preset-env . Il faut ensuite mettre \u00e0 jour le fichier de configuration de webpack en ajoutant une partie. // webpack.config.js module: { rules: [ { // on teste si c'est un fichier JS test: /\\.js$/, // on ne traite pas les fichiers dans node_modules exclude: /node_modules/, use: { loader: \"babel-loader\", options: { presets: [\"env\"] } } } ] }","title":"Babel loader"},{"location":"developpementModerneJavascript/#babel-polyfill","text":"ES6-ES7 n'apportent pas que de la nouvelle syntaxe mais aussi de nouveaux \u00e9l\u00e9ments. Quand on utilise un nouvel \u00e9l\u00e9ment ES6, on ne peut pas le traduire en ES5, ce qui peut poser des probl\u00e8mes de compatibilit\u00e9 avec les anciens navigateurs. Dans ce cas, on peut utiliser un polyfill , qui est un bout de code qui contient ces nouveaux \u00e9l\u00e9ments, ce qui permet d'ajouter les \u00e9l\u00e9ments manquants au navigateur. On va utiliser Babel polyfill. Il faut commencer par l'installer avec la commande npm install --save babel-polyfill . Il faut ensuite mettre \u00e0 jour le fichier de configuration de webpack en ajoutant babel-polyfill dans les fichiers en entr\u00e9e. Il faut aussi importer babel-polyfill dans le fichier d'entr\u00e9e JavaScript. // webpack.config.js module.exports = { watch: true, entry: [\"babel-polyfill\", \"./src/script.js\"], // dit \u00e0 webpack le point d'entr\u00e9e de notre projet output: { path: path.resolve(__dirname, \"dist\"), filename: \"bundle.js\" // dit \u00e0 webpack le nom du fichier produit } // script.js import \"babel-polyfill\" import {myLog} from \"./external.js\" myLog(\"Hello !\")","title":"Babel polyfill"},{"location":"frameworksJavascript/","text":"Les biblioth\u00e8ques et frameworks JavaScript Qu'est-ce qu'un framework et quelle est la diff\u00e9rence entre une biblioth\u00e8que et un framework ? Un framework est une structure pour d\u00e9velopper, c'est un cadre de travail qui va structurer le travail du d\u00e9veloppeur. Les frameworks font gagner du temps en prenant en charge les besoins r\u00e9curents comme l'architecture du projet, ce qui permet de se focaliser sur le m\u00e9tier du projet. Une biblioth\u00e8que et un framework ont tous les deux pour but de faciliter le d\u00e9veloppement. Pour les diff\u00e9rencier, on peut r\u00e9sumer en disant que notre code utilise une biblioth\u00e8que pour fonctionner alors qu'un framework utilise notre code pour fonctionner et cr\u00e9er l'ensemble de notre code. En g\u00e9n\u00e9ral, une biblioth\u00e8que est un ensemble de fonctions et d'objets que notre code va utiliser en important la biblioth\u00e8que, par exemple jQuery. D\u00e9couverte de React D\u00e9couverte d'Angular D\u00e9couverte de Vue.js Angular, React ou Vue.js D\u00e9couverte de Node.js D\u00e9couverte d'Express D\u00e9couverte de MongoDB D\u00e9couverte de MEAN et de Meteor (?)","title":"Les bib"},{"location":"frameworksJavascript/#les-bibliotheques-et-frameworks-javascript","text":"","title":"Les biblioth\u00e8ques et frameworks JavaScript"},{"location":"frameworksJavascript/#quest-ce-quun-framework-et-quelle-est-la-difference-entre-une-bibliotheque-et-un-framework","text":"Un framework est une structure pour d\u00e9velopper, c'est un cadre de travail qui va structurer le travail du d\u00e9veloppeur. Les frameworks font gagner du temps en prenant en charge les besoins r\u00e9curents comme l'architecture du projet, ce qui permet de se focaliser sur le m\u00e9tier du projet. Une biblioth\u00e8que et un framework ont tous les deux pour but de faciliter le d\u00e9veloppement. Pour les diff\u00e9rencier, on peut r\u00e9sumer en disant que notre code utilise une biblioth\u00e8que pour fonctionner alors qu'un framework utilise notre code pour fonctionner et cr\u00e9er l'ensemble de notre code. En g\u00e9n\u00e9ral, une biblioth\u00e8que est un ensemble de fonctions et d'objets que notre code va utiliser en important la biblioth\u00e8que, par exemple jQuery.","title":"Qu'est-ce qu'un framework et quelle est la diff\u00e9rence entre une biblioth\u00e8que et un framework ?"},{"location":"frameworksJavascript/#decouverte-de-react","text":"","title":"D\u00e9couverte de React"},{"location":"frameworksJavascript/#decouverte-dangular","text":"","title":"D\u00e9couverte d'Angular"},{"location":"frameworksJavascript/#decouverte-de-vuejs","text":"","title":"D\u00e9couverte de Vue.js"},{"location":"frameworksJavascript/#angular-react-ou-vuejs","text":"","title":"Angular, React ou Vue.js"},{"location":"frameworksJavascript/#decouverte-de-nodejs","text":"","title":"D\u00e9couverte de Node.js"},{"location":"frameworksJavascript/#decouverte-dexpress","text":"","title":"D\u00e9couverte d'Express"},{"location":"frameworksJavascript/#decouverte-de-mongodb","text":"","title":"D\u00e9couverte de MongoDB"},{"location":"frameworksJavascript/#decouverte-de-mean-et-de-meteor","text":"","title":"D\u00e9couverte de MEAN et de Meteor (?)"},{"location":"javascriptDebarqueDansLeNavigateur/","text":"JavaScript d\u00e9barque dans le navigateur JavaScript dans le navigateur L'objet Window Lorsque JavaScript est ex\u00e9cut\u00e9 dans le navigateur, l'objet global est Window. Il repr\u00e9sente la fen\u00eatre du navigateur. Il poss\u00e8de des propri\u00e9t\u00e9s et des m\u00e9thodes. On peut y acc\u00e9der directement sans mettre le mot window car c'est l'objet global (il est dit implicite). // affiche la largeur du navigateur console.log(window.innerWidth) console.log(innerWidth) alert() n'est pas une fonction mais une m\u00e9thode de l'objet window. window.alert('Hello World') est \u00e9quivalent \u00e0 alert('Hello World') en revanche isNan() ou parseInt ne d\u00e9pendent pas d'un objet, ce sont des fonctions globales. Il n'y en a pas beaucoup lorsqu'on d\u00e9clare une variable dans le contexte global du script, cette variable devient une propri\u00e9t\u00e9 de l'objet window toute variable non d\u00e9clar\u00e9e (utilis\u00e9e sans \u00e9crire le mot-cl\u00e9 var) devient une propri\u00e9t\u00e9 de window, quelque soit l'endroit o\u00f9 on se situe. Ecrire text = 'toto' revient donc \u00e0 \u00e9crire window.text = 'toto'. Il est conseill\u00e9 de toujours d\u00e9clarer une variable avec var. Pour d\u00e9clarer une variable globale dans une fonction, on pourra sp\u00e9cifier explicitement l'objet window L'objet Location C'est une propri\u00e9t\u00e9 de l'objet global Window. Il a lui-m\u00eame des propri\u00e9t\u00e9s et des m\u00e9thodes. Il contient des informations sur o\u00f9 se trouve notre navigateur (URL, etc...). location.reload() // relancer la page location.replace(\"URL\") // permet de change d'URL L'objet Document : le DOM C'est une propri\u00e9t\u00e9 de l'objet Window. C'est la repr\u00e9sentation de notre page HTML, plus pr\u00e9cisemment la la balise <html> . Avec JavaScript, on va manipuler le DOM. On peut voir les propri\u00e9t\u00e9s de l'objet document avec la commande console.log(window) et le contenu de l'objet document avec la commande console.log(window.document) . Le document a des propri\u00e9t\u00e9s que l'on peut modifier, ajouter, d\u00e9placer, supprimer. Par exemple le titre de la page : console.log(document.title) // affiche : JavaScript (titre pr\u00e9sent dans la page HTML) document.title = \"Mon nouveau titre\" console.log(document.title) // affiche : Mon nouveau titre console.log(document.body) // affiche le body Petit historique Le DOM est une interface de programmation pour les documents XML et HTML, qui permet via le JavaScript d'acc\u00e9der au code XML et/ou HTML d'un document. On peut modifier, ajouter, d\u00e9placer, supprimer des \u00e9l\u00e9ments HTML (une paire de balises HTML) Au d\u00e9but du JavaScript, le DOM n'\u00e9tait pas unifi\u00e9, c'est-\u00e0-dire que deux navigateurs poss\u00e9daient un DOM diff\u00e9rent, donc la mani\u00e8re d'acc\u00e9der \u00e0 un \u00e9l\u00e9ment HTML diff\u00e9rait d'un navigateur \u00e0 l'autre. Il fallait donc coder diff\u00e9remment en fonction du navigateur. Le W3C a publi\u00e9 une nouvelle sp\u00e9cification DOM-1, pour DOM Level 1 qui d\u00e9finit le DOM et comment sont sch\u00e9matis\u00e9s les documents HTML et XML, sous forme d'un arbre, ou d'une hi\u00e9rarchie. L'\u00e9l\u00e9ment contient 2 \u00e9l\u00e9ments enfants : et , etc... Ensuite, la sp\u00e9cification DOM-2 a \u00e9t\u00e9 publi\u00e9 avec l'introduction de la m\u00e9thode getElementById() qui permet de r\u00e9cup\u00e9rer un \u00e9l\u00e9ment en connaissant son ID. La structure DOM Le DOM pose comme concept que la page Web est une hi\u00e9rarchie d'\u00e9l\u00e9ments. On peut sch\u00e9matiser une page web comme ceci : Voici le code source correspondant : <!doctype html> <html> <head> <meta charset=\"utf-8\" /> <title>Le titre de la page</title> </head> <body> <div> <p>Du texte <a>et un lien</a></p> </div> </body> </html> L'\u00e9l\u00e9ment <html> contient deux \u00e9l\u00e9ments, appel\u00e9s enfants : <head> et <body> . Pour ces deux enfants, <html> est l'\u00e9l\u00e9ment parent . Chaque \u00e9l\u00e9ment est appel\u00e9 noeud ( node en anglais). <title> contient un \u00e9l\u00e9ment enfant #text qui contient du texte. Le texte pr\u00e9sent dans une page Web est vu par le DOM comme on noeud de type #text . JavaScript et le DOM L'h\u00e9ritage des propri\u00e9t\u00e9s et des m\u00e9thodes Les \u00e9l\u00e9ments HTML sont vus par JavaScript comme des objets poss\u00e9dant des propri\u00e9t\u00e9s et des m\u00e9thodes. Tous ne poss\u00e8dent pas les m\u00eames propri\u00e9t\u00e9s et m\u00e9thodes. Certaines sont communes car tous les \u00e9l\u00e9ments HTML sont d'un m\u00eame type : Node. Une est un objet HTTMLDivElement, sous-objet HTMLElement, lui-m\u00eame sous-objet d'Element, lui-m\u00eame sous-objet de Node. Les m\u00e9thodes et propri\u00e9t\u00e9s de Node peuvent \u00eatre utilis\u00e9es depuis ses sous-objets gr\u00e2ce \u00e0 l'h\u00e9ritage. Hi\u00e9rarchie des \u00e9l\u00e9ments children renvoie une HTML Collection (un peu comme un tableau) des enfants de l'\u00e9l\u00e9ment firstElementChild et lastElementChild renvoient le premier et le dernier enfant de l'\u00e9l\u00e9ment nextElementSibling renvoie le prochain \u00e9l\u00e9ment de m\u00eame niveau parentElement renvoie l'\u00e9l\u00e9ment parent <body> <div> <p>Mon paragraphe 1</p> <p>Mon paragraphe 2</p> </div> <script src=\"script.js\"></script> </body> console.log(document.body.children) // [div, script] console.log(document.body.children[0].children) // [p, p] console.log(document.body.firstElementChild) // \u00e9quivalent \u00e0 children[0], retourne la div console.log(document.body.children[0].nextElementSibling) // affiche le script console.log(document.body.children[0].parentElement) // affiche le body R\u00e9cup\u00e9rer et modifier les \u00e9l\u00e9ments Un console.log() d'un \u00e9l\u00e9ment du DOM affiche la repr\u00e9sentation HTML de l'\u00e9l\u00e9ment, mais on ne voit pas ses propri\u00e9t\u00e9s. Pour voir les propri\u00e9t\u00e9s et m\u00e9thodes d'un \u00e9l\u00e9ment, il faut afficher tous les enfants de l'\u00e9l\u00e9ment parent et cliquer sur l'\u00e9l\u00e9ment enfant qui nous int\u00e9resse dans la console. console.log(document.body.children[0].children[1]) // affiche <p>Mon paragraphe 2</p> console.log(document.body.children[0].children) // affiche l'HTML Collection avec ses 2 enfants. On peut cliquer sur chaque enfant pour voir ses attributs et m\u00e9thodes Le contenu : innerHTML innerHTML permet de r\u00e9cup\u00e9rer le code HTML enfant d'un \u00e9l\u00e9ment sous forme de texte. Si les balises sont pr\u00e9sentes, innerHTML les retournera sous forme de texte. Exemple : <body> <div id=\"myDiv\"> <p>Un peu de texte <a>et un lien</a></p> </div> <script> const div = document.getElementById('myDiv') console.log(div.innerHTML) // affiche : <p>Un peu de texte <a>et un lien</a></p> </script> </body> Autre exemple o\u00f9 l'on va modifier le contenu du paragraphe : console.log(document.body.children[0].children[0].innerHTML) // affiche Un peu de texte <a>et un lien</a> document.body.children[0].children[0].innerHTML = \"<strong>Nouveau Texte</strong>\" console.log(document.body.children[0].children[0].innerHTML) // affiche Nouveau Texte (en gras car les les balises strong sont interpr\u00e9t\u00e9es par le navigateur pour mettre le texte en gras) Il est aussi possible d'ajouter ou d'\u00e9diter du HTML document.getElementById('myDiv').innerHTML = '<blockquote>Je mets une citation \u00e0 la place du paragraphe</blockquote>' document.getElementById('myDiv').innerHTML += ' et <strong>une portion mise en emphase</strong>.' Il ne faut pas l'utiliser dans une boucle car innerHTML ralentit l'ex\u00e9cution du code. Il vaut mieux la concat\u00e9ner dans une variable et ensuite ajouter le tout via innerHTML . innerText et textContent innerText pour IE et textContent pour les autres navigateurs sont des propri\u00e9t\u00e9s analogues \u00e0 innerHTML , qui permettent de r\u00e9cup\u00e9rer le contenu d'un \u00e9l\u00e9ment sous forme de texte mais sans les balises , et permet aussi de modifier le contenu de l'\u00e9l\u00e9ment. innerText a \u00e9t\u00e9 introduite dans IE, mais jamais standardis\u00e9e et n'est pas suport\u00e9e par tous les navigateurs textContent est la version standardis\u00e9e d' innerText . Elle est reconnue par tous les navigateurs \u00e0 l'exception des versions ant\u00e9rieures \u00e0 IE9. console.log(document.body.children[0].children[0].textContent) // affiche Un peu de texte et un lien document.body.children[0].children[0].textContent = \"<strong>Nouveau Texte</strong>\" // les balises ne sont pas interpr\u00e9t\u00e9s par le navigateur mais \u00e9crites comme du texte affich\u00e9 dans le navigateur console.log(document.body.children[0].children[0].textContent) // affiche <strong>Nouveau Texte</strong> Modifier le style La propri\u00e9t\u00e9 style permet de modifier le style CSS des \u00e9l\u00e9ments. Les types correspondent au CSS sauf qu'il faut les \u00e9crire en kamel case. Par exemple \u00e9crire backgroundColor en JavaScript au lieu de background-color en CSS. document.body.children[0].style.backgroundColor = \"red\" // mais le fond de la div en rouge Modifier les classes CSS <body> <div class=\"super\"> <p>Mon paragraphe 1</p> <p>Mon paragraphe 2</p> </div> <script src=\"script.js\"></script> </body> classList permet d'avoir la liste des classes CSS que poss\u00e8de un \u00e9l\u00e9ment. Les m\u00e9thodes add() et remove() permettent d'ajouter et d'enlever des classes CSS. toggle() permet d'enlever la classe si elle pr\u00e9sente et de l'ajouter si elle n'y est pas. console.log(document.body.children[0].classList) // affiche [\"super\"] document.body.children[0].classList.add(\"toto\") // ajoute la classe toto \u00e0 la div et applique son style console.log(document.body.children[0].classList) // affiche [\"super\", \"toto\"] document.body.children[0].classList.remove(\"toto\") // enl\u00e8ve la classe toto de la div et enl\u00e8ve son style console.log(document.body.children[0].classList) // affiche [\"super\"] document.body.children[0].classList.toggle(\"toto\") console.log(document.body.children[0].classList) // affiche [\"super\", \"toto\"] document.body.children[0].classList.toggle(\"toto\") console.log(document.body.children[0].classList) // affiche [\"super\"] On peut aussi utiliser className pour appliquer une classe CSS \u00e0 un \u00e9l\u00e9ment : document.getElementById('p1').className = 'bleu' Modifier les attributs Un attribut correspond aux informations pr\u00e9sentes dans une balise, par exemple src dans la balise script : <script src=\"index.js\"></script> . Les m\u00e9thodes getAttribute() et setAttribute() permettent de r\u00e9cup\u00e9rer et modifier un attribut d'un \u00e9l\u00e9ment HTML. console.log(document.body.children[1].getAttribute(\"src\")) // affiche index.js document.body.children[1].setAttribute(\"src\", \"toto.js\") // modifie la valeur de l'attribut renseign\u00e9e console.log(document.body.children[1].getAttribute(\"src\")) // affiche toto.js S\u00e9lectionner les \u00e9l\u00e9ments Pour s\u00e9lectionner un \u00e9l\u00e9ment, on peut le faire plus simplement qu'en partant de body et en descendant avec children . La m\u00e9thode getElementById() de l'objet document permet de s\u00e9lectionner un \u00e9l\u00e9ment par son id, getElementsByTagName() s\u00e9lectionne les \u00e9l\u00e9ments qui correspondent \u00e0 un tag HTML, par exemple h1 ou p , et getElementsByClassName() s\u00e9lectionne les \u00e9l\u00e9ments qui correspondent \u00e0 une classe CSS. On peut aussi stocker les \u00e9l\u00e9ments dans une variable. <body> <div class=\"super\"> <h1 id=\"titre\">Mon Titre</h1> <p class=\"maClasse\">Mon paragraphe 1</p> <p>Mon paragraphe 2</p> </div> <script src=\"script.js\"></script> </body> console.log(document.getElementById(\"titre\")) // affiche <h1 id=\"titre\">Mon Titre</h1> console.log(document.getElementsByTagName(\"p\")) // affiche une HTML Collection avec les 2 paragraphes console.log(document.getElementsByClassName(\"maClasse\")) // affiche une HTML Collection avec l'\u00e9l\u00e9ment qui a cette classe const monTitre = document.getElementById(\"titre\") console.log(monTitre) // affiche <h1 id=\"titre\">Mon Titre</h1> S\u00e9lectionner avec Query Selector La m\u00e9thode querySelector() permet d'utiliser les s\u00e9lecteurs CSS pour s\u00e9lectionner un \u00e9l\u00e9ment. Si plusieurs \u00e9l\u00e9ments correspondent, seul le premier \u00e9l\u00e9ment sera s\u00e9lectionn\u00e9. La m\u00e9thode querySelectorAll() renvoie une liste, et permet donc de s\u00e9lectionner plusieurs \u00e9l\u00e9ments. console.log(document.querySelector(\".maClasse\")) // affiche <p class=\"maClasse\">Mon paragraphe 1</p> console.log(document.querySelectorAll(\".maClasse\")) // affiche une NodeList d'un \u00e9l\u00e9ment avec le paragraphe 1 console.log(document.querySelector(\"p\")) // affiche <p class=\"maClasse\">Mon paragraphe 1</p> (le 1er paragraphe rencontr\u00e9) console.log(document.querySelectorAll(\"p\")) // affiche une NodeList de deux \u00e9l\u00e9ments avec les paragraphes Modifier l'ordre des \u00e9l\u00e9ments La m\u00e9thode insertBefore() permet d'ins\u00e9rer un \u00e9l\u00e9ment HTML avant un autre \u00e9l\u00e9ment. Si l'\u00e9l\u00e9ment existe d\u00e9j\u00e0, il est d'abord supprim\u00e9 avant d'\u00eatre replac\u00e9. La m\u00e9thode appendChild() permet d'ajouter un \u00e9l\u00e9ment \u00e0 un autre \u00e9l\u00e9ment en tant qu'enfant. La m\u00e9thode replaceChild() permet de remplacer un \u00e9l\u00e9ment enfant par un autre. La m\u00e9thode removeChild() permet de supprimer un \u00e9l\u00e9ment, remove() le permet aussi de mani\u00e8re plus simple mais n'est pas support\u00e9 par les anciennes versions des navigateurs. <link rel=\"stylesheet\" href=\"style.css\"> <body> <div class=\"rouge\">Rouge</div> <div class=\"vert\">Vert</div> <div class=\"bleu\">Bleu</div> <script src=\"script.js\"></script> </body> .rouge, .vert, .bleu { width: 300px; height: 100px; color: white; font-size: 40px; text-align: center; } .rouge { background-color: red; } .vert { background-color: green; } .bleu { background-color: blue; } const rouge = document.querySelector(\".rouge\") const vert = document.querySelector(\".vert\") const bleu = document.querySelector(\".bleu\") document.body.insertBefore(bleu,vert) // ins\u00e8re l'\u00e9l\u00e9ment bleu avant l'\u00e9l\u00e9ment vert rouge.appendChild(bleu) // ajoute l'\u00e9l\u00e9ment bleu en tant qu'enfant de rouge document.body.replaceChild(bleu, rouge) // remplace l'\u00e9l\u00e9ment rouge par l'\u00e9l\u00e9ment bleu bleu.parentElement.removeChild(bleu) // permet de supprimer l'\u00e9l\u00e9ment bleu bleu.remove() // permet aussi de supprimer l'\u00e9l\u00e9ment bleu mais n'est pas support\u00e9 par les anciens navigateurs Cr\u00e9er des \u00e9l\u00e9ments Pour cr\u00e9er un \u00e9l\u00e9ment, on va utiliser la m\u00e9thode createElement() que l'on va ensuite ins\u00e9rer dans le DOM avec la m\u00e9thode appendChild() /* creation d'une classe CSS jaune que l'on va appliquer sur un \u00e9l\u00e9ment que l'on va cr\u00e9er en JS */ .jaune { width: 300px; height: 100px; color: white; font-size: 40px; text-align: center; background-color: yellow } const jaune = document.createElement(\"div\") //cr\u00e9ation d'un \u00e9l\u00e9ment div jaune.classList.add(\"jaune\") // application de la classe jaune sur la div jaune.textContent = \"Jaune\" // ajout du texte Jaune dans la div document.body.appendChild(jaune) // insertion de l'\u00e9l\u00e9ment jaune en tant qu'enfant du body Exemple de cr\u00e9ation d'une fonction qui cr\u00e9e des \u00e9l\u00e9ments que l'on va appeler plusieurs fois pour remplir une liste <body> <ul></ul> <script src=\"script.js\"></script> </body> function planifierTache(heure, tache){ const nouvelleTache = document.createElement(\"li\") nouvelleTache.innerHTML = `<h3>${heure}</h3><p>${tache}</p>` // innerHTML permet de dire le code HTML que l'on veut mettre \u00e0 l'int\u00e9rieur d'un \u00e9l\u00e9ment HTML document.querySelector(\"ul\").appendChild(nouvelleTache) } planifierTache('7h30', 'R\u00e9veil') planifierTache('7h40', 'Petit-d\u00e9jeuner') planifierTache('8h00', 'Douche') Les \u00e9v\u00e9nements Javascript Qu'est-ce qu'un \u00e9v\u00e9nement ? Les \u00e9v\u00e9nements permettent de d\u00e9clencher une fonction selon qu'une action s'est produite ou non, par exemple faire appara\u00eetre une fen\u00eatre alert() au survol d'une zone d'un \u00e9l\u00e9ment. Ils sont de diff\u00e9rentes natures, par exemple : cliquer sur un \u00e9l\u00e9ment appuyer sur une touche du clavier lorsque le navigateur a fini de charger la page Web Un \u00e9v\u00e9nement est bas\u00e9 sur l'interface Event , avec par exemple les classes MouseEvent et KeyboardEvent pour les \u00e9v\u00e9nements li\u00e9s \u00e0 la souris et au clavier. On-Event Handler <body> <div class=\"rouge\">Rouge</div> <div class=\"vert\">Vert</div> <div class=\"bleu\">Bleu</div> <script src=\"index.js\"></script> </body> console.log(rouge) // affiche <div class=\"rouge\">Rouge</div> console.log(rouge.parentElement.children) // affiche la collection HTML des \u00e9l\u00e9m\u00e9nts enfants du parent, dont rouge, pour lesquels on peut voir les propri\u00e9t\u00e9s et m\u00e9thodes Les propri\u00e9t\u00e9s qui commencent par on sont li\u00e9s aux \u00e9v\u00e9nements. Elles sont appel\u00e9es On-Event Handler , que l'on peut traduire par gestionnaire d'\u00e9v\u00e9nements . Par exemple, la propri\u00e9t\u00e9 onload g\u00e8re l'\u00e9v\u00e9nement load . L'\u00e9v\u00e9nement load se produit quand la page a fini de se charger : window.onload = function(){ console.log(\"la page est charg\u00e9e\") } console.log(\"apr\u00e8s le onload\") // s'affiche AVANT \"la page est charg\u00e9e\" On peut aussi d\u00e9clarer une fonction et l'appeler sur la propri\u00e9t\u00e9 onload : function windowReady(){ console.log(\"la page est charg\u00e9e\") } window.onload = windowReady() On peut encapsuler tout le code JS dans un windows.onload pour s'assurer que tous les \u00e9l\u00e9ments que l'on manipule sont charg\u00e9s : window.onload = function(){ const rouge = document.querySelector(\".rouge\") const vert = document.querySelector(\".vert\") const bleu = document.querySelector(\".bleu\") } Exemple de l'\u00e9v\u00e9nement clic, d\u00e9clench\u00e9 \u00e0 chaque clic sur l'\u00e9l\u00e9ment rouge : rouge.onclick = function(event){ console.log(\"clic sur la div rouge !\") console.log(event) } On peut r\u00e9cup\u00e9rer l'\u00e9v\u00e9nement en le passant en argument de la fonction en lui donnant le nom que l'on veut car le fait de mettre un argument \u00e0 la fonction nous donne forc\u00e9ment l'\u00e9v\u00e9nement. On peut \u00e9crire les Event Handler directement dans le code HTML, ce qui n'est pas conseill\u00e9 : <div class=\"vert\" onclick=\"console.log('toto')\">Vert</div> On ne peut pas d\u00e9finir plusieurs fois le m\u00eame event handler sur le m\u00eame \u00e9l\u00e9ment. Auquel cas, seul le dernier event handler va fonctionner car c'est une propri\u00e9t\u00e9 \u00e0 laquelle on attache une fonction, donc la derni\u00e8re a \u00e9cras\u00e9e les pr\u00e9c\u00e9dentes. rouge.onclick = function(event){ console.log(\"clic sur la div rouge !\") console.log(event) } rouge.onclick = function(){ console.log(\"deuxi\u00e8me message\") // seul ce message va s'afficher } Event Listener Un Event Listener , ou \u00e9couteur d'\u00e9v\u00e9nement en fran\u00e7ais, est une autre fa\u00e7on d'interagir avec les \u00e9v\u00e9nements. Il faut utiliser la m\u00e9thode addEventListener() qui prend en argument le nom de l'\u00e9v\u00e9nementet la fonction a ex\u00e9cuter : rouge.addEventListener(\"click\", function(event){ console.log(\"clic sur la div rouge !\") console.log(event) }) function afficherMessage(){ console.log(\"deuxi\u00e8me message\") } rouge.addEventListener(\"click\", afficherMessage) On peut ajouter plusieurs event listener sur le m\u00eame \u00e9v\u00e9nement et sur le m\u00eame \u00e9l\u00e9ment, ils seront tous ex\u00e9cut\u00e9s. On peut aussi d\u00e9clarer une fonction en externe et l'appeler dans le listener sans l'ex\u00e9cuter , juste en marquant son nom. La fonction anonyme en argument n'\u00e9tait pas \u00e9ex\u00e9cut\u00e9e non plus, le listeneur le fait quand l'\u00e9v\u00e9nement a lieu. On peut aussi supprimer un event listener avec removeEventListener() . Dans l'exemple suivant, quand on clique sur vert, on enl\u00e8ve le deuxi\u00e8me event listener de rouge, et quand on clique ensuite sur rouge, il n'y a plus que le premier qui s'ex\u00e9cute : vert.addEventListener(\"click\", function(){ rouge.removeEventListener(\"click\", afficherMessage) }) Propagation des \u00e9v\u00e9nements <div id=\"parent\"> <div id=\"enfant\"></div> </div> <script src=\"index.js\"></script> #parent { width: 300px; height: 300px; background-color: red; } #enfant { width: 100px; height: 100px; background-color: blue; } const parent = document.querySelector(\"#parent\") const enfant = document.querySelector(\"#enfant\") parent.addEventListener(\"click\", parentFonction) enfant.addEventListener(\"click\", enfantFonction) function enfantFonction(){ console.log(\"clic sur l'enfant\") } function parentFonction(){ console.log(\"clic sur le parent\") } Dans cet exemple, il y a une div bleu enfant contenu dans une div rouge rouge. Lorsqu'on clique sur la div parent, clic sur le parent s'\u00e9crit dans la log, et lorsqu'on clique sur la div enfant, clic sur l'enfant puis clic sur le parent s'affichent car l'enfant est contenu dans le parent. Les \u00e9v\u00e9nements sont faits de deix phases : - phase de capture : part des parents et va vers les enfants - phase de bouillonnement ( event bubbling ) : part de l'enfant et va vers les parents Par d\u00e9faut, addEventListener s'ex\u00e9cute pendant la phase de bouillenement (les \u00e9v\u00e9nements d\u00e9butent par les enfants et remontent vers les parents). Pour qu'elle s'ex\u00e9cute pendant la phase de capture, il faut ajouter un troi\u00e8me argument true \u00e0 la m\u00e9thode addEventListener . Dans l\"exemple suivant, lorsqu'on clique sur la div enfant, clic sur parent s'affiche donc avant clic sur enfant : parent.addEventListener(\"click\", parentFonction, true) enfant.addEventListener(\"click\", enfantFonction, true) Propri\u00e9t\u00e9s de l'objet Event Certaines propri\u00e9t\u00e9s sont communes \u00e0 tous les \u00e9v\u00e9nements, d'autres sont sp\u00e9cifiques \u00e0 certains \u00e9v\u00e9nement comme les \u00e9v\u00e9nements souris, ou les \u00e9v\u00e9nements claviers : function parentFonction(event){ console.log(\"clic sur le parent\") console.log(event) console.log(event.type) // affiche : click, correspond au type de l'\u00e9v\u00e9nement console.log(event.target) // affiche la div parent, correspond \u00e0 l'\u00e9l\u00e9ment qui a d\u00e9but\u00e9 l'\u00e9v\u00e9nement console.log(event.currentTarget) console.log(event.clientX) // affiche o\u00f9 l'on se place sur l'axe horizontale, propri\u00e9t\u00e9 sp\u00e9cifique au MouseEvent } M\u00e9thodes de l'objet Event La m\u00e9thode stopPropagation() permet de stopper la propagation d'un \u00e9v\u00e9nement. Dans l'exemple suivant, en cliquant sur l'enfant, on ne verra que le clic sur l'enfant mais pas le clic sur le parent. L'\u00e9v\u00e9nement a \u00e9t\u00e9 stopp\u00e9 et n'a donc pas atteint la div parent. function enfantFonction(event){ console.log(\"clic sur l'enfant\") event.stopPropagation() } La m\u00e9thode preventDefault() permet de ne pas traiter l'\u00e9v\u00e9nement avec son action par d\u00e9faut. Dans l'exemple suivant, lors de la soumission du formulaire, on \u00e9crit un message dans la log. Par d\u00e9faut, la soumission d'un formulaire rafra\u00eechit la page, le message dans la log dispara\u00eet donc aussit\u00f4t qu'il est apparu. Pour ne pas rafra\u00eechir la page, on peut utiliser la m\u00e9thode preventDefault() , le message restera alors affich\u00e9 dans la log. <body> <form> <input type=\"text\" placeholder=\"Votre nom\"> <button type=\"submit\">Envoyer</button> </form> <script src=\"index.js\"></script> </body> const form = document.querySelector(\"form\") form.addEventListener(\"submit\", envoyerFormulaire) function envoyerFormulaire(event){ event.preventDefault() console.log(\"Formulaire envoy\u00e9\") } Requ\u00eates HTTP - Ajax Qu'est-ce qu'une requ\u00eate HTTP ? Ajax est un raccourci pour Asynchronous JavaScript and XML (XML et JavaScript asynchrones). Ajax permet d'\u00e9changer avec le serveur via des requ\u00eates HTTP sans rafra\u00eechir toute la page mais uniquement certains \u00e9l\u00e9ment de la page. Ces requ\u00eates fonctionnent de mani\u00e8re asynchrones, c'est-\u00e0-dire que l'on traitera la r\u00e9ponse quand elle arrive sans attendre qu'elle arrive, ce qui permet de continuer \u00e0 ex\u00e9cuter la suite du code. Requ\u00eates HTTP avec XMLHttpRequest XMLHttpRequest est l'objet qui permet de faire des requ\u00eates Ajax. C'est l'objet de base qui sert \u00e0 faire des requ\u00eates HTTP. D'autres objets se basent dessus. Lors d'une requ\u00eate HTTP, son \u00e9tat va varier, et nous pouvons r\u00e9cup\u00e9rer chaque changement de cet \u00e9tat, avec l'\u00e9v\u00e9nement onreadystatechange . L'\u00e9tat varie de 0 \u00e0 4. La requ\u00eate est termin\u00e9e \u00e0 l'\u00e9tat 4. Exemple avec l'API Jsonplaceholder sur l'URL /posts en GET : const req = new XMLHttpRequest() const method = 'GET' const url = 'https://jsonplaceholder.typicode.com/posts' req.onreadystatechange = function(event){ if(this.readyState === XMLHttpRequest.DONE){// on aurait pu \u00e9crire 4 \u00e0 la place, c'est pareil if(this.status === 200){ console.log( JSON.parse(this.responseText) ) } else { console.log(\"Statut Erreur : \"+this.status) } } } req.open(method, url) req.send() Exemple d'une requ\u00eate en POST : const req = new XMLHttpRequest() const method = 'POST' const url = 'https://jsonplaceholder.typicode.com/posts' const data = { body: \"la la la\", title: \"mon titre\", userId: 1 } req.onreadystatechange = function(event){ if(this.readyState === XMLHttpRequest.DONE){// on aurait pu \u00e9crire 4 \u00e0 la place, c'est pareil if(this.status === 201){ console.log( JSON.parse(this.responseText) ) } else { console.log(\"Statut Erreur : \"+this.status) } } } req.open(method, url) req.send(data) La m\u00e9thode open() prend en argument la m\u00e9thode HTTP puis l'url \u00e0 appeler. Il y a ensuite des arguments optionels : XMLHttpRequest.open(method, url, async, user, password) async : \u00e0 true par d\u00e9faut. On peut le mettre \u00e0 false pour faire des requ\u00eates synchrones, ce qui est d\u00e9conseill\u00e9 user et password sont null par d\u00e9faut et servent \u00e0 l'authentification","title":"Dans le nav"},{"location":"javascriptDebarqueDansLeNavigateur/#javascript-debarque-dans-le-navigateur","text":"","title":"JavaScript d\u00e9barque dans le navigateur"},{"location":"javascriptDebarqueDansLeNavigateur/#javascript-dans-le-navigateur","text":"","title":"JavaScript dans le navigateur"},{"location":"javascriptDebarqueDansLeNavigateur/#lobjet-window","text":"Lorsque JavaScript est ex\u00e9cut\u00e9 dans le navigateur, l'objet global est Window. Il repr\u00e9sente la fen\u00eatre du navigateur. Il poss\u00e8de des propri\u00e9t\u00e9s et des m\u00e9thodes. On peut y acc\u00e9der directement sans mettre le mot window car c'est l'objet global (il est dit implicite). // affiche la largeur du navigateur console.log(window.innerWidth) console.log(innerWidth) alert() n'est pas une fonction mais une m\u00e9thode de l'objet window. window.alert('Hello World') est \u00e9quivalent \u00e0 alert('Hello World') en revanche isNan() ou parseInt ne d\u00e9pendent pas d'un objet, ce sont des fonctions globales. Il n'y en a pas beaucoup lorsqu'on d\u00e9clare une variable dans le contexte global du script, cette variable devient une propri\u00e9t\u00e9 de l'objet window toute variable non d\u00e9clar\u00e9e (utilis\u00e9e sans \u00e9crire le mot-cl\u00e9 var) devient une propri\u00e9t\u00e9 de window, quelque soit l'endroit o\u00f9 on se situe. Ecrire text = 'toto' revient donc \u00e0 \u00e9crire window.text = 'toto'. Il est conseill\u00e9 de toujours d\u00e9clarer une variable avec var. Pour d\u00e9clarer une variable globale dans une fonction, on pourra sp\u00e9cifier explicitement l'objet window","title":"L'objet Window"},{"location":"javascriptDebarqueDansLeNavigateur/#lobjet-location","text":"C'est une propri\u00e9t\u00e9 de l'objet global Window. Il a lui-m\u00eame des propri\u00e9t\u00e9s et des m\u00e9thodes. Il contient des informations sur o\u00f9 se trouve notre navigateur (URL, etc...). location.reload() // relancer la page location.replace(\"URL\") // permet de change d'URL","title":"L'objet Location"},{"location":"javascriptDebarqueDansLeNavigateur/#lobjet-document-le-dom","text":"C'est une propri\u00e9t\u00e9 de l'objet Window. C'est la repr\u00e9sentation de notre page HTML, plus pr\u00e9cisemment la la balise <html> . Avec JavaScript, on va manipuler le DOM. On peut voir les propri\u00e9t\u00e9s de l'objet document avec la commande console.log(window) et le contenu de l'objet document avec la commande console.log(window.document) . Le document a des propri\u00e9t\u00e9s que l'on peut modifier, ajouter, d\u00e9placer, supprimer. Par exemple le titre de la page : console.log(document.title) // affiche : JavaScript (titre pr\u00e9sent dans la page HTML) document.title = \"Mon nouveau titre\" console.log(document.title) // affiche : Mon nouveau titre console.log(document.body) // affiche le body","title":"L'objet Document : le DOM"},{"location":"javascriptDebarqueDansLeNavigateur/#petit-historique","text":"Le DOM est une interface de programmation pour les documents XML et HTML, qui permet via le JavaScript d'acc\u00e9der au code XML et/ou HTML d'un document. On peut modifier, ajouter, d\u00e9placer, supprimer des \u00e9l\u00e9ments HTML (une paire de balises HTML) Au d\u00e9but du JavaScript, le DOM n'\u00e9tait pas unifi\u00e9, c'est-\u00e0-dire que deux navigateurs poss\u00e9daient un DOM diff\u00e9rent, donc la mani\u00e8re d'acc\u00e9der \u00e0 un \u00e9l\u00e9ment HTML diff\u00e9rait d'un navigateur \u00e0 l'autre. Il fallait donc coder diff\u00e9remment en fonction du navigateur. Le W3C a publi\u00e9 une nouvelle sp\u00e9cification DOM-1, pour DOM Level 1 qui d\u00e9finit le DOM et comment sont sch\u00e9matis\u00e9s les documents HTML et XML, sous forme d'un arbre, ou d'une hi\u00e9rarchie. L'\u00e9l\u00e9ment contient 2 \u00e9l\u00e9ments enfants : et , etc... Ensuite, la sp\u00e9cification DOM-2 a \u00e9t\u00e9 publi\u00e9 avec l'introduction de la m\u00e9thode getElementById() qui permet de r\u00e9cup\u00e9rer un \u00e9l\u00e9ment en connaissant son ID.","title":"Petit historique"},{"location":"javascriptDebarqueDansLeNavigateur/#la-structure-dom","text":"Le DOM pose comme concept que la page Web est une hi\u00e9rarchie d'\u00e9l\u00e9ments. On peut sch\u00e9matiser une page web comme ceci : Voici le code source correspondant : <!doctype html> <html> <head> <meta charset=\"utf-8\" /> <title>Le titre de la page</title> </head> <body> <div> <p>Du texte <a>et un lien</a></p> </div> </body> </html> L'\u00e9l\u00e9ment <html> contient deux \u00e9l\u00e9ments, appel\u00e9s enfants : <head> et <body> . Pour ces deux enfants, <html> est l'\u00e9l\u00e9ment parent . Chaque \u00e9l\u00e9ment est appel\u00e9 noeud ( node en anglais). <title> contient un \u00e9l\u00e9ment enfant #text qui contient du texte. Le texte pr\u00e9sent dans une page Web est vu par le DOM comme on noeud de type #text .","title":"La structure DOM"},{"location":"javascriptDebarqueDansLeNavigateur/#javascript-et-le-dom","text":"","title":"JavaScript et le DOM"},{"location":"javascriptDebarqueDansLeNavigateur/#lheritage-des-proprietes-et-des-methodes","text":"Les \u00e9l\u00e9ments HTML sont vus par JavaScript comme des objets poss\u00e9dant des propri\u00e9t\u00e9s et des m\u00e9thodes. Tous ne poss\u00e8dent pas les m\u00eames propri\u00e9t\u00e9s et m\u00e9thodes. Certaines sont communes car tous les \u00e9l\u00e9ments HTML sont d'un m\u00eame type : Node. Une est un objet HTTMLDivElement, sous-objet HTMLElement, lui-m\u00eame sous-objet d'Element, lui-m\u00eame sous-objet de Node. Les m\u00e9thodes et propri\u00e9t\u00e9s de Node peuvent \u00eatre utilis\u00e9es depuis ses sous-objets gr\u00e2ce \u00e0 l'h\u00e9ritage.","title":"L'h\u00e9ritage des propri\u00e9t\u00e9s et des m\u00e9thodes"},{"location":"javascriptDebarqueDansLeNavigateur/#hierarchie-des-elements","text":"children renvoie une HTML Collection (un peu comme un tableau) des enfants de l'\u00e9l\u00e9ment firstElementChild et lastElementChild renvoient le premier et le dernier enfant de l'\u00e9l\u00e9ment nextElementSibling renvoie le prochain \u00e9l\u00e9ment de m\u00eame niveau parentElement renvoie l'\u00e9l\u00e9ment parent <body> <div> <p>Mon paragraphe 1</p> <p>Mon paragraphe 2</p> </div> <script src=\"script.js\"></script> </body> console.log(document.body.children) // [div, script] console.log(document.body.children[0].children) // [p, p] console.log(document.body.firstElementChild) // \u00e9quivalent \u00e0 children[0], retourne la div console.log(document.body.children[0].nextElementSibling) // affiche le script console.log(document.body.children[0].parentElement) // affiche le body","title":"Hi\u00e9rarchie des \u00e9l\u00e9ments"},{"location":"javascriptDebarqueDansLeNavigateur/#recuperer-et-modifier-les-elements","text":"Un console.log() d'un \u00e9l\u00e9ment du DOM affiche la repr\u00e9sentation HTML de l'\u00e9l\u00e9ment, mais on ne voit pas ses propri\u00e9t\u00e9s. Pour voir les propri\u00e9t\u00e9s et m\u00e9thodes d'un \u00e9l\u00e9ment, il faut afficher tous les enfants de l'\u00e9l\u00e9ment parent et cliquer sur l'\u00e9l\u00e9ment enfant qui nous int\u00e9resse dans la console. console.log(document.body.children[0].children[1]) // affiche <p>Mon paragraphe 2</p> console.log(document.body.children[0].children) // affiche l'HTML Collection avec ses 2 enfants. On peut cliquer sur chaque enfant pour voir ses attributs et m\u00e9thodes","title":"R\u00e9cup\u00e9rer et modifier les \u00e9l\u00e9ments"},{"location":"javascriptDebarqueDansLeNavigateur/#le-contenu-innerhtml","text":"innerHTML permet de r\u00e9cup\u00e9rer le code HTML enfant d'un \u00e9l\u00e9ment sous forme de texte. Si les balises sont pr\u00e9sentes, innerHTML les retournera sous forme de texte. Exemple : <body> <div id=\"myDiv\"> <p>Un peu de texte <a>et un lien</a></p> </div> <script> const div = document.getElementById('myDiv') console.log(div.innerHTML) // affiche : <p>Un peu de texte <a>et un lien</a></p> </script> </body> Autre exemple o\u00f9 l'on va modifier le contenu du paragraphe : console.log(document.body.children[0].children[0].innerHTML) // affiche Un peu de texte <a>et un lien</a> document.body.children[0].children[0].innerHTML = \"<strong>Nouveau Texte</strong>\" console.log(document.body.children[0].children[0].innerHTML) // affiche Nouveau Texte (en gras car les les balises strong sont interpr\u00e9t\u00e9es par le navigateur pour mettre le texte en gras) Il est aussi possible d'ajouter ou d'\u00e9diter du HTML document.getElementById('myDiv').innerHTML = '<blockquote>Je mets une citation \u00e0 la place du paragraphe</blockquote>' document.getElementById('myDiv').innerHTML += ' et <strong>une portion mise en emphase</strong>.' Il ne faut pas l'utiliser dans une boucle car innerHTML ralentit l'ex\u00e9cution du code. Il vaut mieux la concat\u00e9ner dans une variable et ensuite ajouter le tout via innerHTML .","title":"Le contenu : innerHTML"},{"location":"javascriptDebarqueDansLeNavigateur/#innertext-et-textcontent","text":"innerText pour IE et textContent pour les autres navigateurs sont des propri\u00e9t\u00e9s analogues \u00e0 innerHTML , qui permettent de r\u00e9cup\u00e9rer le contenu d'un \u00e9l\u00e9ment sous forme de texte mais sans les balises , et permet aussi de modifier le contenu de l'\u00e9l\u00e9ment. innerText a \u00e9t\u00e9 introduite dans IE, mais jamais standardis\u00e9e et n'est pas suport\u00e9e par tous les navigateurs textContent est la version standardis\u00e9e d' innerText . Elle est reconnue par tous les navigateurs \u00e0 l'exception des versions ant\u00e9rieures \u00e0 IE9. console.log(document.body.children[0].children[0].textContent) // affiche Un peu de texte et un lien document.body.children[0].children[0].textContent = \"<strong>Nouveau Texte</strong>\" // les balises ne sont pas interpr\u00e9t\u00e9s par le navigateur mais \u00e9crites comme du texte affich\u00e9 dans le navigateur console.log(document.body.children[0].children[0].textContent) // affiche <strong>Nouveau Texte</strong>","title":"innerText et textContent"},{"location":"javascriptDebarqueDansLeNavigateur/#modifier-le-style","text":"La propri\u00e9t\u00e9 style permet de modifier le style CSS des \u00e9l\u00e9ments. Les types correspondent au CSS sauf qu'il faut les \u00e9crire en kamel case. Par exemple \u00e9crire backgroundColor en JavaScript au lieu de background-color en CSS. document.body.children[0].style.backgroundColor = \"red\" // mais le fond de la div en rouge","title":"Modifier le style"},{"location":"javascriptDebarqueDansLeNavigateur/#modifier-les-classes-css","text":"<body> <div class=\"super\"> <p>Mon paragraphe 1</p> <p>Mon paragraphe 2</p> </div> <script src=\"script.js\"></script> </body> classList permet d'avoir la liste des classes CSS que poss\u00e8de un \u00e9l\u00e9ment. Les m\u00e9thodes add() et remove() permettent d'ajouter et d'enlever des classes CSS. toggle() permet d'enlever la classe si elle pr\u00e9sente et de l'ajouter si elle n'y est pas. console.log(document.body.children[0].classList) // affiche [\"super\"] document.body.children[0].classList.add(\"toto\") // ajoute la classe toto \u00e0 la div et applique son style console.log(document.body.children[0].classList) // affiche [\"super\", \"toto\"] document.body.children[0].classList.remove(\"toto\") // enl\u00e8ve la classe toto de la div et enl\u00e8ve son style console.log(document.body.children[0].classList) // affiche [\"super\"] document.body.children[0].classList.toggle(\"toto\") console.log(document.body.children[0].classList) // affiche [\"super\", \"toto\"] document.body.children[0].classList.toggle(\"toto\") console.log(document.body.children[0].classList) // affiche [\"super\"] On peut aussi utiliser className pour appliquer une classe CSS \u00e0 un \u00e9l\u00e9ment : document.getElementById('p1').className = 'bleu'","title":"Modifier les classes CSS"},{"location":"javascriptDebarqueDansLeNavigateur/#modifier-les-attributs","text":"Un attribut correspond aux informations pr\u00e9sentes dans une balise, par exemple src dans la balise script : <script src=\"index.js\"></script> . Les m\u00e9thodes getAttribute() et setAttribute() permettent de r\u00e9cup\u00e9rer et modifier un attribut d'un \u00e9l\u00e9ment HTML. console.log(document.body.children[1].getAttribute(\"src\")) // affiche index.js document.body.children[1].setAttribute(\"src\", \"toto.js\") // modifie la valeur de l'attribut renseign\u00e9e console.log(document.body.children[1].getAttribute(\"src\")) // affiche toto.js","title":"Modifier les attributs"},{"location":"javascriptDebarqueDansLeNavigateur/#selectionner-les-elements","text":"Pour s\u00e9lectionner un \u00e9l\u00e9ment, on peut le faire plus simplement qu'en partant de body et en descendant avec children . La m\u00e9thode getElementById() de l'objet document permet de s\u00e9lectionner un \u00e9l\u00e9ment par son id, getElementsByTagName() s\u00e9lectionne les \u00e9l\u00e9ments qui correspondent \u00e0 un tag HTML, par exemple h1 ou p , et getElementsByClassName() s\u00e9lectionne les \u00e9l\u00e9ments qui correspondent \u00e0 une classe CSS. On peut aussi stocker les \u00e9l\u00e9ments dans une variable. <body> <div class=\"super\"> <h1 id=\"titre\">Mon Titre</h1> <p class=\"maClasse\">Mon paragraphe 1</p> <p>Mon paragraphe 2</p> </div> <script src=\"script.js\"></script> </body> console.log(document.getElementById(\"titre\")) // affiche <h1 id=\"titre\">Mon Titre</h1> console.log(document.getElementsByTagName(\"p\")) // affiche une HTML Collection avec les 2 paragraphes console.log(document.getElementsByClassName(\"maClasse\")) // affiche une HTML Collection avec l'\u00e9l\u00e9ment qui a cette classe const monTitre = document.getElementById(\"titre\") console.log(monTitre) // affiche <h1 id=\"titre\">Mon Titre</h1>","title":"S\u00e9lectionner les \u00e9l\u00e9ments"},{"location":"javascriptDebarqueDansLeNavigateur/#selectionner-avec-query-selector","text":"La m\u00e9thode querySelector() permet d'utiliser les s\u00e9lecteurs CSS pour s\u00e9lectionner un \u00e9l\u00e9ment. Si plusieurs \u00e9l\u00e9ments correspondent, seul le premier \u00e9l\u00e9ment sera s\u00e9lectionn\u00e9. La m\u00e9thode querySelectorAll() renvoie une liste, et permet donc de s\u00e9lectionner plusieurs \u00e9l\u00e9ments. console.log(document.querySelector(\".maClasse\")) // affiche <p class=\"maClasse\">Mon paragraphe 1</p> console.log(document.querySelectorAll(\".maClasse\")) // affiche une NodeList d'un \u00e9l\u00e9ment avec le paragraphe 1 console.log(document.querySelector(\"p\")) // affiche <p class=\"maClasse\">Mon paragraphe 1</p> (le 1er paragraphe rencontr\u00e9) console.log(document.querySelectorAll(\"p\")) // affiche une NodeList de deux \u00e9l\u00e9ments avec les paragraphes","title":"S\u00e9lectionner avec Query Selector"},{"location":"javascriptDebarqueDansLeNavigateur/#modifier-lordre-des-elements","text":"La m\u00e9thode insertBefore() permet d'ins\u00e9rer un \u00e9l\u00e9ment HTML avant un autre \u00e9l\u00e9ment. Si l'\u00e9l\u00e9ment existe d\u00e9j\u00e0, il est d'abord supprim\u00e9 avant d'\u00eatre replac\u00e9. La m\u00e9thode appendChild() permet d'ajouter un \u00e9l\u00e9ment \u00e0 un autre \u00e9l\u00e9ment en tant qu'enfant. La m\u00e9thode replaceChild() permet de remplacer un \u00e9l\u00e9ment enfant par un autre. La m\u00e9thode removeChild() permet de supprimer un \u00e9l\u00e9ment, remove() le permet aussi de mani\u00e8re plus simple mais n'est pas support\u00e9 par les anciennes versions des navigateurs. <link rel=\"stylesheet\" href=\"style.css\"> <body> <div class=\"rouge\">Rouge</div> <div class=\"vert\">Vert</div> <div class=\"bleu\">Bleu</div> <script src=\"script.js\"></script> </body> .rouge, .vert, .bleu { width: 300px; height: 100px; color: white; font-size: 40px; text-align: center; } .rouge { background-color: red; } .vert { background-color: green; } .bleu { background-color: blue; } const rouge = document.querySelector(\".rouge\") const vert = document.querySelector(\".vert\") const bleu = document.querySelector(\".bleu\") document.body.insertBefore(bleu,vert) // ins\u00e8re l'\u00e9l\u00e9ment bleu avant l'\u00e9l\u00e9ment vert rouge.appendChild(bleu) // ajoute l'\u00e9l\u00e9ment bleu en tant qu'enfant de rouge document.body.replaceChild(bleu, rouge) // remplace l'\u00e9l\u00e9ment rouge par l'\u00e9l\u00e9ment bleu bleu.parentElement.removeChild(bleu) // permet de supprimer l'\u00e9l\u00e9ment bleu bleu.remove() // permet aussi de supprimer l'\u00e9l\u00e9ment bleu mais n'est pas support\u00e9 par les anciens navigateurs","title":"Modifier l'ordre des \u00e9l\u00e9ments"},{"location":"javascriptDebarqueDansLeNavigateur/#creer-des-elements","text":"Pour cr\u00e9er un \u00e9l\u00e9ment, on va utiliser la m\u00e9thode createElement() que l'on va ensuite ins\u00e9rer dans le DOM avec la m\u00e9thode appendChild() /* creation d'une classe CSS jaune que l'on va appliquer sur un \u00e9l\u00e9ment que l'on va cr\u00e9er en JS */ .jaune { width: 300px; height: 100px; color: white; font-size: 40px; text-align: center; background-color: yellow } const jaune = document.createElement(\"div\") //cr\u00e9ation d'un \u00e9l\u00e9ment div jaune.classList.add(\"jaune\") // application de la classe jaune sur la div jaune.textContent = \"Jaune\" // ajout du texte Jaune dans la div document.body.appendChild(jaune) // insertion de l'\u00e9l\u00e9ment jaune en tant qu'enfant du body Exemple de cr\u00e9ation d'une fonction qui cr\u00e9e des \u00e9l\u00e9ments que l'on va appeler plusieurs fois pour remplir une liste <body> <ul></ul> <script src=\"script.js\"></script> </body> function planifierTache(heure, tache){ const nouvelleTache = document.createElement(\"li\") nouvelleTache.innerHTML = `<h3>${heure}</h3><p>${tache}</p>` // innerHTML permet de dire le code HTML que l'on veut mettre \u00e0 l'int\u00e9rieur d'un \u00e9l\u00e9ment HTML document.querySelector(\"ul\").appendChild(nouvelleTache) } planifierTache('7h30', 'R\u00e9veil') planifierTache('7h40', 'Petit-d\u00e9jeuner') planifierTache('8h00', 'Douche')","title":"Cr\u00e9er des \u00e9l\u00e9ments"},{"location":"javascriptDebarqueDansLeNavigateur/#les-evenements-javascript","text":"","title":"Les \u00e9v\u00e9nements Javascript"},{"location":"javascriptDebarqueDansLeNavigateur/#quest-ce-quun-evenement","text":"Les \u00e9v\u00e9nements permettent de d\u00e9clencher une fonction selon qu'une action s'est produite ou non, par exemple faire appara\u00eetre une fen\u00eatre alert() au survol d'une zone d'un \u00e9l\u00e9ment. Ils sont de diff\u00e9rentes natures, par exemple : cliquer sur un \u00e9l\u00e9ment appuyer sur une touche du clavier lorsque le navigateur a fini de charger la page Web Un \u00e9v\u00e9nement est bas\u00e9 sur l'interface Event , avec par exemple les classes MouseEvent et KeyboardEvent pour les \u00e9v\u00e9nements li\u00e9s \u00e0 la souris et au clavier.","title":"Qu'est-ce qu'un \u00e9v\u00e9nement ?"},{"location":"javascriptDebarqueDansLeNavigateur/#on-event-handler","text":"<body> <div class=\"rouge\">Rouge</div> <div class=\"vert\">Vert</div> <div class=\"bleu\">Bleu</div> <script src=\"index.js\"></script> </body> console.log(rouge) // affiche <div class=\"rouge\">Rouge</div> console.log(rouge.parentElement.children) // affiche la collection HTML des \u00e9l\u00e9m\u00e9nts enfants du parent, dont rouge, pour lesquels on peut voir les propri\u00e9t\u00e9s et m\u00e9thodes Les propri\u00e9t\u00e9s qui commencent par on sont li\u00e9s aux \u00e9v\u00e9nements. Elles sont appel\u00e9es On-Event Handler , que l'on peut traduire par gestionnaire d'\u00e9v\u00e9nements . Par exemple, la propri\u00e9t\u00e9 onload g\u00e8re l'\u00e9v\u00e9nement load . L'\u00e9v\u00e9nement load se produit quand la page a fini de se charger : window.onload = function(){ console.log(\"la page est charg\u00e9e\") } console.log(\"apr\u00e8s le onload\") // s'affiche AVANT \"la page est charg\u00e9e\" On peut aussi d\u00e9clarer une fonction et l'appeler sur la propri\u00e9t\u00e9 onload : function windowReady(){ console.log(\"la page est charg\u00e9e\") } window.onload = windowReady() On peut encapsuler tout le code JS dans un windows.onload pour s'assurer que tous les \u00e9l\u00e9ments que l'on manipule sont charg\u00e9s : window.onload = function(){ const rouge = document.querySelector(\".rouge\") const vert = document.querySelector(\".vert\") const bleu = document.querySelector(\".bleu\") } Exemple de l'\u00e9v\u00e9nement clic, d\u00e9clench\u00e9 \u00e0 chaque clic sur l'\u00e9l\u00e9ment rouge : rouge.onclick = function(event){ console.log(\"clic sur la div rouge !\") console.log(event) } On peut r\u00e9cup\u00e9rer l'\u00e9v\u00e9nement en le passant en argument de la fonction en lui donnant le nom que l'on veut car le fait de mettre un argument \u00e0 la fonction nous donne forc\u00e9ment l'\u00e9v\u00e9nement. On peut \u00e9crire les Event Handler directement dans le code HTML, ce qui n'est pas conseill\u00e9 : <div class=\"vert\" onclick=\"console.log('toto')\">Vert</div> On ne peut pas d\u00e9finir plusieurs fois le m\u00eame event handler sur le m\u00eame \u00e9l\u00e9ment. Auquel cas, seul le dernier event handler va fonctionner car c'est une propri\u00e9t\u00e9 \u00e0 laquelle on attache une fonction, donc la derni\u00e8re a \u00e9cras\u00e9e les pr\u00e9c\u00e9dentes. rouge.onclick = function(event){ console.log(\"clic sur la div rouge !\") console.log(event) } rouge.onclick = function(){ console.log(\"deuxi\u00e8me message\") // seul ce message va s'afficher }","title":"On-Event Handler"},{"location":"javascriptDebarqueDansLeNavigateur/#event-listener","text":"Un Event Listener , ou \u00e9couteur d'\u00e9v\u00e9nement en fran\u00e7ais, est une autre fa\u00e7on d'interagir avec les \u00e9v\u00e9nements. Il faut utiliser la m\u00e9thode addEventListener() qui prend en argument le nom de l'\u00e9v\u00e9nementet la fonction a ex\u00e9cuter : rouge.addEventListener(\"click\", function(event){ console.log(\"clic sur la div rouge !\") console.log(event) }) function afficherMessage(){ console.log(\"deuxi\u00e8me message\") } rouge.addEventListener(\"click\", afficherMessage) On peut ajouter plusieurs event listener sur le m\u00eame \u00e9v\u00e9nement et sur le m\u00eame \u00e9l\u00e9ment, ils seront tous ex\u00e9cut\u00e9s. On peut aussi d\u00e9clarer une fonction en externe et l'appeler dans le listener sans l'ex\u00e9cuter , juste en marquant son nom. La fonction anonyme en argument n'\u00e9tait pas \u00e9ex\u00e9cut\u00e9e non plus, le listeneur le fait quand l'\u00e9v\u00e9nement a lieu. On peut aussi supprimer un event listener avec removeEventListener() . Dans l'exemple suivant, quand on clique sur vert, on enl\u00e8ve le deuxi\u00e8me event listener de rouge, et quand on clique ensuite sur rouge, il n'y a plus que le premier qui s'ex\u00e9cute : vert.addEventListener(\"click\", function(){ rouge.removeEventListener(\"click\", afficherMessage) })","title":"Event Listener"},{"location":"javascriptDebarqueDansLeNavigateur/#propagation-des-evenements","text":"<div id=\"parent\"> <div id=\"enfant\"></div> </div> <script src=\"index.js\"></script> #parent { width: 300px; height: 300px; background-color: red; } #enfant { width: 100px; height: 100px; background-color: blue; } const parent = document.querySelector(\"#parent\") const enfant = document.querySelector(\"#enfant\") parent.addEventListener(\"click\", parentFonction) enfant.addEventListener(\"click\", enfantFonction) function enfantFonction(){ console.log(\"clic sur l'enfant\") } function parentFonction(){ console.log(\"clic sur le parent\") } Dans cet exemple, il y a une div bleu enfant contenu dans une div rouge rouge. Lorsqu'on clique sur la div parent, clic sur le parent s'\u00e9crit dans la log, et lorsqu'on clique sur la div enfant, clic sur l'enfant puis clic sur le parent s'affichent car l'enfant est contenu dans le parent. Les \u00e9v\u00e9nements sont faits de deix phases : - phase de capture : part des parents et va vers les enfants - phase de bouillonnement ( event bubbling ) : part de l'enfant et va vers les parents Par d\u00e9faut, addEventListener s'ex\u00e9cute pendant la phase de bouillenement (les \u00e9v\u00e9nements d\u00e9butent par les enfants et remontent vers les parents). Pour qu'elle s'ex\u00e9cute pendant la phase de capture, il faut ajouter un troi\u00e8me argument true \u00e0 la m\u00e9thode addEventListener . Dans l\"exemple suivant, lorsqu'on clique sur la div enfant, clic sur parent s'affiche donc avant clic sur enfant : parent.addEventListener(\"click\", parentFonction, true) enfant.addEventListener(\"click\", enfantFonction, true)","title":"Propagation des \u00e9v\u00e9nements"},{"location":"javascriptDebarqueDansLeNavigateur/#proprietes-de-lobjet-event","text":"Certaines propri\u00e9t\u00e9s sont communes \u00e0 tous les \u00e9v\u00e9nements, d'autres sont sp\u00e9cifiques \u00e0 certains \u00e9v\u00e9nement comme les \u00e9v\u00e9nements souris, ou les \u00e9v\u00e9nements claviers : function parentFonction(event){ console.log(\"clic sur le parent\") console.log(event) console.log(event.type) // affiche : click, correspond au type de l'\u00e9v\u00e9nement console.log(event.target) // affiche la div parent, correspond \u00e0 l'\u00e9l\u00e9ment qui a d\u00e9but\u00e9 l'\u00e9v\u00e9nement console.log(event.currentTarget) console.log(event.clientX) // affiche o\u00f9 l'on se place sur l'axe horizontale, propri\u00e9t\u00e9 sp\u00e9cifique au MouseEvent }","title":"Propri\u00e9t\u00e9s de l'objet Event"},{"location":"javascriptDebarqueDansLeNavigateur/#methodes-de-lobjet-event","text":"La m\u00e9thode stopPropagation() permet de stopper la propagation d'un \u00e9v\u00e9nement. Dans l'exemple suivant, en cliquant sur l'enfant, on ne verra que le clic sur l'enfant mais pas le clic sur le parent. L'\u00e9v\u00e9nement a \u00e9t\u00e9 stopp\u00e9 et n'a donc pas atteint la div parent. function enfantFonction(event){ console.log(\"clic sur l'enfant\") event.stopPropagation() } La m\u00e9thode preventDefault() permet de ne pas traiter l'\u00e9v\u00e9nement avec son action par d\u00e9faut. Dans l'exemple suivant, lors de la soumission du formulaire, on \u00e9crit un message dans la log. Par d\u00e9faut, la soumission d'un formulaire rafra\u00eechit la page, le message dans la log dispara\u00eet donc aussit\u00f4t qu'il est apparu. Pour ne pas rafra\u00eechir la page, on peut utiliser la m\u00e9thode preventDefault() , le message restera alors affich\u00e9 dans la log. <body> <form> <input type=\"text\" placeholder=\"Votre nom\"> <button type=\"submit\">Envoyer</button> </form> <script src=\"index.js\"></script> </body> const form = document.querySelector(\"form\") form.addEventListener(\"submit\", envoyerFormulaire) function envoyerFormulaire(event){ event.preventDefault() console.log(\"Formulaire envoy\u00e9\") }","title":"M\u00e9thodes de l'objet Event"},{"location":"javascriptDebarqueDansLeNavigateur/#requetes-http-ajax","text":"","title":"Requ\u00eates HTTP - Ajax"},{"location":"javascriptDebarqueDansLeNavigateur/#quest-ce-quune-requete-http","text":"Ajax est un raccourci pour Asynchronous JavaScript and XML (XML et JavaScript asynchrones). Ajax permet d'\u00e9changer avec le serveur via des requ\u00eates HTTP sans rafra\u00eechir toute la page mais uniquement certains \u00e9l\u00e9ment de la page. Ces requ\u00eates fonctionnent de mani\u00e8re asynchrones, c'est-\u00e0-dire que l'on traitera la r\u00e9ponse quand elle arrive sans attendre qu'elle arrive, ce qui permet de continuer \u00e0 ex\u00e9cuter la suite du code.","title":"Qu'est-ce qu'une requ\u00eate HTTP ?"},{"location":"javascriptDebarqueDansLeNavigateur/#requetes-http-avec-xmlhttprequest","text":"XMLHttpRequest est l'objet qui permet de faire des requ\u00eates Ajax. C'est l'objet de base qui sert \u00e0 faire des requ\u00eates HTTP. D'autres objets se basent dessus. Lors d'une requ\u00eate HTTP, son \u00e9tat va varier, et nous pouvons r\u00e9cup\u00e9rer chaque changement de cet \u00e9tat, avec l'\u00e9v\u00e9nement onreadystatechange . L'\u00e9tat varie de 0 \u00e0 4. La requ\u00eate est termin\u00e9e \u00e0 l'\u00e9tat 4. Exemple avec l'API Jsonplaceholder sur l'URL /posts en GET : const req = new XMLHttpRequest() const method = 'GET' const url = 'https://jsonplaceholder.typicode.com/posts' req.onreadystatechange = function(event){ if(this.readyState === XMLHttpRequest.DONE){// on aurait pu \u00e9crire 4 \u00e0 la place, c'est pareil if(this.status === 200){ console.log( JSON.parse(this.responseText) ) } else { console.log(\"Statut Erreur : \"+this.status) } } } req.open(method, url) req.send() Exemple d'une requ\u00eate en POST : const req = new XMLHttpRequest() const method = 'POST' const url = 'https://jsonplaceholder.typicode.com/posts' const data = { body: \"la la la\", title: \"mon titre\", userId: 1 } req.onreadystatechange = function(event){ if(this.readyState === XMLHttpRequest.DONE){// on aurait pu \u00e9crire 4 \u00e0 la place, c'est pareil if(this.status === 201){ console.log( JSON.parse(this.responseText) ) } else { console.log(\"Statut Erreur : \"+this.status) } } } req.open(method, url) req.send(data) La m\u00e9thode open() prend en argument la m\u00e9thode HTTP puis l'url \u00e0 appeler. Il y a ensuite des arguments optionels : XMLHttpRequest.open(method, url, async, user, password) async : \u00e0 true par d\u00e9faut. On peut le mettre \u00e0 false pour faire des requ\u00eates synchrones, ce qui est d\u00e9conseill\u00e9 user et password sont null par d\u00e9faut et servent \u00e0 l'authentification","title":"Requ\u00eates HTTP avec XMLHttpRequest"},{"location":"lesBasesDeJavaScript/","text":"Les bases de JavaScript Introduction Qu\u2019est que le JavaScript ? Le JavaScript est un langage de programmation de scripts orient\u00e9 objet Un langage de programmation permet d\u2019\u00e9crire du code source qui sera analys\u00e9 par l\u2019ordinateur. Il existe trois mani\u00e8res d\u2019utiliser du code source : langage compil\u00e9 : le code source est donn\u00e9 \u00e0 un programme appel\u00e9 compilateur qui va lire le code source et le convertir dans un langage que l\u2019ordinateur sera capable d\u2019interpr\u00e9ter : le langage binaire. Les langages comme le C ou le C++ sont des langages dits compil\u00e9s langage pr\u00e9compil\u00e9 : le code source est partiellement compil\u00e9, dans un langage plus simple \u00e0 lire par l\u2019ordinateur mais ce n\u2019est pas encore du binaire. Ce code interm\u00e9diaire devra \u00eatre lu par une machine virtuelle qui ex\u00e9cutera ce code. Les langages comme Java ou C# sont dits pr\u00e9compil\u00e9s langage interpr\u00e9t\u00e9 : pas de compilation, le code source reste tel quel. Pour ex\u00e9cuter le code, on doit le fournir \u00e0 un interpr\u00e9teur qui lira le code et r\u00e9alisera les actions. Pour obtenir des gains de performances, on peut le le compiler \u00e0 la vol\u00e9e pendant son ex\u00e9cution, ce que font aujourd\u2019hui la plupart des interpr\u00e9teurs JavaScript Les scripts sont majoritairement interpr\u00e9t\u00e9s, ce qui est le cas de JavaScript qui est un langage interpr\u00e9t\u00e9. Il y a un interpr\u00e9teur JavaScript dans le navigateur Web, qui est diff\u00e9rent selon le navigateur : Chakra dans Internet Explorer, SpiderMonkey dans Firefox, V8 dans Chrome. Le JavaScript est majoritairement utilis\u00e9 sur les pages Web pour dynamiser les pages HTML, en ajoutant des interactions avec l\u2019utilisateur, des animations, de l\u2019aide \u00e0 la navigation, par exemple : afficher ou masquer du texte, faire d\u00e9filer des images, cr\u00e9er des infobulles\u2026 Les scripts JavaScript sont ex\u00e9cut\u00e9s par le navigateur chez l\u2019internaute (le client), contrairement aux langages serveur (comme le PHP) ex\u00e9cut\u00e9 par le serveur web. Un script serveur va s\u2019occuper de cr\u00e9er la page Web qui sera envoy\u00e9 au navigateur. Ce dernier va alors afficher la page puis ex\u00e9cuter les scripts client tel que le JavaScript. Le JavaScript ne sert pas que dans les pages Web. Il sert aussi \u00e0 r\u00e9aliser des extensions pour des programmes. Chrome et Firefox en poss\u00e8dent tous deux un panel gigantesque en partie cod\u00e9es en JavaSript. Il est aussi possible d\u2019ex\u00e9cuter du JavaScript en dehors du navigateur. Le JavaScript peut aussi \u00eatre utilis\u00e9 pour r\u00e9aliser des applications. Petit historique du langage En 1995, Brendan Eich d\u00e9veloppe le LiveScript qui sera renomm\u00e9 en JavaScript en hommage au langage Java. Netscape d\u00e9cide d\u2019envoyer sa version de JavaScript \u00e0 l\u2019ECMA international pour que le langage soit standardis\u00e9. L\u2019ECMA standardise le langage soit le nom d\u2019ECMAScript. L\u2019ECMAScript est la r\u00e9f\u00e9rence de base, de l\u00e0 en d\u00e9coule des impl\u00e9mentations comme le JavaScript. Les versions du JavaScript sont bas\u00e9es sur celles de l\u2019ECMAScript. Ainsi il existe : ES1 et ES2 qui sont les pr\u00e9mices du langage JavaScript ES3 sorti en d\u00e9cembre 1999 ES4 qui a \u00e9t\u00e9 abandonn\u00e9 en raison de modifications trop importantes qui ne furent pas appr\u00e9ci\u00e9es ES5 sortie en d\u00e9cembre 2009, la version la plus r\u00e9pandue et la plus utilis\u00e9e \u00e0 ce jour ES6, finalis\u00e9 en d\u00e9cembre 2014 D\u00e9boguer votre code gr\u00e2ce \u00e0 la console Nous allons commencer \u00e0 \u00e9tudier les diff\u00e9rents bugs que l\u2019on va g\u00e9n\u00e9ralement rencontrer en JavaScript et surtout comment les r\u00e9soudre, en utilisant les kits de d\u00e9veloppement fournis avec n\u2019importe quel navigateur digne de ce nom. En quoi consiste le d\u00e9bogage ? Les bugs Ce sont des erreurs humaines laiss\u00e9es dans le code. Il existe deux types principaux de bugs : ceux que l\u2019interpr\u00e9teur JavaScript saura signaler : fautes de syntaxe va myVar = 'test; // Le mot-cl\u00e9 \u00ab var \u00bb est mal orthographi\u00e9 et il manque une apostrophe ceux que l\u2019interpr\u00e9teur ne verra pas : erreurs dans l\u2019algorithme // On veut afficher la valeur 6 avec les nombres 3 et 2 var myVar = 3 + 2; // Mais on obtient 5 au lieu de 6 car on a fait une addition au lieu d'une multiplication Une erreur syntaxique emp\u00eache le code de s\u2019ex\u00e9cuter tandis que les erreurs d\u2019algorithme ne pose aucun probl\u00e8me d\u2019ex\u00e9cution. Le d\u00e9bogage Cette technique consiste \u00e0 supprimer les bugs qui existent dans le code. Les bugs syntaxiques sont les plus simples \u00e0 r\u00e9soudre car l\u2019interpr\u00e9teur JavaScript signale g\u00e9n\u00e9ralement l\u2019endroit o\u00f9 l\u2019erreur est apparue. En ce qui concerne les bugs algorithmiques, il va falloir chercher nous-m\u00eame. Le plus simple est souvent de remonter les couches de code pour trouver o\u00f9 l\u2019erreur s\u2019est produite. Les kits de d\u00e9veloppement et leur console Tous les navigateurs r\u00e9cent poss\u00e8de un kit de d\u00e9veloppement : Chrome, Firefox, IE, Safari, Op\u00e9ra\u2026 Ces kits permettent de d\u00e9boguer efficacement nos codes : d\u00e9tection des erreurs syntaxiques, afficher des valeurs dans la console, consulter le code HTML g\u00e9n\u00e9r\u00e9 par le code, analyser les requ\u00eates HTTP effectu\u00e9es par le navigateur, mesurer les performances du code, etc\u2026 Les fonctionnalit\u00e9s des diff\u00e9rents kits sont souvent identiques, mais il y a parfois quelques diff\u00e9rences. Nous verrons surtout celui de Chrome. Pour ouvrir le kit de d\u00e9veloppement, il faut appuyer sur F12 . Dans le cadre du d\u00e9bogage d\u2019erreurs, il est tr\u00e8s important de bien externaliser le code JavaScript car l\u2019affichage des erreurs peut \u00eatre erron\u00e9 avec Chrome lorsque le code JS est directement int\u00e9gr\u00e9 au sein du code HTML. Consulter la console pour voir les erreurs. On peut par exemple voir SyntaxError qui mentionne une erreur syntaxique. A droite du texte, on voit le nom du fichier concern\u00e9 ainsi que la ligne de code, qu\u2019il est possible de consulter en cliquant dessus. L\u2019interpr\u00e9teur JavaScript s\u2019arr\u00eate sur la premi\u00e8re erreur rencontr\u00e9e, m\u00eame s\u2019il y a plusieurs erreurs. En corrigeant la premi\u00e8re erreur, le navigateur affichera alors l\u2019erreur suivante. La console permet aussi de rep\u00e9rer des erreurs qui ne sont pas forc\u00e9ment li\u00e9es au JavaScript, telles que des images manquantes par exemple. En cas de page web non conforme \u00e0 ce qu\u2019on attend, il faut toujours consulter la console ce qui permet g\u00e9n\u00e9ralement de trouver la source du probl\u00e8me. Aller plus loin avec la console La console est un outil qui permet de faire plus que simplement lister les erreurs sur la page. La m\u00e9thode console.log() permet d\u2019afficher la valeur d\u2019une variable sans bloquer l\u2019ex\u00e9cution du code contrairement \u00e0 la fonction alert() . // on affiche un tableau. var helloArray = ['Hello', 'Bonjour', 'Hola']; console.log(helloArray); La m\u00e9thode console.log() permet d\u2019afficher le contenu de l\u2019objet. Elle est utilisable sur tous les types de variables et pourra rendre service de nombreuses fois. En plus de la m\u00e9thode log(), l\u2019objet console en propose d\u2019autres qui permettent de modifier la mani\u00e8re d\u2019afficher les valeurs : \u00e9mettre des alertes ou des erreurs avec les m\u00e9thodes warn() et error() , grouper des lignes de r\u00e9sultats avec group() et groupEnd() . Ces m\u00e9thodes sont faites pour d\u00e9boguer le code et n\u2019ont rien \u00e0 faire dans le code une fois le site mis en ligne. Dans la console, il y a une ligne en bas avec un chevron bleu o\u00f9 il est possible d\u2019\u00e9crire directement du code qui agit pendant son ex\u00e9cution ! Cependant, cela fonctionne uniquement sur les variables globales. Utiliser les points d\u2019arr\u00eat Pour identifier un bug qui se produit pendant une fraction de seconde, il est possible d\u2019utiliser un point d\u2019arr\u00eat, aussi appel\u00e9 breakpoint en anglais. Gr\u00e2ce aux points d\u2019arr\u00eat, nous allons pouvoir \u00e9tudier la pile d\u2019ex\u00e9cution de notre code, dans l\u2019onglet \u201cSources\u201d dans le kit de d\u00e9veloppement et choisir un fichier parmi ceux de la page web. Dans le fichier JS, il suffit de cliquer sur un num\u00e9ro de ligne pour mettre un point d\u2019arr\u00eat. Celui-ci indique au navigateur qu\u2019on souhaite mettre en pause le code avant l\u2019ex\u00e9cution de la ligne concern\u00e9e . Ils ne peuvent \u00eatre plac\u00e9 que sur des lignes comportant des instructions , c\u2019est impossible sur une ligne de d\u00e9claration de fonction par exemple. Il faut recharger la page pour prendre en compte le point d\u2019arr\u00eat. Le code sera surlign\u00e9 \u00e0 l\u2019endroit o\u00f9 il s\u2019est arr\u00eat\u00e9. On peut consulter les variables actuellement utilis\u00e9es au sein du scope actuel (dans le menu \u201cLocal\u201d) ainsi que les variables globales (menu \u201cGlobal\u201d). La pile d\u2019ex\u00e9cution Pour chaque point d\u2019arr\u00eat, on peut consulter la pile d\u2019ex\u00e9cution ( call stack ) qui d\u00e9finit par quelles fonctions le code est pass\u00e9 afin d\u2019atteindre la ligne actuellement mise en pause par le point d\u2019arr\u00eat. On peut cliquer sur chaque \u00e9tape de la pile et consulter les variables du scope. La pile permet aussi de savoir par quoi a \u00e9t\u00e9 d\u00e9clench\u00e9 une partie du code. Enfin il est possible de donner un nom \u00e0 une fonction anonyme dans la pile d\u2019ex\u00e9cution afin de mieux la rep\u00e9rer. Premiers pas L\u2019objectif ici est d\u2019apprendre \u00e0 int\u00e9grer le JavaScript aux pages Web. Afficher une bo\u00eete de dialogue Dans les balises <body> du HTML, \u00e9crire <script> alert('Hello world!') </script> Une bo\u00eete de dialogue s'affiche avec le message Hello world! Dans cet exemple, il n\u2019y a qu\u2019une instruction : l\u2019appel de la fonction alert() . C\u2019est une instruction simple, appel\u00e9e fonction, qui permet d\u2019afficher une bo\u00eete de dialogue contenant un message. Une bo\u00eete de dialogue s'affiche avec le message Hello world! La syntaxe du JavaScript Les instructions Les instructions doivent \u00eatre s\u00e9par\u00e9es par un point-virgule, non obligatoire si l\u2019instruction qui suit se trouve sur la ligne suivante. instruction_1 instruction_2; instruction_3; instruction_4 Les espaces Le JavaScript n\u2019est pas sensible aux espaces, on peut donc indenter comme on le souhaite les instructions. Les commentaires Il existe des commentaires de fin de ligne et des commentaires multilignes. instruction_1 // Ceci est ma premi\u00e8re instruction instruction_2 // La troisi\u00e8me instruction ci-dessous : instruction_3 /* Ce script comporte 3 instructions : - Instruction 1 qui fait telle chose - Instruction 2 qui fait autre chose - Instruction 3 qui termine le script */ instruction_1 instruction_2 instruction_3 // Fin du script Quelques aides Un site de documentation : https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference Un site pour tester le code JavaScript en ligne : https://jsfiddle.net/ O\u00f9 placer le code dans la page ? Les codes JavaScript sont ins\u00e9r\u00e9s au moyen de l\u2019\u00e9l\u00e9ment <script> . Cet \u00e9l\u00e9ment poss\u00e8de un attribut type qui sert \u00e0 indiquer le type de langage que l\u2019on va utiliser. dans notre cas, il s\u2019agit du JavaScript, mais \u00e7a pourrait \u00eatre autre chose, comme du VBScript. En HTML4 et XHTML 1.x, l\u2019attribut type est obligatoire. En revanche, en HTML5, il ne l\u2019est pas. L\u2019attribut type prend comme valeur text/javascript, qui est en fait le type MIME d\u2019un code JavaScript. Le JavaScript dans la page Rien de plus simple, on place le code au sein de l\u2019\u00e9l\u00e9ment <script> dans le <body> du HTML. <!DOCTYPE html> <html> <head> <title>Hello World!</title> </head> <body> <script> alert('Hello world!'); </script> </body> </html> En HTML4 ou en XHTML 1.x, il faut utiliser des commentaires d\u2019encadrement pour que la page soit conforme \u00e0 ces normes. C\u2019est inutile en HTML5. Ces commentaires servent \u00e0 isoler le code JavaScript pour ne pas qu\u2019il soit interpr\u00e9t\u00e9 par le validateur du W3C. Cela \u00e9vite d\u2019avoir des erreurs dans la page en emp\u00eachant par exemple l\u2019interpr\u00e9tation des chevrons < et > comme des balises HTML. <body> <script> <!-- valeur_1 > valeur_2; //--> </script> </body> Le JavaScript en externe Il est conseill\u00e9 d\u2019\u00e9crire le code JavaScript dans un fichier externe portant l\u2019extension .js . Ce fichier est ensuite appel\u00e9 depuis la page Web au moyen de l\u2019\u00e9l\u00e9ment script et de son attribut src qui contient l\u2019URL du fichier. Voici un exemple avec un fichier hello.js qui se situe dans le m\u00eame r\u00e9pertoire de la page Web. <!DOCTYPE html> <html> <head> <title>Test JavaScript</title> <meta charset=\"utf-8\" /> </head> <body> <script src=\"index.js\"></script> </body> </html> Il vaut mieux privil\u00e9gier un fichier externe plut\u00f4t que d\u2019inclure le code directement dans la page, car le fichier externe est mis en cache par le navigateur et n\u2019est donc pas recharg\u00e9 \u00e0 chaque chargement de la page, ce qui acc\u00e9l\u00e8re l\u2019affichage de la page. Une page Web est lue par le navigateur de fa\u00e7on lin\u00e9aire, c\u2019est \u00e0 dire d\u2019abord l\u2019\u00e9l\u00e9ment <head> puis les \u00e9l\u00e9ments <body> les uns \u00e0 la suite des autres. Si on appelle un fichier JavaScript d\u00e8s le d\u00e9but du chargement de la page, le navigateur va donc charger ce fichier et si ce dernier est volumineux, le chargement de la page s\u2019en trouvera ralenti car le navigateur va charger le fichier avant de commencer \u00e0 afficher le contenu de la page. Pour pallier ce probl\u00e8me, il est conseill\u00e9 de placer les \u00e9l\u00e9ments <script> juste avant la fermeture de l\u2019\u00e9l\u00e9ment <body> . Les variables Qu\u2019est ce qu\u2019une variable Une variable est un espace de stockage. Il faut commencer par la d\u00e9clarer, c\u2019est \u00e0 dire lui r\u00e9server un espace de stockage. Le mot cl\u00e9 var est pr\u00e9sent pour indiquer qu\u2019on d\u00e9clare une variable. var myVariable; JavaScript est sensible \u00e0 la casse , il faut faire attention aux majuscules et minuscules. JavaScript est un langage typ\u00e9 dynamiquement , cela veut dire que la d\u00e9claration de variable se fait avec le mot cl\u00e9 var sans distinction du contenu. Les trois types principaux en JavaScript : le type num\u00e9rique ( number ) pour les nombres entiers ou d\u00e9cimaux les cha\u00eenes de caract\u00e8res ( string ) : on peut l\u2019assigner avec des guillemets (\") ou des apostrophes ('). Pour \u00e9chapper les apostrophes, il faut utiliser \\ les bool\u00e9ens ( boolean ) : prennent soit la valeur true ou false L\u2019instruction typeof permet de tester l\u2019existence d\u2019une variable ou d\u2019en v\u00e9rifier son type. var myNumber = 2 var maString = \"toto\" var monBool = true console.log(typeof myNumber) // Affiche : \u00ab number \u00bb console.log(typeof maString) // Affiche : \u00ab string \u00bb console.log(typeof monBool) // Affiche : \u00ab boolean \u00bb console.log(typeof nothing) // Affiche : \u00ab undefined \u00bb Si l\u2019instruction typeof renvoie undefined, c\u2019est que soit votre variable est inexistante, soit qu\u2019elle est d\u00e9clar\u00e9e mais ne contient rien. Les op\u00e9rateurs arithm\u00e9tiques L\u2019addition + , la soustraction - , la multiplication * , la division / et le modulo % qui est le reste d\u2019une division. L'incr\u00e9mentation permet d\u2019ajouter une unit\u00e9 \u00e0 un nombre au moyen d\u2019une syntaxe court. A l\u2019inverse, la d\u00e9cr\u00e9mentation permet de soustraire une unit\u00e9. var a = 5 // la valeur est affich\u00e9e puis incr\u00e9ment\u00e9e console.log(a++) // 5 console.log(a) // 6 var b = 5 // la valeur est incr\u00e9ment\u00e9e puis affich\u00e9e console.log(++b) // 6 console.log(b) // 6 var c = 1 c += 2 console.log(c) // 3 c *= 4 console.log(c) // 12 c /= 2 console.log(c) // 6 Initiation \u00e0 la concat\u00e9nation et \u00e0 la conversion des types La concat\u00e9nation L\u2019op\u00e9rateur + permet de faire des concat\u00e9nations. var hi = 'Bonjour ', name = 'toi', result result = hi + name console.log(result) // Affiche : \u00ab Bonjour toi \u00bb Interagir avec l\u2019utilisateur La fonction prompt() renvoi ce que l\u2019utilisateur a \u00e9crit dans une bo\u00eete de dialogue sous forme d\u2019une cha\u00eene de caract\u00e8res, que l\u2019on peut donc r\u00e9cup\u00e9rer dans une variable. var text = prompt('Tapez quelque chose :') Convertir une cha\u00eene de caract\u00e8res en nombre Si on essaie de faire l\u2019addition de deux chiffres saisis par l\u2019utilisateur, ils vont \u00eatre concat\u00e9n\u00e9 (par exemple 3 + 6 va donner 36 et non pas 9) car ils sont consid\u00e9r\u00e9s comme une cha\u00eene de caract\u00e8res. Il faut donc convertir les variables en nombre avec la fonction parseInt() pour les nombres entiers et parseFloat() pour les nombres d\u00e9cimaux. Si on utilise parseInt() sur un nombre d\u00e9cimal, il sera tronqu\u00e9. var text = '1337', number number = parseInt(text) var text = '1337.54', number number = parseFloat(text) Convertir un nombre en cha\u00eene de caract\u00e8res L\u2019ajout d\u2019une cha\u00eene de caract\u00e8re vide entre les deux nombres les convertis en caract\u00e8res. var text, number1 = 4, number2 = 2 text = number1 + '' + number2 console.log(text) // Affiche : \u00ab 42 \u00bb Une fa\u00e7on de faire plus propre est d'utiliser la m\u00e9thode toString() var number=1337.65 var text = number.toString() console.log(number) // 1337.65 console.log(typeof number) // number console.log(text) // 1337.65 console.log(typeof text) // string Les conditions La base de toute condition : les bool\u00e9ens Les op\u00e9rateurs de comparaison : == \u00e9gal \u00e0 != diff\u00e9rent de === contenu et type \u00e9gal \u00e0 !== contenu ou type diff\u00e9rent de > sup\u00e9rieur \u00e0 >= sup\u00e9rieur ou \u00e9gal \u00e0 < inf\u00e9rieur \u00e0 <= inf\u00e9rieur ou \u00e9gal \u00e0 var number1 = 2, number2 = \"2\" console.log(number1 == number2) // true console.log(number1 === number2) // false Les op\u00e9rateurs logiques : && ET valeur1&&valeur2 || OU valeur1||valeur2 ! NON !valeur L\u2019op\u00e9rateur ET v\u00e9rifie que toutes les valeurs qui lui sont pass\u00e9es valent true. Si une seule renvoie false, alors la condition ne sera pas respect\u00e9e. L\u2019op\u00e9rateur OU renvoie true si une des valeurs qui lui est soumise contient true. L\u2019op\u00e9rateur NON inverse la valeur qui lui est pass\u00e9e, ainsi true devient false. var result = true && true console.log(result) // Affiche : \u00ab true \u00bb result = true && false console.log(result) // Affiche : \u00ab false \u00bb var result = false result = !result // On stocke dans \u00ab result \u00bb l'inverse de \u00ab result \u00bb console.log(result) // Affiche \u00ab true \u00bb car on voulait l'inverse de \u00ab false \u00bb La condition if if (2 < 8 && 8 >= 4) { // Cette condition renvoie \u00ab true \u00bb, le code est donc ex\u00e9cut\u00e9 console.log('La condition est bien v\u00e9rifi\u00e9e.') } if (2 > 8 || 8 <= 4) { // Cette condition renvoie \u00ab false \u00bb, le code n'est donc pas ex\u00e9cut\u00e9 console.log(\"La condition n'est pas v\u00e9rifi\u00e9e mais vous ne le saurez pas vu que ce code ne s'ex\u00e9cute pas.\") } La fonction confirm() On lui passe en param\u00e8tre une cha\u00eene de caract\u00e8res qui sera affich\u00e9e \u00e0 l\u2019\u00e9cran et elle retourne un bool\u00e9en en fonction de l\u2019action de l\u2019utilisateur sur la bo\u00eete de dialogue (OK ou Annuler). if (confirm('Voulez-vous ex\u00e9cuter le code JavaScript de cette page ?')) { console.log('Le code a bien \u00e9t\u00e9 ex\u00e9cut\u00e9 !') } Le code s\u2019ex\u00e9cute si on clique sur OK et ne s\u2019ex\u00e9cute pas si on clique sur Annuler. La structure if, else if, else pour dire sinon si, sinon Une premi\u00e8re condition est test\u00e9e, une deuxi\u00e8me sera test\u00e9e si la premi\u00e8re \u00e9choue, et si aucune condition ne se v\u00e9rifie, la structure else fait alors son travail. if(/* condition */){ // Du code... }else if(/* condition */){ // Du code... }else{ // Du code... } La condition \u201cswitch\u201d Tr\u00e8s pratique pour faire du cas par cas, il n\u2019est pas n\u00e9cessaire de r\u00e9\u00e9crire la condition \u00e0 chaque fois. var drawer = parseInt(prompt('Choisissez le tiroir \u00e0 ouvrir (1 \u00e0 3) :')); switch (drawer) { case 1: console.log('Contient divers outils pour dessiner : du papier, des crayons, etc.') break case 2: console.log('Contient du mat\u00e9riel informatique : des c\u00e2bles, des composants, etc.') break default: console.log(\"Info du jour : le meuble ne contient que 4 tiroirs et, jusqu'\u00e0 preuve du contraire, les tiroirs n\u00e9gatifs n'existent pas.\") } On \u00e9crit break \u00e0 la fin de chaque case pour casser le switch et \u00e9viter d\u2019ex\u00e9cuter le reste du code. L\u2019oubli du break fait ex\u00e9cuter tout le code \u00e0 partir du case choisi. Default sera ex\u00e9cut\u00e9 si aucun des cas pr\u00e9c\u00e9dents n\u2019a \u00e9t\u00e9 ex\u00e9cut\u00e9, partie optionnelle. L'op\u00e9rateur Ternaire C'est une syntaxe simplifi\u00e9e pour faire un if else mais un peu moins lisible : condition ? valeurSiTrue : valeurSiFalse Exemple : var gaetan = \"Ga\u00ebtan\" var louis = \"Louis\" var nomLePlusLong if(gaetan.length > louis.length){ nomLePlusLong = gaetan } else { nomLePlusLong = louis } console.log(nomLePlusLong) // affiche Ga\u00ebtan var nomLePlusLong2 = gaetan.length > louis.length ? gaetan : louis console.log(nomLePlusLong2) // affiche Ga\u00ebtan Les conditions sur les variables Tester l\u2019existence du contenu d\u2019une variable var conditionTest = 'Fonctionnera ? Fonctionnera pas ?' if (conditionTest) { console.log('Fonctionne !') } else { console.log('Ne fonctionne pas !') } Le code affiche le texte \u201cFonctionne\u201d car la variable conditionTest a \u00e9t\u00e9 convertie en bool\u00e9en et son contenu a \u00e9t\u00e9 \u00e9valu\u00e9 comme true. Pour qu\u2019il soit \u00e9valu\u00e9 comme false, il faut que que ce soit un nombre \u00e9gal \u00e0 0 ou une cha\u00eene de caract\u00e8res vide. La valeur undefined renvoie aussi false. Le cas de l\u2019op\u00e9rateur OU var conditionTest1 = '', conditionTest2 = 'Une cha\u00eene de caract\u00e8res' console.log(conditionTest1 || conditionTest2) L\u2019op\u00e9rateur OU en plus de sa fonction principale, permet de renvoyer la premi\u00e8re valeur \u00e9valu\u00e9e \u00e0 true. Dans cet exemple, elle renvoie donc Une cha\u00eene de caract\u00e8res . Les boucles La boucle while C\u2019est un r\u00e9p\u00e9tition d\u2019instruction jusqu\u2019\u00e0 ce qu\u2019on dise \u00e0 la boucle de s\u2019arr\u00eater. A chaque r\u00e9p\u00e9tition, on parle d\u2019it\u00e9ration. Tant que la condition est vraie, la boucle se r\u00e9p\u00e8te. while (condition) { instruction_1 instruction_2 } Il est possible d\u2019arr\u00eater la boucle avec le mot cl\u00e9 break . Il est possible de mettre fin \u00e0 une it\u00e9ration et faire continuer la boucle avec continue . La boucle do while Elle ressemble \u00e0 la boucle while sauf qu\u2019elle est toujours ex\u00e9cut\u00e9e au moins une fois. Dans le cas d\u2019une boucle while, si la condition n\u2019est pas valide, la boucle n\u2019est pas ex\u00e9cut\u00e9e. Avec do while, la boucle est ex\u00e9cut\u00e9e une premi\u00e8re fois, puis la condition est test\u00e9e pour savoir si la boucle doit continuer. do { instruction_1 instruction_2 } while (condition) Utilisation tr\u00e8s peu fr\u00e9quente car il est possible d\u2019utiliser une boucle while normale avec une condition qui fait que celle-ci est toujours ex\u00e9cut\u00e9e une fois. La boucle for Ressemble dans son fonctionnement \u00e0 la boucle while for (initialisation; condition; incr\u00e9mentation) { instruction_1 instruction_2 } L\u2019incr\u00e9mentation a lieu \u00e0 la fin de chaque it\u00e9ration. Le premier tour de boucle dans l\u2019exemple ci-dessous est donc fait avec iter=0. for (var iter = 0; iter < 5; iter++) { console.log('It\u00e9ration n\u00b0' + iter) // affiche 0 puis 1, 2, 3 et 4 } console.log(iter) // affiche 5 Port\u00e9e des variables de boucle En JavaScript, il est d\u00e9conseill\u00e9 de d\u00e9clarer des variables au sein d\u2019une boucle car il n\u2019est pas n\u00e9cessaire de d\u00e9clarer une variable \u00e0 chaque passage dans la boucle. Il est conseill\u00e9 de les d\u00e9clarer dans le bloc d\u2019initialisation, mais attention une fois la boucle ex\u00e9cut\u00e9e, la variable existe toujours. Ce comportement est diff\u00e9rent de celui de nombreux autres langages dans lesquels une variable d\u00e9clar\u00e9e dans une boucle est d\u00e9truite une fois la boucle ex\u00e9cut\u00e9e. Priorit\u00e9 d\u2019ex\u00e9cution Les trois blocs de la boucle for ne sont pas ex\u00e9cut\u00e9s en m\u00eame temps : initialisation : juste avant que la boucle ne d\u00e9marre condition : avant chaque passage de boucle incr\u00e9mentation : apr\u00e8s chaque passage de boucle. Cela veut dire que si on fait un break dans une boucle for, le passage dans la boucle lors du break ne sera pas comptabilis\u00e9. La boucle for est tr\u00e8s utilis\u00e9e en JavaScript, bien plus que la boucle while . Le fonctionnement de JavaScript fait que la boucle for est n\u00e9cessaire dans la majorit\u00e9 des cas comme la manipulation des tableaux ainsi que des objets. Nous verrons aussi une variante de la boucle for , appel\u00e9e for in . Les fonctions Concevoir des fonctions // d\u00e9claration d'une fonction function myFunction(arguments) { // Le code que la fonction va devoir ex\u00e9cuter } myFunction() // ex\u00e9cution de la fonction L\u2019utilit\u00e9 basique des fonctions est d\u2019\u00e9viter la r\u00e9p\u00e9tition de code. Le code \u00e9crit dans une fonction ne s'ex\u00e9cute pas imm\u00e9diatement, sinon l'int\u00e9r\u00eat serait nul. Pour cela il faut appeler la fonction afin de l'ex\u00e9cuter. La port\u00e9e des variables Toute variable d\u00e9clar\u00e9e dans une fonction n\u2019est utilisable que dans cette m\u00eame fonction, appel\u00e9e variable locale . Lorsqu\u2019une variable n\u2019est accessible que dans une partie du code, on dit qu\u2019elle se trouve au sein d\u2019un \u201cscope\u201d. Les variables d\u00e9clar\u00e9es en-dehors des fonctions sont appel\u00e9es variables globales , car elles sont accessibles partout dans le code, y compris dans les fonctions. Si on cr\u00e9e une variable locale avec le m\u00eame nom qu\u2019une variable globale, la variable locale prend le dessus le temps de l\u2019ex\u00e9cution de la fonction. Par principe, il faut d\u00e9clarer les variables qui ne servent que dans une fonction \u00e0 l\u2019int\u00e9rieur de celle-ci et non pas de mani\u00e8re globale. Les arguments et les valeurs de retour function myFunction(arg) { console.log('Votre argument : ' + arg) } function moar(first, second) { // On peut maintenant utiliser les variables \u00ab first \u00bb et \u00ab second \u00bb comme on le souhaite : console.log('Votre premier argument : ' + first) console.log('Votre deuxi\u00e8me argument : ' + second) } Les arguments sont propres \u00e0 leur fonction, ils ne seront accessibles que dans cette fonction et nulle part ailleurs. Les valeurs de retour Chaque fonction ne peut retourner qu\u2019une seule et unique valeur. Il est possible de contourner le probl\u00e8me en renvoyant un tableau ou un objet. L\u2019instruction return met fin \u00e0 la fonction puis retourne la valeur. function sayHello() { return 'Bonjour !' } console.log(sayHello()) // on affiche la valeur retourn\u00e9e par la fonction sayHello() Les fonctions anonymes Elles sont extr\u00eamement importantes en JavaScript. Elles servent pour les objets, les \u00e9v\u00e9nements, les variables statiques, les closures\u2026 Elles n\u2019ont pas de nom ! C\u2019est la seule diff\u00e9rence avec une fonction traditionnelle. function (arguments) { // Le code de votre fonction anonyme } Pour l\u2019appeler, il existe de tr\u00e8s nombreuses fa\u00e7ons de faire. Pour le moment, il faut se limiter \u00e0 une seule solution : assigner la fonction \u00e0 une variable. var sayHello = function(){ console.log('Bonjour !') } sayHello() // Affiche : \u00ab Bonjour ! \u00bb La variable sayHello est devenue une fonction. Les objets et les tableaux Introduction aux objets JavaScript est un langage orient\u00e9 objet, cela veut dire que le langage dispose d\u2019objets, qui disposent d\u2019une structure. JavaScript met \u00e0 notre disposition des objets natifs : un nombre, une cha\u00eene de caract\u00e8res, un bool\u00e9en. On dit que JavaScript n\u2019est pas un langage typ\u00e9 car les variables contiennent toujours la m\u00eame chose : un objet. Cet objet peut \u00eatre de nature diff\u00e9rente (nombre, bool\u00e9en\u2026). Il est \u00e9galement possible de cr\u00e9er nos propres objets, ce qui sera vu apr\u00e8s. Les objets contiennent trois choses distinctes : un constructeur code utilis\u00e9 quand on utilise un nouvel objet permet d\u2019effectuer des actions comme d\u00e9finir diverses variables r\u00e9alis\u00e9 automatiquement pour les objets natifs des propri\u00e9t\u00e9s une propri\u00e9t\u00e9 est une variable contenue dans l\u2019objet des m\u00e9thodes il est possible de modifier l\u2019objet gr\u00e2ce aux m\u00e9thodes qui sont des fonctions contenues dans l\u2019objet, qui permettent de r\u00e9aliser des op\u00e9rations sur le contenu de l\u2019objet var myString = 'Ceci est une cha\u00eene de caract\u00e8res' // On cr\u00e9e un objet String console.log(myString.length) // On affiche le nombre de caract\u00e8res, au moyen de la propri\u00e9t\u00e9 \u00ab length \u00bb console.log(myString.toUpperCase()) // On r\u00e9cup\u00e8re la cha\u00eene en majuscules, avec la m\u00e9thode toUpperCase() Le point apr\u00e8s un objet permet d\u2019acc\u00e9der aux propri\u00e9t\u00e9s et aux m\u00e9thodes d\u2019un objet. Nous avons d\u00e9j\u00e0 d\u00e9couvert trois objets natif : Number, Boolean, String. On allons maintenant d\u00e9couvrir l\u2019objet Array qui g\u00e8re les tableaux. Les tableaux Un tableau, array en anglais, contient plusieurs valeurs appel\u00e9es item . Chaque item est accessible au moyen d\u2019un indice dont la num\u00e9rotation commence \u00e0 0. var myArray = [1, 2, 3, 4, 5] console.log(myArray.length) // affiche 5 console.log(myArray[0]) // affiche 1, le premier \u00e9l\u00e9ment du tableau myArray[0]=8 // modifie la valeur du premier \u00e9l\u00e9ment du tableau console.log(myArray[0]) // affiche 8, le premier \u00e9l\u00e9ment du tableau console.log(myArray[myArray.length-1]) // affiche 5, le dernier \u00e9l\u00e9ment du tableau Pour plus de d\u00e9tails sur les tableaux, voir la partie Objets et fonctions utiles en JavaScript . Les objets litt\u00e9raux La syntaxe d\u2019un objet Il est possible d\u2019acc\u00e9der aux propri\u00e9t\u00e9s d'un objet via un identifiant. Un objet est similaire \u00e0 un tableau sauf que l\u2019on met des accolades \u00e0 la place des crochets. var myObject = { propertyName1: propertyValue1, propertyName2: propertyValue2, methode1: function(){ } } Pour d\u00e9finir d\u00e8s l\u2019initialisation les items \u00e0 ajouter, il suffit d\u2019\u00e9crire l\u2019identifiant suivi de deux points et de la valeur \u00e0 lui attribuer. La s\u00e9paration des items se fait comme pour un tableau, avec une virgule. var louis = { prenom: 'Louis', nom: 'Varlet', direPapa: function(){ console.log(\"Papa !\") } } // Acc\u00e8s aux propri\u00e9t\u00e9s console.log(louis) // permet d'acc\u00e9der \u00e0 l'objet louis console.log(typeof louis) // affiche object console.log(louis.prenom) // affiche Louis console.log(louis[\"prenom\"]) // affiche Louis (m\u00e9thode est utile si l\u2019identifiant est contenu dans une variable) // Ajouter une propri\u00e9t\u00e9 en sp\u00e9cifiant un identifiant qui n\u2019est pas encore pr\u00e9sent. console.log(louis.age) // affiche undefined louis.age = 1 console.log(louis.age) // affiche 1 louis[\"prenomPere\"] = \"Ga\u00ebtan\" // on peut aussi le faire avec les crochets console.log(louis.prenomPere) // affiche Ga\u00ebtan // Ex\u00e9cution d'une m\u00e9thode louis.direPapa() // affiche Papa ! Autre fa\u00e7on de cr\u00e9er un objet : var gaetan = new Object() gaetan.prenom = 'Ga\u00ebtan' gaetan.nom = 'Varlet' Parcourir un objet avec for in Il n\u2019est pas possible d\u2019utiliser une boucle for car elle incr\u00e9mente une variable num\u00e9rique ce qui est inutile sur un objet litt\u00e9ral puisque nous devons poss\u00e9der un identifiant. La boucle for in ne sert qu\u2019\u00e0 une chose : parcourir un objet. Le fonctionnement est quasiment le m\u00eame que pour un tableau, except\u00e9 qu\u2019il suffit de fournir une \u201cvariable cl\u00e9\u201d qui re\u00e7oit un identifiant (au lieu d\u2019un index) et de sp\u00e9cifier l\u2019objet \u00e0 parcourir : const louis = { prenom: \"Louis\", nom: \"Varlet\" } for(let property in louis){ console.log(louis[property]) } // affiche Louis // affiche Varlet Utilisation des objets litt\u00e9raux Ils peuvent \u00eatre utile pour ordonner un code. On les utilise aussi dans les fonctions, car return ne sait retourner qu\u2019une seule variable. Avec un objet, il est possible de retourner plusieurs variables en stockant les r\u00e9sultats dans l\u2019objet, plus commode qu\u2019un tableau. Exemple d\u2019une fonction qui calcule des coordonn\u00e9es d\u2019un \u00e9l\u00e9ment HTML sur une page Web et retourne les coordonn\u00e9es x et y : function getCoords() { /* Script incomplet, juste pour l'exemple */ return { x: 12, y: 21 } } var coords = getCoords() console.log(coords.x) // 12 console.log(coords.y) // 21 Les constructeurs Ils permettent de cr\u00e9er un moule pour cr\u00e9er plusieurs objets \u00e0 partir de ce moule function Dog(name, color, age){ this.name = name this.color = color this.age = age this.aboie = function(){ console.log(\"wouf wouf \"+this.name) } } var monChien = new Dog(\"Rex\", \"noir\", 6) console.log(monChien); // affiche le chien monChien.aboie(); // affiche : wouf wouf Rex","title":"Les bases"},{"location":"lesBasesDeJavaScript/#les-bases-de-javascript","text":"","title":"Les bases de JavaScript"},{"location":"lesBasesDeJavaScript/#introduction","text":"","title":"Introduction"},{"location":"lesBasesDeJavaScript/#quest-que-le-javascript","text":"Le JavaScript est un langage de programmation de scripts orient\u00e9 objet Un langage de programmation permet d\u2019\u00e9crire du code source qui sera analys\u00e9 par l\u2019ordinateur. Il existe trois mani\u00e8res d\u2019utiliser du code source : langage compil\u00e9 : le code source est donn\u00e9 \u00e0 un programme appel\u00e9 compilateur qui va lire le code source et le convertir dans un langage que l\u2019ordinateur sera capable d\u2019interpr\u00e9ter : le langage binaire. Les langages comme le C ou le C++ sont des langages dits compil\u00e9s langage pr\u00e9compil\u00e9 : le code source est partiellement compil\u00e9, dans un langage plus simple \u00e0 lire par l\u2019ordinateur mais ce n\u2019est pas encore du binaire. Ce code interm\u00e9diaire devra \u00eatre lu par une machine virtuelle qui ex\u00e9cutera ce code. Les langages comme Java ou C# sont dits pr\u00e9compil\u00e9s langage interpr\u00e9t\u00e9 : pas de compilation, le code source reste tel quel. Pour ex\u00e9cuter le code, on doit le fournir \u00e0 un interpr\u00e9teur qui lira le code et r\u00e9alisera les actions. Pour obtenir des gains de performances, on peut le le compiler \u00e0 la vol\u00e9e pendant son ex\u00e9cution, ce que font aujourd\u2019hui la plupart des interpr\u00e9teurs JavaScript Les scripts sont majoritairement interpr\u00e9t\u00e9s, ce qui est le cas de JavaScript qui est un langage interpr\u00e9t\u00e9. Il y a un interpr\u00e9teur JavaScript dans le navigateur Web, qui est diff\u00e9rent selon le navigateur : Chakra dans Internet Explorer, SpiderMonkey dans Firefox, V8 dans Chrome. Le JavaScript est majoritairement utilis\u00e9 sur les pages Web pour dynamiser les pages HTML, en ajoutant des interactions avec l\u2019utilisateur, des animations, de l\u2019aide \u00e0 la navigation, par exemple : afficher ou masquer du texte, faire d\u00e9filer des images, cr\u00e9er des infobulles\u2026 Les scripts JavaScript sont ex\u00e9cut\u00e9s par le navigateur chez l\u2019internaute (le client), contrairement aux langages serveur (comme le PHP) ex\u00e9cut\u00e9 par le serveur web. Un script serveur va s\u2019occuper de cr\u00e9er la page Web qui sera envoy\u00e9 au navigateur. Ce dernier va alors afficher la page puis ex\u00e9cuter les scripts client tel que le JavaScript. Le JavaScript ne sert pas que dans les pages Web. Il sert aussi \u00e0 r\u00e9aliser des extensions pour des programmes. Chrome et Firefox en poss\u00e8dent tous deux un panel gigantesque en partie cod\u00e9es en JavaSript. Il est aussi possible d\u2019ex\u00e9cuter du JavaScript en dehors du navigateur. Le JavaScript peut aussi \u00eatre utilis\u00e9 pour r\u00e9aliser des applications.","title":"Qu\u2019est que le JavaScript ?"},{"location":"lesBasesDeJavaScript/#petit-historique-du-langage","text":"En 1995, Brendan Eich d\u00e9veloppe le LiveScript qui sera renomm\u00e9 en JavaScript en hommage au langage Java. Netscape d\u00e9cide d\u2019envoyer sa version de JavaScript \u00e0 l\u2019ECMA international pour que le langage soit standardis\u00e9. L\u2019ECMA standardise le langage soit le nom d\u2019ECMAScript. L\u2019ECMAScript est la r\u00e9f\u00e9rence de base, de l\u00e0 en d\u00e9coule des impl\u00e9mentations comme le JavaScript. Les versions du JavaScript sont bas\u00e9es sur celles de l\u2019ECMAScript. Ainsi il existe : ES1 et ES2 qui sont les pr\u00e9mices du langage JavaScript ES3 sorti en d\u00e9cembre 1999 ES4 qui a \u00e9t\u00e9 abandonn\u00e9 en raison de modifications trop importantes qui ne furent pas appr\u00e9ci\u00e9es ES5 sortie en d\u00e9cembre 2009, la version la plus r\u00e9pandue et la plus utilis\u00e9e \u00e0 ce jour ES6, finalis\u00e9 en d\u00e9cembre 2014","title":"Petit historique du langage"},{"location":"lesBasesDeJavaScript/#deboguer-votre-code-grace-a-la-console","text":"Nous allons commencer \u00e0 \u00e9tudier les diff\u00e9rents bugs que l\u2019on va g\u00e9n\u00e9ralement rencontrer en JavaScript et surtout comment les r\u00e9soudre, en utilisant les kits de d\u00e9veloppement fournis avec n\u2019importe quel navigateur digne de ce nom.","title":"D\u00e9boguer votre code gr\u00e2ce \u00e0 la console"},{"location":"lesBasesDeJavaScript/#en-quoi-consiste-le-debogage","text":"","title":"En quoi consiste le d\u00e9bogage ?"},{"location":"lesBasesDeJavaScript/#les-bugs","text":"Ce sont des erreurs humaines laiss\u00e9es dans le code. Il existe deux types principaux de bugs : ceux que l\u2019interpr\u00e9teur JavaScript saura signaler : fautes de syntaxe va myVar = 'test; // Le mot-cl\u00e9 \u00ab var \u00bb est mal orthographi\u00e9 et il manque une apostrophe ceux que l\u2019interpr\u00e9teur ne verra pas : erreurs dans l\u2019algorithme // On veut afficher la valeur 6 avec les nombres 3 et 2 var myVar = 3 + 2; // Mais on obtient 5 au lieu de 6 car on a fait une addition au lieu d'une multiplication Une erreur syntaxique emp\u00eache le code de s\u2019ex\u00e9cuter tandis que les erreurs d\u2019algorithme ne pose aucun probl\u00e8me d\u2019ex\u00e9cution.","title":"Les bugs"},{"location":"lesBasesDeJavaScript/#le-debogage","text":"Cette technique consiste \u00e0 supprimer les bugs qui existent dans le code. Les bugs syntaxiques sont les plus simples \u00e0 r\u00e9soudre car l\u2019interpr\u00e9teur JavaScript signale g\u00e9n\u00e9ralement l\u2019endroit o\u00f9 l\u2019erreur est apparue. En ce qui concerne les bugs algorithmiques, il va falloir chercher nous-m\u00eame. Le plus simple est souvent de remonter les couches de code pour trouver o\u00f9 l\u2019erreur s\u2019est produite.","title":"Le d\u00e9bogage"},{"location":"lesBasesDeJavaScript/#les-kits-de-developpement-et-leur-console","text":"Tous les navigateurs r\u00e9cent poss\u00e8de un kit de d\u00e9veloppement : Chrome, Firefox, IE, Safari, Op\u00e9ra\u2026 Ces kits permettent de d\u00e9boguer efficacement nos codes : d\u00e9tection des erreurs syntaxiques, afficher des valeurs dans la console, consulter le code HTML g\u00e9n\u00e9r\u00e9 par le code, analyser les requ\u00eates HTTP effectu\u00e9es par le navigateur, mesurer les performances du code, etc\u2026 Les fonctionnalit\u00e9s des diff\u00e9rents kits sont souvent identiques, mais il y a parfois quelques diff\u00e9rences. Nous verrons surtout celui de Chrome. Pour ouvrir le kit de d\u00e9veloppement, il faut appuyer sur F12 . Dans le cadre du d\u00e9bogage d\u2019erreurs, il est tr\u00e8s important de bien externaliser le code JavaScript car l\u2019affichage des erreurs peut \u00eatre erron\u00e9 avec Chrome lorsque le code JS est directement int\u00e9gr\u00e9 au sein du code HTML. Consulter la console pour voir les erreurs. On peut par exemple voir SyntaxError qui mentionne une erreur syntaxique. A droite du texte, on voit le nom du fichier concern\u00e9 ainsi que la ligne de code, qu\u2019il est possible de consulter en cliquant dessus. L\u2019interpr\u00e9teur JavaScript s\u2019arr\u00eate sur la premi\u00e8re erreur rencontr\u00e9e, m\u00eame s\u2019il y a plusieurs erreurs. En corrigeant la premi\u00e8re erreur, le navigateur affichera alors l\u2019erreur suivante. La console permet aussi de rep\u00e9rer des erreurs qui ne sont pas forc\u00e9ment li\u00e9es au JavaScript, telles que des images manquantes par exemple. En cas de page web non conforme \u00e0 ce qu\u2019on attend, il faut toujours consulter la console ce qui permet g\u00e9n\u00e9ralement de trouver la source du probl\u00e8me.","title":"Les kits de d\u00e9veloppement et leur console"},{"location":"lesBasesDeJavaScript/#aller-plus-loin-avec-la-console","text":"La console est un outil qui permet de faire plus que simplement lister les erreurs sur la page. La m\u00e9thode console.log() permet d\u2019afficher la valeur d\u2019une variable sans bloquer l\u2019ex\u00e9cution du code contrairement \u00e0 la fonction alert() . // on affiche un tableau. var helloArray = ['Hello', 'Bonjour', 'Hola']; console.log(helloArray); La m\u00e9thode console.log() permet d\u2019afficher le contenu de l\u2019objet. Elle est utilisable sur tous les types de variables et pourra rendre service de nombreuses fois. En plus de la m\u00e9thode log(), l\u2019objet console en propose d\u2019autres qui permettent de modifier la mani\u00e8re d\u2019afficher les valeurs : \u00e9mettre des alertes ou des erreurs avec les m\u00e9thodes warn() et error() , grouper des lignes de r\u00e9sultats avec group() et groupEnd() . Ces m\u00e9thodes sont faites pour d\u00e9boguer le code et n\u2019ont rien \u00e0 faire dans le code une fois le site mis en ligne. Dans la console, il y a une ligne en bas avec un chevron bleu o\u00f9 il est possible d\u2019\u00e9crire directement du code qui agit pendant son ex\u00e9cution ! Cependant, cela fonctionne uniquement sur les variables globales.","title":"Aller plus loin avec la console"},{"location":"lesBasesDeJavaScript/#utiliser-les-points-darret","text":"Pour identifier un bug qui se produit pendant une fraction de seconde, il est possible d\u2019utiliser un point d\u2019arr\u00eat, aussi appel\u00e9 breakpoint en anglais. Gr\u00e2ce aux points d\u2019arr\u00eat, nous allons pouvoir \u00e9tudier la pile d\u2019ex\u00e9cution de notre code, dans l\u2019onglet \u201cSources\u201d dans le kit de d\u00e9veloppement et choisir un fichier parmi ceux de la page web. Dans le fichier JS, il suffit de cliquer sur un num\u00e9ro de ligne pour mettre un point d\u2019arr\u00eat. Celui-ci indique au navigateur qu\u2019on souhaite mettre en pause le code avant l\u2019ex\u00e9cution de la ligne concern\u00e9e . Ils ne peuvent \u00eatre plac\u00e9 que sur des lignes comportant des instructions , c\u2019est impossible sur une ligne de d\u00e9claration de fonction par exemple. Il faut recharger la page pour prendre en compte le point d\u2019arr\u00eat. Le code sera surlign\u00e9 \u00e0 l\u2019endroit o\u00f9 il s\u2019est arr\u00eat\u00e9. On peut consulter les variables actuellement utilis\u00e9es au sein du scope actuel (dans le menu \u201cLocal\u201d) ainsi que les variables globales (menu \u201cGlobal\u201d). La pile d\u2019ex\u00e9cution Pour chaque point d\u2019arr\u00eat, on peut consulter la pile d\u2019ex\u00e9cution ( call stack ) qui d\u00e9finit par quelles fonctions le code est pass\u00e9 afin d\u2019atteindre la ligne actuellement mise en pause par le point d\u2019arr\u00eat. On peut cliquer sur chaque \u00e9tape de la pile et consulter les variables du scope. La pile permet aussi de savoir par quoi a \u00e9t\u00e9 d\u00e9clench\u00e9 une partie du code. Enfin il est possible de donner un nom \u00e0 une fonction anonyme dans la pile d\u2019ex\u00e9cution afin de mieux la rep\u00e9rer.","title":"Utiliser les points d\u2019arr\u00eat"},{"location":"lesBasesDeJavaScript/#premiers-pas","text":"L\u2019objectif ici est d\u2019apprendre \u00e0 int\u00e9grer le JavaScript aux pages Web.","title":"Premiers pas"},{"location":"lesBasesDeJavaScript/#afficher-une-boite-de-dialogue","text":"Dans les balises <body> du HTML, \u00e9crire <script> alert('Hello world!') </script> Une bo\u00eete de dialogue s'affiche avec le message Hello world! Dans cet exemple, il n\u2019y a qu\u2019une instruction : l\u2019appel de la fonction alert() . C\u2019est une instruction simple, appel\u00e9e fonction, qui permet d\u2019afficher une bo\u00eete de dialogue contenant un message. Une bo\u00eete de dialogue s'affiche avec le message Hello world!","title":"Afficher une bo\u00eete de dialogue"},{"location":"lesBasesDeJavaScript/#la-syntaxe-du-javascript","text":"","title":"La syntaxe du JavaScript"},{"location":"lesBasesDeJavaScript/#les-instructions","text":"Les instructions doivent \u00eatre s\u00e9par\u00e9es par un point-virgule, non obligatoire si l\u2019instruction qui suit se trouve sur la ligne suivante. instruction_1 instruction_2; instruction_3; instruction_4","title":"Les instructions"},{"location":"lesBasesDeJavaScript/#les-espaces","text":"Le JavaScript n\u2019est pas sensible aux espaces, on peut donc indenter comme on le souhaite les instructions.","title":"Les espaces"},{"location":"lesBasesDeJavaScript/#les-commentaires","text":"Il existe des commentaires de fin de ligne et des commentaires multilignes. instruction_1 // Ceci est ma premi\u00e8re instruction instruction_2 // La troisi\u00e8me instruction ci-dessous : instruction_3 /* Ce script comporte 3 instructions : - Instruction 1 qui fait telle chose - Instruction 2 qui fait autre chose - Instruction 3 qui termine le script */ instruction_1 instruction_2 instruction_3 // Fin du script","title":"Les commentaires"},{"location":"lesBasesDeJavaScript/#quelques-aides","text":"Un site de documentation : https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference Un site pour tester le code JavaScript en ligne : https://jsfiddle.net/","title":"Quelques aides"},{"location":"lesBasesDeJavaScript/#ou-placer-le-code-dans-la-page","text":"Les codes JavaScript sont ins\u00e9r\u00e9s au moyen de l\u2019\u00e9l\u00e9ment <script> . Cet \u00e9l\u00e9ment poss\u00e8de un attribut type qui sert \u00e0 indiquer le type de langage que l\u2019on va utiliser. dans notre cas, il s\u2019agit du JavaScript, mais \u00e7a pourrait \u00eatre autre chose, comme du VBScript. En HTML4 et XHTML 1.x, l\u2019attribut type est obligatoire. En revanche, en HTML5, il ne l\u2019est pas. L\u2019attribut type prend comme valeur text/javascript, qui est en fait le type MIME d\u2019un code JavaScript.","title":"O\u00f9 placer le code dans la page ?"},{"location":"lesBasesDeJavaScript/#le-javascript-dans-la-page","text":"Rien de plus simple, on place le code au sein de l\u2019\u00e9l\u00e9ment <script> dans le <body> du HTML. <!DOCTYPE html> <html> <head> <title>Hello World!</title> </head> <body> <script> alert('Hello world!'); </script> </body> </html> En HTML4 ou en XHTML 1.x, il faut utiliser des commentaires d\u2019encadrement pour que la page soit conforme \u00e0 ces normes. C\u2019est inutile en HTML5. Ces commentaires servent \u00e0 isoler le code JavaScript pour ne pas qu\u2019il soit interpr\u00e9t\u00e9 par le validateur du W3C. Cela \u00e9vite d\u2019avoir des erreurs dans la page en emp\u00eachant par exemple l\u2019interpr\u00e9tation des chevrons < et > comme des balises HTML. <body> <script> <!-- valeur_1 > valeur_2; //--> </script> </body>","title":"Le JavaScript dans la page"},{"location":"lesBasesDeJavaScript/#le-javascript-en-externe","text":"Il est conseill\u00e9 d\u2019\u00e9crire le code JavaScript dans un fichier externe portant l\u2019extension .js . Ce fichier est ensuite appel\u00e9 depuis la page Web au moyen de l\u2019\u00e9l\u00e9ment script et de son attribut src qui contient l\u2019URL du fichier. Voici un exemple avec un fichier hello.js qui se situe dans le m\u00eame r\u00e9pertoire de la page Web. <!DOCTYPE html> <html> <head> <title>Test JavaScript</title> <meta charset=\"utf-8\" /> </head> <body> <script src=\"index.js\"></script> </body> </html> Il vaut mieux privil\u00e9gier un fichier externe plut\u00f4t que d\u2019inclure le code directement dans la page, car le fichier externe est mis en cache par le navigateur et n\u2019est donc pas recharg\u00e9 \u00e0 chaque chargement de la page, ce qui acc\u00e9l\u00e8re l\u2019affichage de la page. Une page Web est lue par le navigateur de fa\u00e7on lin\u00e9aire, c\u2019est \u00e0 dire d\u2019abord l\u2019\u00e9l\u00e9ment <head> puis les \u00e9l\u00e9ments <body> les uns \u00e0 la suite des autres. Si on appelle un fichier JavaScript d\u00e8s le d\u00e9but du chargement de la page, le navigateur va donc charger ce fichier et si ce dernier est volumineux, le chargement de la page s\u2019en trouvera ralenti car le navigateur va charger le fichier avant de commencer \u00e0 afficher le contenu de la page. Pour pallier ce probl\u00e8me, il est conseill\u00e9 de placer les \u00e9l\u00e9ments <script> juste avant la fermeture de l\u2019\u00e9l\u00e9ment <body> .","title":"Le JavaScript en externe"},{"location":"lesBasesDeJavaScript/#les-variables","text":"","title":"Les variables"},{"location":"lesBasesDeJavaScript/#quest-ce-quune-variable","text":"Une variable est un espace de stockage. Il faut commencer par la d\u00e9clarer, c\u2019est \u00e0 dire lui r\u00e9server un espace de stockage. Le mot cl\u00e9 var est pr\u00e9sent pour indiquer qu\u2019on d\u00e9clare une variable. var myVariable; JavaScript est sensible \u00e0 la casse , il faut faire attention aux majuscules et minuscules. JavaScript est un langage typ\u00e9 dynamiquement , cela veut dire que la d\u00e9claration de variable se fait avec le mot cl\u00e9 var sans distinction du contenu. Les trois types principaux en JavaScript : le type num\u00e9rique ( number ) pour les nombres entiers ou d\u00e9cimaux les cha\u00eenes de caract\u00e8res ( string ) : on peut l\u2019assigner avec des guillemets (\") ou des apostrophes ('). Pour \u00e9chapper les apostrophes, il faut utiliser \\ les bool\u00e9ens ( boolean ) : prennent soit la valeur true ou false L\u2019instruction typeof permet de tester l\u2019existence d\u2019une variable ou d\u2019en v\u00e9rifier son type. var myNumber = 2 var maString = \"toto\" var monBool = true console.log(typeof myNumber) // Affiche : \u00ab number \u00bb console.log(typeof maString) // Affiche : \u00ab string \u00bb console.log(typeof monBool) // Affiche : \u00ab boolean \u00bb console.log(typeof nothing) // Affiche : \u00ab undefined \u00bb Si l\u2019instruction typeof renvoie undefined, c\u2019est que soit votre variable est inexistante, soit qu\u2019elle est d\u00e9clar\u00e9e mais ne contient rien.","title":"Qu\u2019est ce qu\u2019une variable"},{"location":"lesBasesDeJavaScript/#les-operateurs-arithmetiques","text":"L\u2019addition + , la soustraction - , la multiplication * , la division / et le modulo % qui est le reste d\u2019une division. L'incr\u00e9mentation permet d\u2019ajouter une unit\u00e9 \u00e0 un nombre au moyen d\u2019une syntaxe court. A l\u2019inverse, la d\u00e9cr\u00e9mentation permet de soustraire une unit\u00e9. var a = 5 // la valeur est affich\u00e9e puis incr\u00e9ment\u00e9e console.log(a++) // 5 console.log(a) // 6 var b = 5 // la valeur est incr\u00e9ment\u00e9e puis affich\u00e9e console.log(++b) // 6 console.log(b) // 6 var c = 1 c += 2 console.log(c) // 3 c *= 4 console.log(c) // 12 c /= 2 console.log(c) // 6","title":"Les op\u00e9rateurs arithm\u00e9tiques"},{"location":"lesBasesDeJavaScript/#initiation-a-la-concatenation-et-a-la-conversion-des-types","text":"","title":"Initiation \u00e0 la concat\u00e9nation et \u00e0 la conversion des types"},{"location":"lesBasesDeJavaScript/#la-concatenation","text":"L\u2019op\u00e9rateur + permet de faire des concat\u00e9nations. var hi = 'Bonjour ', name = 'toi', result result = hi + name console.log(result) // Affiche : \u00ab Bonjour toi \u00bb","title":"La concat\u00e9nation"},{"location":"lesBasesDeJavaScript/#interagir-avec-lutilisateur","text":"La fonction prompt() renvoi ce que l\u2019utilisateur a \u00e9crit dans une bo\u00eete de dialogue sous forme d\u2019une cha\u00eene de caract\u00e8res, que l\u2019on peut donc r\u00e9cup\u00e9rer dans une variable. var text = prompt('Tapez quelque chose :')","title":"Interagir avec l\u2019utilisateur"},{"location":"lesBasesDeJavaScript/#convertir-une-chaine-de-caracteres-en-nombre","text":"Si on essaie de faire l\u2019addition de deux chiffres saisis par l\u2019utilisateur, ils vont \u00eatre concat\u00e9n\u00e9 (par exemple 3 + 6 va donner 36 et non pas 9) car ils sont consid\u00e9r\u00e9s comme une cha\u00eene de caract\u00e8res. Il faut donc convertir les variables en nombre avec la fonction parseInt() pour les nombres entiers et parseFloat() pour les nombres d\u00e9cimaux. Si on utilise parseInt() sur un nombre d\u00e9cimal, il sera tronqu\u00e9. var text = '1337', number number = parseInt(text) var text = '1337.54', number number = parseFloat(text)","title":"Convertir une cha\u00eene de caract\u00e8res en nombre"},{"location":"lesBasesDeJavaScript/#convertir-un-nombre-en-chaine-de-caracteres","text":"L\u2019ajout d\u2019une cha\u00eene de caract\u00e8re vide entre les deux nombres les convertis en caract\u00e8res. var text, number1 = 4, number2 = 2 text = number1 + '' + number2 console.log(text) // Affiche : \u00ab 42 \u00bb Une fa\u00e7on de faire plus propre est d'utiliser la m\u00e9thode toString() var number=1337.65 var text = number.toString() console.log(number) // 1337.65 console.log(typeof number) // number console.log(text) // 1337.65 console.log(typeof text) // string","title":"Convertir un nombre en cha\u00eene de caract\u00e8res"},{"location":"lesBasesDeJavaScript/#les-conditions","text":"","title":"Les conditions"},{"location":"lesBasesDeJavaScript/#la-base-de-toute-condition-les-booleens","text":"Les op\u00e9rateurs de comparaison : == \u00e9gal \u00e0 != diff\u00e9rent de === contenu et type \u00e9gal \u00e0 !== contenu ou type diff\u00e9rent de > sup\u00e9rieur \u00e0 >= sup\u00e9rieur ou \u00e9gal \u00e0 < inf\u00e9rieur \u00e0 <= inf\u00e9rieur ou \u00e9gal \u00e0 var number1 = 2, number2 = \"2\" console.log(number1 == number2) // true console.log(number1 === number2) // false Les op\u00e9rateurs logiques : && ET valeur1&&valeur2 || OU valeur1||valeur2 ! NON !valeur L\u2019op\u00e9rateur ET v\u00e9rifie que toutes les valeurs qui lui sont pass\u00e9es valent true. Si une seule renvoie false, alors la condition ne sera pas respect\u00e9e. L\u2019op\u00e9rateur OU renvoie true si une des valeurs qui lui est soumise contient true. L\u2019op\u00e9rateur NON inverse la valeur qui lui est pass\u00e9e, ainsi true devient false. var result = true && true console.log(result) // Affiche : \u00ab true \u00bb result = true && false console.log(result) // Affiche : \u00ab false \u00bb var result = false result = !result // On stocke dans \u00ab result \u00bb l'inverse de \u00ab result \u00bb console.log(result) // Affiche \u00ab true \u00bb car on voulait l'inverse de \u00ab false \u00bb","title":"La base de toute condition : les bool\u00e9ens"},{"location":"lesBasesDeJavaScript/#la-condition-if","text":"if (2 < 8 && 8 >= 4) { // Cette condition renvoie \u00ab true \u00bb, le code est donc ex\u00e9cut\u00e9 console.log('La condition est bien v\u00e9rifi\u00e9e.') } if (2 > 8 || 8 <= 4) { // Cette condition renvoie \u00ab false \u00bb, le code n'est donc pas ex\u00e9cut\u00e9 console.log(\"La condition n'est pas v\u00e9rifi\u00e9e mais vous ne le saurez pas vu que ce code ne s'ex\u00e9cute pas.\") }","title":"La condition if"},{"location":"lesBasesDeJavaScript/#la-fonction-confirm","text":"On lui passe en param\u00e8tre une cha\u00eene de caract\u00e8res qui sera affich\u00e9e \u00e0 l\u2019\u00e9cran et elle retourne un bool\u00e9en en fonction de l\u2019action de l\u2019utilisateur sur la bo\u00eete de dialogue (OK ou Annuler). if (confirm('Voulez-vous ex\u00e9cuter le code JavaScript de cette page ?')) { console.log('Le code a bien \u00e9t\u00e9 ex\u00e9cut\u00e9 !') } Le code s\u2019ex\u00e9cute si on clique sur OK et ne s\u2019ex\u00e9cute pas si on clique sur Annuler.","title":"La fonction confirm()"},{"location":"lesBasesDeJavaScript/#la-structure-if-else-if-else-pour-dire-sinon-si-sinon","text":"Une premi\u00e8re condition est test\u00e9e, une deuxi\u00e8me sera test\u00e9e si la premi\u00e8re \u00e9choue, et si aucune condition ne se v\u00e9rifie, la structure else fait alors son travail. if(/* condition */){ // Du code... }else if(/* condition */){ // Du code... }else{ // Du code... }","title":"La structure if, else if, else pour dire sinon si, sinon"},{"location":"lesBasesDeJavaScript/#la-condition-switch","text":"Tr\u00e8s pratique pour faire du cas par cas, il n\u2019est pas n\u00e9cessaire de r\u00e9\u00e9crire la condition \u00e0 chaque fois. var drawer = parseInt(prompt('Choisissez le tiroir \u00e0 ouvrir (1 \u00e0 3) :')); switch (drawer) { case 1: console.log('Contient divers outils pour dessiner : du papier, des crayons, etc.') break case 2: console.log('Contient du mat\u00e9riel informatique : des c\u00e2bles, des composants, etc.') break default: console.log(\"Info du jour : le meuble ne contient que 4 tiroirs et, jusqu'\u00e0 preuve du contraire, les tiroirs n\u00e9gatifs n'existent pas.\") } On \u00e9crit break \u00e0 la fin de chaque case pour casser le switch et \u00e9viter d\u2019ex\u00e9cuter le reste du code. L\u2019oubli du break fait ex\u00e9cuter tout le code \u00e0 partir du case choisi. Default sera ex\u00e9cut\u00e9 si aucun des cas pr\u00e9c\u00e9dents n\u2019a \u00e9t\u00e9 ex\u00e9cut\u00e9, partie optionnelle.","title":"La condition \u201cswitch\u201d"},{"location":"lesBasesDeJavaScript/#loperateur-ternaire","text":"C'est une syntaxe simplifi\u00e9e pour faire un if else mais un peu moins lisible : condition ? valeurSiTrue : valeurSiFalse Exemple : var gaetan = \"Ga\u00ebtan\" var louis = \"Louis\" var nomLePlusLong if(gaetan.length > louis.length){ nomLePlusLong = gaetan } else { nomLePlusLong = louis } console.log(nomLePlusLong) // affiche Ga\u00ebtan var nomLePlusLong2 = gaetan.length > louis.length ? gaetan : louis console.log(nomLePlusLong2) // affiche Ga\u00ebtan","title":"L'op\u00e9rateur Ternaire"},{"location":"lesBasesDeJavaScript/#les-conditions-sur-les-variables","text":"Tester l\u2019existence du contenu d\u2019une variable var conditionTest = 'Fonctionnera ? Fonctionnera pas ?' if (conditionTest) { console.log('Fonctionne !') } else { console.log('Ne fonctionne pas !') } Le code affiche le texte \u201cFonctionne\u201d car la variable conditionTest a \u00e9t\u00e9 convertie en bool\u00e9en et son contenu a \u00e9t\u00e9 \u00e9valu\u00e9 comme true. Pour qu\u2019il soit \u00e9valu\u00e9 comme false, il faut que que ce soit un nombre \u00e9gal \u00e0 0 ou une cha\u00eene de caract\u00e8res vide. La valeur undefined renvoie aussi false. Le cas de l\u2019op\u00e9rateur OU var conditionTest1 = '', conditionTest2 = 'Une cha\u00eene de caract\u00e8res' console.log(conditionTest1 || conditionTest2) L\u2019op\u00e9rateur OU en plus de sa fonction principale, permet de renvoyer la premi\u00e8re valeur \u00e9valu\u00e9e \u00e0 true. Dans cet exemple, elle renvoie donc Une cha\u00eene de caract\u00e8res .","title":"Les conditions sur les variables"},{"location":"lesBasesDeJavaScript/#les-boucles","text":"","title":"Les boucles"},{"location":"lesBasesDeJavaScript/#la-boucle-while","text":"C\u2019est un r\u00e9p\u00e9tition d\u2019instruction jusqu\u2019\u00e0 ce qu\u2019on dise \u00e0 la boucle de s\u2019arr\u00eater. A chaque r\u00e9p\u00e9tition, on parle d\u2019it\u00e9ration. Tant que la condition est vraie, la boucle se r\u00e9p\u00e8te. while (condition) { instruction_1 instruction_2 } Il est possible d\u2019arr\u00eater la boucle avec le mot cl\u00e9 break . Il est possible de mettre fin \u00e0 une it\u00e9ration et faire continuer la boucle avec continue .","title":"La boucle while"},{"location":"lesBasesDeJavaScript/#la-boucle-do-while","text":"Elle ressemble \u00e0 la boucle while sauf qu\u2019elle est toujours ex\u00e9cut\u00e9e au moins une fois. Dans le cas d\u2019une boucle while, si la condition n\u2019est pas valide, la boucle n\u2019est pas ex\u00e9cut\u00e9e. Avec do while, la boucle est ex\u00e9cut\u00e9e une premi\u00e8re fois, puis la condition est test\u00e9e pour savoir si la boucle doit continuer. do { instruction_1 instruction_2 } while (condition) Utilisation tr\u00e8s peu fr\u00e9quente car il est possible d\u2019utiliser une boucle while normale avec une condition qui fait que celle-ci est toujours ex\u00e9cut\u00e9e une fois.","title":"La boucle do while"},{"location":"lesBasesDeJavaScript/#la-boucle-for","text":"Ressemble dans son fonctionnement \u00e0 la boucle while for (initialisation; condition; incr\u00e9mentation) { instruction_1 instruction_2 } L\u2019incr\u00e9mentation a lieu \u00e0 la fin de chaque it\u00e9ration. Le premier tour de boucle dans l\u2019exemple ci-dessous est donc fait avec iter=0. for (var iter = 0; iter < 5; iter++) { console.log('It\u00e9ration n\u00b0' + iter) // affiche 0 puis 1, 2, 3 et 4 } console.log(iter) // affiche 5 Port\u00e9e des variables de boucle En JavaScript, il est d\u00e9conseill\u00e9 de d\u00e9clarer des variables au sein d\u2019une boucle car il n\u2019est pas n\u00e9cessaire de d\u00e9clarer une variable \u00e0 chaque passage dans la boucle. Il est conseill\u00e9 de les d\u00e9clarer dans le bloc d\u2019initialisation, mais attention une fois la boucle ex\u00e9cut\u00e9e, la variable existe toujours. Ce comportement est diff\u00e9rent de celui de nombreux autres langages dans lesquels une variable d\u00e9clar\u00e9e dans une boucle est d\u00e9truite une fois la boucle ex\u00e9cut\u00e9e. Priorit\u00e9 d\u2019ex\u00e9cution Les trois blocs de la boucle for ne sont pas ex\u00e9cut\u00e9s en m\u00eame temps : initialisation : juste avant que la boucle ne d\u00e9marre condition : avant chaque passage de boucle incr\u00e9mentation : apr\u00e8s chaque passage de boucle. Cela veut dire que si on fait un break dans une boucle for, le passage dans la boucle lors du break ne sera pas comptabilis\u00e9. La boucle for est tr\u00e8s utilis\u00e9e en JavaScript, bien plus que la boucle while . Le fonctionnement de JavaScript fait que la boucle for est n\u00e9cessaire dans la majorit\u00e9 des cas comme la manipulation des tableaux ainsi que des objets. Nous verrons aussi une variante de la boucle for , appel\u00e9e for in .","title":"La boucle for"},{"location":"lesBasesDeJavaScript/#les-fonctions","text":"","title":"Les fonctions"},{"location":"lesBasesDeJavaScript/#concevoir-des-fonctions","text":"// d\u00e9claration d'une fonction function myFunction(arguments) { // Le code que la fonction va devoir ex\u00e9cuter } myFunction() // ex\u00e9cution de la fonction L\u2019utilit\u00e9 basique des fonctions est d\u2019\u00e9viter la r\u00e9p\u00e9tition de code. Le code \u00e9crit dans une fonction ne s'ex\u00e9cute pas imm\u00e9diatement, sinon l'int\u00e9r\u00eat serait nul. Pour cela il faut appeler la fonction afin de l'ex\u00e9cuter.","title":"Concevoir des fonctions"},{"location":"lesBasesDeJavaScript/#la-portee-des-variables","text":"Toute variable d\u00e9clar\u00e9e dans une fonction n\u2019est utilisable que dans cette m\u00eame fonction, appel\u00e9e variable locale . Lorsqu\u2019une variable n\u2019est accessible que dans une partie du code, on dit qu\u2019elle se trouve au sein d\u2019un \u201cscope\u201d. Les variables d\u00e9clar\u00e9es en-dehors des fonctions sont appel\u00e9es variables globales , car elles sont accessibles partout dans le code, y compris dans les fonctions. Si on cr\u00e9e une variable locale avec le m\u00eame nom qu\u2019une variable globale, la variable locale prend le dessus le temps de l\u2019ex\u00e9cution de la fonction. Par principe, il faut d\u00e9clarer les variables qui ne servent que dans une fonction \u00e0 l\u2019int\u00e9rieur de celle-ci et non pas de mani\u00e8re globale.","title":"La port\u00e9e des variables"},{"location":"lesBasesDeJavaScript/#les-arguments-et-les-valeurs-de-retour","text":"function myFunction(arg) { console.log('Votre argument : ' + arg) } function moar(first, second) { // On peut maintenant utiliser les variables \u00ab first \u00bb et \u00ab second \u00bb comme on le souhaite : console.log('Votre premier argument : ' + first) console.log('Votre deuxi\u00e8me argument : ' + second) } Les arguments sont propres \u00e0 leur fonction, ils ne seront accessibles que dans cette fonction et nulle part ailleurs. Les valeurs de retour Chaque fonction ne peut retourner qu\u2019une seule et unique valeur. Il est possible de contourner le probl\u00e8me en renvoyant un tableau ou un objet. L\u2019instruction return met fin \u00e0 la fonction puis retourne la valeur. function sayHello() { return 'Bonjour !' } console.log(sayHello()) // on affiche la valeur retourn\u00e9e par la fonction sayHello()","title":"Les arguments et les valeurs de retour"},{"location":"lesBasesDeJavaScript/#les-fonctions-anonymes","text":"Elles sont extr\u00eamement importantes en JavaScript. Elles servent pour les objets, les \u00e9v\u00e9nements, les variables statiques, les closures\u2026 Elles n\u2019ont pas de nom ! C\u2019est la seule diff\u00e9rence avec une fonction traditionnelle. function (arguments) { // Le code de votre fonction anonyme } Pour l\u2019appeler, il existe de tr\u00e8s nombreuses fa\u00e7ons de faire. Pour le moment, il faut se limiter \u00e0 une seule solution : assigner la fonction \u00e0 une variable. var sayHello = function(){ console.log('Bonjour !') } sayHello() // Affiche : \u00ab Bonjour ! \u00bb La variable sayHello est devenue une fonction.","title":"Les fonctions anonymes"},{"location":"lesBasesDeJavaScript/#les-objets-et-les-tableaux","text":"","title":"Les objets et les tableaux"},{"location":"lesBasesDeJavaScript/#introduction-aux-objets","text":"JavaScript est un langage orient\u00e9 objet, cela veut dire que le langage dispose d\u2019objets, qui disposent d\u2019une structure. JavaScript met \u00e0 notre disposition des objets natifs : un nombre, une cha\u00eene de caract\u00e8res, un bool\u00e9en. On dit que JavaScript n\u2019est pas un langage typ\u00e9 car les variables contiennent toujours la m\u00eame chose : un objet. Cet objet peut \u00eatre de nature diff\u00e9rente (nombre, bool\u00e9en\u2026). Il est \u00e9galement possible de cr\u00e9er nos propres objets, ce qui sera vu apr\u00e8s. Les objets contiennent trois choses distinctes : un constructeur code utilis\u00e9 quand on utilise un nouvel objet permet d\u2019effectuer des actions comme d\u00e9finir diverses variables r\u00e9alis\u00e9 automatiquement pour les objets natifs des propri\u00e9t\u00e9s une propri\u00e9t\u00e9 est une variable contenue dans l\u2019objet des m\u00e9thodes il est possible de modifier l\u2019objet gr\u00e2ce aux m\u00e9thodes qui sont des fonctions contenues dans l\u2019objet, qui permettent de r\u00e9aliser des op\u00e9rations sur le contenu de l\u2019objet var myString = 'Ceci est une cha\u00eene de caract\u00e8res' // On cr\u00e9e un objet String console.log(myString.length) // On affiche le nombre de caract\u00e8res, au moyen de la propri\u00e9t\u00e9 \u00ab length \u00bb console.log(myString.toUpperCase()) // On r\u00e9cup\u00e8re la cha\u00eene en majuscules, avec la m\u00e9thode toUpperCase() Le point apr\u00e8s un objet permet d\u2019acc\u00e9der aux propri\u00e9t\u00e9s et aux m\u00e9thodes d\u2019un objet. Nous avons d\u00e9j\u00e0 d\u00e9couvert trois objets natif : Number, Boolean, String. On allons maintenant d\u00e9couvrir l\u2019objet Array qui g\u00e8re les tableaux.","title":"Introduction aux objets"},{"location":"lesBasesDeJavaScript/#les-tableaux","text":"Un tableau, array en anglais, contient plusieurs valeurs appel\u00e9es item . Chaque item est accessible au moyen d\u2019un indice dont la num\u00e9rotation commence \u00e0 0. var myArray = [1, 2, 3, 4, 5] console.log(myArray.length) // affiche 5 console.log(myArray[0]) // affiche 1, le premier \u00e9l\u00e9ment du tableau myArray[0]=8 // modifie la valeur du premier \u00e9l\u00e9ment du tableau console.log(myArray[0]) // affiche 8, le premier \u00e9l\u00e9ment du tableau console.log(myArray[myArray.length-1]) // affiche 5, le dernier \u00e9l\u00e9ment du tableau Pour plus de d\u00e9tails sur les tableaux, voir la partie Objets et fonctions utiles en JavaScript .","title":"Les tableaux"},{"location":"lesBasesDeJavaScript/#les-objets-litteraux","text":"","title":"Les objets litt\u00e9raux"},{"location":"lesBasesDeJavaScript/#la-syntaxe-dun-objet","text":"Il est possible d\u2019acc\u00e9der aux propri\u00e9t\u00e9s d'un objet via un identifiant. Un objet est similaire \u00e0 un tableau sauf que l\u2019on met des accolades \u00e0 la place des crochets. var myObject = { propertyName1: propertyValue1, propertyName2: propertyValue2, methode1: function(){ } } Pour d\u00e9finir d\u00e8s l\u2019initialisation les items \u00e0 ajouter, il suffit d\u2019\u00e9crire l\u2019identifiant suivi de deux points et de la valeur \u00e0 lui attribuer. La s\u00e9paration des items se fait comme pour un tableau, avec une virgule. var louis = { prenom: 'Louis', nom: 'Varlet', direPapa: function(){ console.log(\"Papa !\") } } // Acc\u00e8s aux propri\u00e9t\u00e9s console.log(louis) // permet d'acc\u00e9der \u00e0 l'objet louis console.log(typeof louis) // affiche object console.log(louis.prenom) // affiche Louis console.log(louis[\"prenom\"]) // affiche Louis (m\u00e9thode est utile si l\u2019identifiant est contenu dans une variable) // Ajouter une propri\u00e9t\u00e9 en sp\u00e9cifiant un identifiant qui n\u2019est pas encore pr\u00e9sent. console.log(louis.age) // affiche undefined louis.age = 1 console.log(louis.age) // affiche 1 louis[\"prenomPere\"] = \"Ga\u00ebtan\" // on peut aussi le faire avec les crochets console.log(louis.prenomPere) // affiche Ga\u00ebtan // Ex\u00e9cution d'une m\u00e9thode louis.direPapa() // affiche Papa ! Autre fa\u00e7on de cr\u00e9er un objet : var gaetan = new Object() gaetan.prenom = 'Ga\u00ebtan' gaetan.nom = 'Varlet'","title":"La syntaxe d\u2019un objet"},{"location":"lesBasesDeJavaScript/#parcourir-un-objet-avec-for-in","text":"Il n\u2019est pas possible d\u2019utiliser une boucle for car elle incr\u00e9mente une variable num\u00e9rique ce qui est inutile sur un objet litt\u00e9ral puisque nous devons poss\u00e9der un identifiant. La boucle for in ne sert qu\u2019\u00e0 une chose : parcourir un objet. Le fonctionnement est quasiment le m\u00eame que pour un tableau, except\u00e9 qu\u2019il suffit de fournir une \u201cvariable cl\u00e9\u201d qui re\u00e7oit un identifiant (au lieu d\u2019un index) et de sp\u00e9cifier l\u2019objet \u00e0 parcourir : const louis = { prenom: \"Louis\", nom: \"Varlet\" } for(let property in louis){ console.log(louis[property]) } // affiche Louis // affiche Varlet","title":"Parcourir un objet avec for in"},{"location":"lesBasesDeJavaScript/#utilisation-des-objets-litteraux","text":"Ils peuvent \u00eatre utile pour ordonner un code. On les utilise aussi dans les fonctions, car return ne sait retourner qu\u2019une seule variable. Avec un objet, il est possible de retourner plusieurs variables en stockant les r\u00e9sultats dans l\u2019objet, plus commode qu\u2019un tableau. Exemple d\u2019une fonction qui calcule des coordonn\u00e9es d\u2019un \u00e9l\u00e9ment HTML sur une page Web et retourne les coordonn\u00e9es x et y : function getCoords() { /* Script incomplet, juste pour l'exemple */ return { x: 12, y: 21 } } var coords = getCoords() console.log(coords.x) // 12 console.log(coords.y) // 21","title":"Utilisation des objets litt\u00e9raux"},{"location":"lesBasesDeJavaScript/#les-constructeurs","text":"Ils permettent de cr\u00e9er un moule pour cr\u00e9er plusieurs objets \u00e0 partir de ce moule function Dog(name, color, age){ this.name = name this.color = color this.age = age this.aboie = function(){ console.log(\"wouf wouf \"+this.name) } } var monChien = new Dog(\"Rex\", \"noir\", 6) console.log(monChien); // affiche le chien monChien.aboie(); // affiche : wouf wouf Rex","title":"Les constructeurs"},{"location":"modelerVosPagesWeb/","text":"Manipuler le code HTML (partie 1/2) Manipuler le code HTML (partie 2/2) Naviguer entre les noeuds La propri\u00e9t\u00e9 parentNode Elle permet d'acc\u00e9der \u00e0 l'\u00e9l\u00e9ment parent d'un \u00e9l\u00e9ment. <blockquote> <p id=\"myP\">Ceci est un paragraphe !</p> </blockquote> var paragraph = document.getElementById('myP'); var blockquote = paragraph.parentNode; nodeType et nodeName permettent de v\u00e9rifier le type d'un noeud et le nom d'un noeud. nodeType retourne un nombre qui correspond \u00e0 un type de noeud : 1 pour noeuf \u00e9l\u00e9ment, 2 pour noeud attribut, 3 pour noeud texte... firstChild et lastChild permettent d'acc\u00e9der au premier et au dernier enfant d'un noeud. Dans l'exemple suivant, le premier enfant de <p> est un noeud textuel, le dernier enfant un \u00e9l\u00e9ment <strong> . Il existe aussi les prorpri\u00e9t\u00e9s firstElementChild et lastElementChild pour \u00e9viter les noeuds #text . <p id=\"myP\">Un peu de texte, <a>un lien</a> et <strong>une portion en emphase</strong></p> var paragraph = document.getElementById('myP'); var first = paragraph.firstChild; var last = paragraph.lastChild; Autres propri\u00e9t\u00e9s nodeValue et data sont des propri\u00e9t\u00e9s qui s'appliquent sur des noeuds textuels et affichent le contenu var paragraph = document.getElementById('myP'); var first = paragraph.firstChild; var last = paragraph.lastChild; alert(first.nodeValue); alert(last.firstChild.data); childNodes est une propri\u00e9t\u00e9 qui retourne un tableau contenant la liste des enfants d'un \u00e9l\u00e9ment nextSibling et previousSibling permettent d'acc\u00e9der au noeud suivant et pr\u00e9c\u00e9dent Attention au noeuds vides <div> <p>Paragraphe 1</p> <p>Paragraphe 2</p> <p>Paragraphe 3</p> </div> <div><p>Paragraphe 1</p><p>Paragraphe 2</p><p>Paragraphe 3</p></div> Les espaces ou les retours \u00e0 la ligne sont consid\u00e9r\u00e9s comme des noeuds textuels dans certains navigateurs. Dans le premier exemple, on a donc 7 noeuds enfants dans la <div> : un #text vide suivi d'un <p> suivi d'un #text vide... alors que dans le deuxi\u00e8me exemple, on a 3 noeuds enfants qui sont des <p> . Pour \u00e9viter ces noeuds textuels vides, il faut utiliser les attributs firstElementChild , lastElementChild , nextElementSibling et previousElementSibling qui ne retournent que les \u00e9l\u00e9ments HTML et ignorent donc les noeuds textuels. Cr\u00e9er et ins\u00e9rer des \u00e9l\u00e9ments Pour ajouter des \u00e9l\u00e9ments HTML avec le DOM il faut : - cr\u00e9er l'\u00e9l\u00e9ment - se fait avec la m\u00e9thode createElement() - var newLink = document.createElement('a'); cr\u00e9e un \u00e9l\u00e9ment <a> mais celui-ci n'est pas ins\u00e9r\u00e9 dans le document, il n'est donc pas visible - lui affecter des attributs - on d\u00e9finit des attributs soit avec setAttribute() , soit directement avec les propri\u00e9t\u00e9s ad\u00e9quates - newLink.id = 'sdz_link'; ou newLink.setAttribute('tabindex', '10'); - l'ins\u00e9rer dans le document - se fait avec la m\u00e9thode appendChild() - par exemple document.getElementById('myP').appendChild(newLink); ajoute notre \u00e9l\u00e9ment <a> dans l'\u00e9l\u00e9ment <p> portant l'ID myP en tant que dernier enfant Ajouter des noeuds textuels La m\u00e9thode createTextNode() sert \u00e0 cr\u00e9er un noeud de type #text . Il faut ensuite l'ins\u00e9rer avec la m\u00e9thode appendChild() sur l'\u00e9l\u00e9ment newLink . var newLinkText = document.createTextNode(\"Le Site du Z\u00e9ro\"); newLink.appendChild(newLinkText); Notions sur les r\u00e9f\u00e9rences En JavaScript, le contenu des variables est pass\u00e9 par valeur , c'est-\u00e0-dire que si on affecte la valeur d'une variable \u00e0 une autre variable, la valeur est copi\u00e9e dans une nouvelle, on a donc deux variables distinctes. Si on change la valeur d'une deux deux variables, l'autre reste inchang\u00e9. JavaScript poss\u00e8de aussi aussi un passage par r\u00e9f\u00e9rence , c'est-\u00e0-dire qu'on transmet l'adresse de la valeur, on peut donc avoir plusieurs variables qui pointent sur une m\u00eame valeur. On verra des exemples avec la cr\u00e9ation d'objets. Le concept de r\u00e9f\u00e9rence se retrouve avec le DOM : deux variables peuvent acc\u00e9der au m\u00eame \u00e9l\u00e9ment. Dans l'exemple suivant, la variable newLink contient une r\u00e9f\u00e9rence vers l'\u00e9l\u00e9ment <a> cr\u00e9\u00e9 (une adresse qui pointe vers <a> ). Une fois l'\u00e9l\u00e9ment HTML ins\u00e9r\u00e9 dans la page, on peut y acc\u00e9der de nombreuses fa\u00e7ons, comme avec getElementById . var newLink = document.createElement('a'); var newLinkText = document.createTextNode('Le Site du Z\u00e9ro'); newLink.id = 'sdz_link'; newLink.href = 'http://www.siteduzero.com'; newLink.appendChild(newLinkText); document.getElementById('myP').appendChild(newLink); Il faut retenir que les objets du DOM sont toujours accessibles par r\u00e9f\u00e9rence. On ne peut donc pas copier un \u00e9l\u00e9ment de la mani\u00e8re suivante, car les deux variables pointent vers le m\u00eame \u00e9l\u00e9ment. Pour duppliquer un \u00e9l\u00e9ment, il va faloir le cl\u00f4ner. var newDiv1 = document.createElement('div'); var newDiv2 = newDiv1; // On tente de copier le <div> Cl\u00f4ner, remplacer, supprimer cloneNode() permet de cloner un \u00e9l\u00e9ment, avec un param\u00e8tre \u00e0 renseigner \u00e0 true ou false si on souhaite cl\u00f4ner le noeud avec ou sans ses enfants et ses diff\u00e9rents attributs. Attention, les \u00e9v\u00e9nements ne sont pas copi\u00e9s. // On va cloner un \u00e9l\u00e9ment cr\u00e9\u00e9 : var hr1 = document.createElement('hr'); var hr2 = hr1.cloneNode(false); // Il n'a pas d'enfants\u2026 // Ici, on clone un \u00e9l\u00e9ment existant : var paragraph1 = document.getElementById('myP'); var paragraph2 = paragraph1.cloneNode(true); // Et attention, l'\u00e9l\u00e9ment est clon\u00e9, mais pas \u00ab ins\u00e9r\u00e9 \u00bb tant que l'on n'a pas appel\u00e9 appendChild() : paragraph1.parentNode.appendChild(paragraph2); replaceChild() permet de remplacer un \u00e9l\u00e9ment par un autre. Il y a deux param\u00e8tres : le nouvel \u00e9l\u00e9ment et l'\u00e9l\u00e9ment \u00e0 remplacer <body> <div> <p id=\"myP\">Un peu de texte <a>et un lien</a></p> </div> <script> var link = document.querySelector('a'); var newLabel = document.createTextNode('et un hyperlien'); link.replaceChild(newLabel, link.firstChild); </script> </body> removeChild() permet de supprimer un \u00e9l\u00e9ment. La m\u00e9thode prend en param\u00e8tre le noeud enfant \u00e0 retirer. La m\u00e9thode retourne l'\u00e9l\u00e9ment supprim\u00e9, il est donc possible de supprimer un \u00e9l\u00e9ment HTML et de la r\u00e9int\u00e9grer ensuite. var link = document.querySelector('a'); link.parentNode.removeChild(link); Autres actions hasChildNodes appliqu\u00e9e sur un \u00e9l\u00e9ment renvoie true si l'\u00e9l\u00e9ment poss\u00e8de au moins un enfant, false sinon insertBefore permet d'ins\u00e9rer un \u00e9l\u00e9ment avant un autre, avec en param\u00e8tre l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer et l'\u00e9l\u00e9ment avant lequel ins\u00e9rer l'\u00e9l\u00e9ment ---- Les \u00e9v\u00e9nements Que sont les \u00e9v\u00e9nements Les \u00e9v\u00e9nements permettent de d\u00e9clencher une fonction selon qu'une action s'est produite ou non, par exemple faire appara\u00eetre une fen\u00eatre alert() au survol d'une zone d'un \u00e9l\u00e9ment. Liste des \u00e9v\u00e9nements click : cliquer (appuyer puis rel\u00e2cher) sur l'\u00e9l\u00e9ment dblclick : double-cliquer sur l'\u00e9l\u00e9ment mouseover : faire entrer le curseur sur l'\u00e9l\u00e9ment mouseout : faire sortir le curseur de l'\u00e9l\u00e9ment mousedown : appuyer (sans rel\u00e2cher) sur le bouton gauche de la souris sur l'\u00e9l\u00e9ment mouseup : rel\u00e2cher le bouton gauche de la souris sur l'\u00e9l\u00e9ment mousemove : faire d\u00e9placer le curseur sur l'\u00e9l\u00e9ment keydown : appuyer (sans rel\u00e2cher) sur une touche de clavier sur l'\u00e9l\u00e9ment keyup : rel\u00e2cher une touche de clavier sur l'\u00e9l\u00e9ment keypress : frapper (appuyer puis rel\u00e2cher) une touche de clavier sur l'\u00e9l\u00e9ment focus : cibler l'\u00e9l\u00e9ment, pour qu'il re\u00e7oive tous les \u00e9v\u00e9nement du clavier blur : annuler le ciblage de l'\u00e9l\u00e9ment input : taper un caract\u00e8re dans un champ texte (support incomplet selon les navigateurs) select : s\u00e9lectionner le contenu d'un champ de texte (input, textarea...) Il existe aussi deux \u00e9v\u00e9n\u00e9ments sp\u00e9cifiques \u00e0 l'\u00e9l\u00e9ment form - submit pour envoyer le formulaire - reset pour r\u00e9initialiser le formulaire Utiliser les \u00e9v\u00e9n\u00e9ments sans le DOM l'\u00e9v\u00e9nement click . Dans l'exemple, il permet en cliquant sur le texte d'afficher la boite de dialogue <span onclick=\"alert('Hello !');\">Cliquez-moi !</span> le mot cl\u00e9 this est une propri\u00e9t\u00e9 pointant sur l'objet courant. L'appel \u00e0 ce mot-cl\u00e9 lors d'un \u00e9v\u00e9nement fait que l'objet point\u00e9 est l'\u00e9l\u00e9ment qui a d\u00e9clanch\u00e9 l'\u00e9v\u00e9nement <span onclick=\"alert('Voici le contenu de l\\'\u00e9l\u00e9ment que vous avez cliqu\u00e9 :\\n\\n' + this.innerHTML);\">Cliquez-moi !</span> le focus. Dans l'exemple, lorsqu'on clique sur l'input, il poss\u00e8de le focus et ex\u00e9cute l'\u00e9v\u00e9nement focus . Lorsque l'input perd le focus, cela d\u00e9clenche l'\u00e9v\u00e9nement blur <input id=\"input\" type=\"text\" size=\"50\" value=\"Cliquez ici !\" onfocus=\"this.value='Appuyez maintenant sur votre touche de tabulation.';\" onblur=\"this.value='Cliquez ici !';\"/> <br /><br/> <a href=\"#\" onfocus=\"document.getElementById('input').value = 'Vous avez maintenant le focus sur le lien, bravo !';\">Un lien bidon</a> bloquer l'action par d\u00e9faut. Par exemple, ne pas rediriger vers l'URL indiqu\u00e9 lorsqu'on clique sur un lien, en ajoutant dans return false; dans l'\u00e9v\u00e9n\u00e9ment . On peut \u00e9ventuellement mettre \"#\" dans le href, ce qui redirige en haut de la page Web <a href=\"http://www.siteduzero.com\" onclick=\"alert('Vous avez cliqu\u00e9 !'); return false;\">Cliquez-moi !</a> Par ailleurs, la balise <a> est con\u00e7ue pour rediriger vers une page Web et non pour servir de d\u00e9clencheur. Pour cela, utiliser une balise <button> a\u00e0 laquelle on retire le style CSS Les \u00e9v\u00e9nements au travers du DOM Le DOM-0 interface ancienne impl\u00e9ment\u00e9e par Netscape, appel\u00e9e DOM-0 on d\u00e9finit les \u00e9v\u00e9nements non plus dans le code HTML mais directement en JavaScript. Chaque \u00e9v\u00e9nement standard poss\u00e8de une propri\u00e9t\u00e9 dont le nom est pr\u00e9c\u00e9d\u00e9 des deux lettres \"on\". Cette propri\u00e9t\u00e9 prend pour valeur une fonction ou une fonction anonyme pour supprimer un \u00e9v\u00e9nement avec le DOM-0, il fait lui attribuer une fonction anonyme vide element.onclick = function() {}; <span id=\"clickme\">Cliquez-moi !</span> <script> var element = document.getElementById('clickme'); element.onclick = function() { alert(\"Vous m'avez cliqu\u00e9 !\"); }; </script> Le DOM-2 la m\u00e9thode sans le DOM ne permet pas d'acc\u00e9der \u00e0 l'objet Event qui contient beaucoup d'informations sur l'\u00e9v\u00e9nement d\u00e9clench\u00e9 le DOM-0 est vieux et ne permet pas de cr\u00e9er plusieurs fois le m\u00eame \u00e9v\u00e9nement le DOM-2 permet la cr\u00e9ation multiple d'un m\u00eame \u00e9v\u00e9nement et g\u00e8re aussi l'objet Event <span id=\"clickme\">Cliquez-moi !</span> <script> var element = document.getElementById('clickme'); element.addEventListener('click', function() { alert(\"Vous m'avez cliqu\u00e9 !\"); }); </script> Dans cet exemple, ce qui change par rapport au DOM-0 et qu'on n'utilise plus une propri\u00e9t\u00e9 mais la m\u00e9thode addEventListener() qui prend 3 param\u00e8tres : le nom de l'\u00e9v\u00e9n\u00e9ment sans \"on, la fonction \u00e0 ex\u00e9cuter, et un bool\u00e9en optionnel pour sp\u00e9cifier si on souhaite utiliser la phase de capture ou de bouillennement (cf ci-apr\u00e8s) On peut cr\u00e9er deux \u00e9v\u00e9nements identiques pour un m\u00eame \u00e9l\u00e9ment. Ainsi, lors du d\u00e9clenchement, les 2 \u00e9v\u00e9nements seront ex\u00e9cut\u00e9s. <span id=\"clickme\">Cliquez-moi !</span> <script> var element = document.getElementById('clickme'); // Premier \u00e9v\u00e9nement click element.addEventListener('click', function() { alert(\"Et de un !\"); }); // Deuxi\u00e8me \u00e9v\u00e9nement click element.addEventListener('click', function() { alert(\"Et de deux !\"); }); </script> Pour supprimer un \u00e9v\u00e9nement, il faut utiliser la m\u00e9thode removeEventListener() avec les m\u00eames param\u00e8tres utilis\u00e9s lors de sa cr\u00e9ation element.addEventListener('click', myFunction); // On cr\u00e9e l'\u00e9v\u00e9nement element.removeEventListener('click', myFunction); // On supprime l'\u00e9v\u00e9nement en lui repassant les m\u00eames param\u00e8tres Les phases de capture et de bouillonnement Ce sont deux \u00e9tapes distinctes de l'ex\u00e9cution d'un \u00e9v\u00e9nement. La capture s'ex\u00e9cute avant le d\u00e9clenchement de l'\u00e9v\u00e9nement tandis que le bouillonnement s'ex\u00e9cute apr\u00e8s le d\u00e9clenchement de l'\u00e9v\u00e9nement. Elles permettent de d\u00e9finir le sens de propagation des \u00e9v\u00e9nements <div> <span>Du texte !</span> </div> Dans cet exemple, si on attribue une fonction \u00e0 l'\u00e9v\u00e9nement click de chacun de ces deux \u00e9l\u00e9ments, quel \u00e9v\u00e9nement va se d\u00e9clencher en premier ? Avec la capture, l'\u00e9v\u00e9nement du <div> se d\u00e9clenchera en premier suivi de celui du <span> . Avec le bouillonnement, l'\u00e9v\u00e9nement du <span> se d\u00e9clenchera d'abord. La phase de bouillonnement est d\u00e9finie par d\u00e9faut et celle qu'on utilise le plus souvent. L'objet Event L'objet Event fournit une multitude d'informations sur l'\u00e9v\u00e9nement actuellement d\u00e9clench\u00e9, comme les touches actuellement enfonc\u00e9s, les coordonn\u00e9es du curseur, l'\u00e9l\u00e9ment qui a d\u00e9clench\u00e9 l'\u00e9v\u00e9nement... Cet objet n'est accessible que lorsqu'on \u00e9v\u00e9nement est d\u00e9clench\u00e9, dans une fonction ex\u00e9cut\u00e9e par un \u00e9v\u00e9nement element.addEventListener('click', function(e) { // L'argument \u00ab e \u00bb va r\u00e9cup\u00e9rer une r\u00e9f\u00e9rence vers l'objet \u00ab Event \u00bb alert(e.type); // Ceci affiche le type de l'\u00e9v\u00e9nement (click, mouseover, etc.) }); la propri\u00e9t\u00e9 type permet de savoir quel type d'\u00e9v\u00e9nement s'est d\u00e9clench\u00e9 la propri\u00e9t\u00e9 target permet de r\u00e9cup\u00e9rer l'\u00e9l\u00e9ment de l'\u00e9v\u00e9nement actuellement d\u00e9clench\u00e9, pour par exemple modifier le contenu d'un \u00e9l\u00e9ment cliqu\u00e9 <span id=\"clickme\">Cliquez-moi !</span> <script> var clickme = document.getElementById('clickme'); clickme.addEventListener('click', function(e) { e.target.innerHTML = 'Vous avez cliqu\u00e9 !'; }); </script> la propri\u00e9t\u00e9 currentTarget permet de conna\u00eetre l'\u00e9l\u00e9ment \u00e0 l'origine de l'\u00e9v\u00e9nement, alors que target permet de conna\u00eetre l'\u00e9l\u00e9ment d\u00e9clencheur qui peut \u00eatre un \u00e9l\u00e9ment enfant. Il s'utilise de la m\u00eame mani\u00e8re que target r\u00e9cup\u00e9rer la position du curseur, g\u00e9n\u00e9ralement par raport au coin sup\u00e9rieur gauche de la page Web, ou aussi au coin sup\u00e9rieur gauche de l'\u00e9cran. Il faut utiliser les propri\u00e9t\u00e9s clientX et clientY pour les positons horizontales et verticales. Souvent combin\u00e9 avec l'\u00e9v\u00e9nement mousemove car la position change \u00e0 chaque d\u00e9placement de la souris <div id=\"position\"></div> <script> var position = document.getElementById('position'); document.addEventListener('mousemove', function(e) { position.innerHTML = 'Position X : ' + e.clientX + 'px<br />Position Y : ' + e.clientY + 'px'; }); </script> la propri\u00e9t\u00e9 relatedTarget permet de r\u00e9cup\u00e9rer l'\u00e9l\u00e9ment en relation avec un \u00e9v\u00e9nement de souris. Elle ne s'utilise qu'avec les \u00e9v\u00e9nements mouseover (objet de l'\u00e9l\u00e9ment dont le curseur vient de sortir) et mouseout (objet de l'\u00e9l\u00e9ment sur lequel le curseur vient d'entrer) r\u00e9cup\u00e9rer les touches frapp\u00e9es par l'utilisateur, se fait par le biais de trois \u00e9v\u00e9nements les \u00e9v\u00e9nements keyup et keydown servent \u00e0 capter toutes les frappes des touches, ils retournent un caract\u00e8re majuscule que la touche Maj soit press\u00e9e ou non l'\u00e9v\u00e9nement keypress sert \u00e0 capter les touches qui \u00e9crivent. En tapant Maj+A, keypress d\u00e9tectera nien un A majuscule il existe trois propri\u00e9t\u00e9s capables de fournir une valeur : keyCode , charCode et which . keyCode est suffisante bloquer l'action par d\u00e9faut de certains \u00e9v\u00e9nements avec DOM-2, avec la m\u00e9thode preventDefault() <a id=\"link\" href=\"http://www.siteduzero.com\">Cliquez-moi !</a> <script> var link = document.getElementById('link'); link.addEventListener('click', function(e) { e.preventDefault(); // On bloque l'action par d\u00e9faut de cet \u00e9v\u00e9nement alert('Vous avez cliqu\u00e9 !'); }); </script> R\u00e9soudre les probl\u00e8mes d'h\u00e9ritage des \u00e9v\u00e9nements Parfois, un \u00e9v\u00e9nement appliqu\u00e9 sur un parent se propage \u00e0 ses enfants. Cet h\u00e9ritage des \u00e9v\u00e9nements peut provoquer des comportements inattendus. C'est le cas des \u00e9v\u00e9nements mouseover , mouseout , mousemove , click ... Pour r\u00e9gler cela, il faut utiliser la propri\u00e9t\u00e9 relatedTarget pour d\u00e9tecter quel est l'\u00e9l\u00e9ment vers lequel le curseur se dirige ou de quel \u00e9l\u00e9ment il provient. ---- Les formulaires Les propri\u00e9t\u00e9s On va s'int\u00e9resser aux propri\u00e9t\u00e9s sp\u00e9cifiques aux \u00e9l\u00e9ments d'un formulaire : value , disabled , checked ... La propri\u00e9t\u00e9 value Elle permet de d\u00e9finir une valeur pour diff\u00e9rents \u00e9l\u00e9ments d'un formulaire comme les <input> en lui assignant une valeur et elle est affich\u00e9e sur l'\u00e9l\u00e9ment HTML. Elle s'utilise aussi avec l'\u00e9l\u00e9ment <textarea> . Pour ce dernier, on ne peut pas utiiser innerHTML <input id=\"text\" type=\"text\" size=\"60\" value=\"Vous n'avez pas le focus !\" /> <script> var text = document.getElementById('text'); text.addEventListener('focus', function(e) { e.target.value = \"Vous avez le focus !\"; }); text.addEventListener('blur', function(e) { e.target.value = \"Vous n'avez pas le focus !\"; }); </script> Les bool\u00e9ens avec disabled , checked et readonly En HTML, ces 3 propri\u00e9t\u00e9s s'utilisent de la mani\u00e8re suivante : <input type=\"text\" disabled=\"disabled\" /> . En JavaScript, ces propri\u00e9t\u00e9s sont des bool\u00e9ens. <input id=\"text\" type=\"text\" /> <script> var text = document.getElementById('text'); text.disabled = true; </script> Pour les boutos de type radio, on peut utiliser la m\u00e9thode querySelectorAll() <label><input type=\"radio\" name=\"check\" value=\"1\" /> Case n\u00b01</label><br /> <label><input type=\"radio\" name=\"check\" value=\"2\" /> Case n\u00b02</label><br /> <label><input type=\"radio\" name=\"check\" value=\"3\" /> Case n\u00b03</label><br /> <label><input type=\"radio\" name=\"check\" value=\"4\" /> Case n\u00b04</label> <br /><br /> <input type=\"button\" value=\"Afficher la case coch\u00e9e\" onclick=\"check();\" /> <script> function check() { var inputs = document.querySelectorAll('input[type=radio]:checked'), inputsLength = inputs.length; for (var i = 0; i < inputsLength; i++) { alert('La case coch\u00e9e est la n\u00b0' + inputs[i].value); } } </script> Les listes d\u00e9roulantes avec selectedIndex et options","title":"Manipuler le code HTML (partie 1/2)"},{"location":"modelerVosPagesWeb/#manipuler-le-code-html-partie-12","text":"","title":"Manipuler le code HTML (partie 1/2)"},{"location":"modelerVosPagesWeb/#manipuler-le-code-html-partie-22","text":"","title":"Manipuler le code HTML (partie 2/2)"},{"location":"modelerVosPagesWeb/#naviguer-entre-les-noeuds","text":"","title":"Naviguer entre les noeuds"},{"location":"modelerVosPagesWeb/#la-propriete-parentnode","text":"Elle permet d'acc\u00e9der \u00e0 l'\u00e9l\u00e9ment parent d'un \u00e9l\u00e9ment. <blockquote> <p id=\"myP\">Ceci est un paragraphe !</p> </blockquote> var paragraph = document.getElementById('myP'); var blockquote = paragraph.parentNode; nodeType et nodeName permettent de v\u00e9rifier le type d'un noeud et le nom d'un noeud. nodeType retourne un nombre qui correspond \u00e0 un type de noeud : 1 pour noeuf \u00e9l\u00e9ment, 2 pour noeud attribut, 3 pour noeud texte... firstChild et lastChild permettent d'acc\u00e9der au premier et au dernier enfant d'un noeud. Dans l'exemple suivant, le premier enfant de <p> est un noeud textuel, le dernier enfant un \u00e9l\u00e9ment <strong> . Il existe aussi les prorpri\u00e9t\u00e9s firstElementChild et lastElementChild pour \u00e9viter les noeuds #text . <p id=\"myP\">Un peu de texte, <a>un lien</a> et <strong>une portion en emphase</strong></p> var paragraph = document.getElementById('myP'); var first = paragraph.firstChild; var last = paragraph.lastChild;","title":"La propri\u00e9t\u00e9 parentNode"},{"location":"modelerVosPagesWeb/#autres-proprietes","text":"nodeValue et data sont des propri\u00e9t\u00e9s qui s'appliquent sur des noeuds textuels et affichent le contenu var paragraph = document.getElementById('myP'); var first = paragraph.firstChild; var last = paragraph.lastChild; alert(first.nodeValue); alert(last.firstChild.data); childNodes est une propri\u00e9t\u00e9 qui retourne un tableau contenant la liste des enfants d'un \u00e9l\u00e9ment nextSibling et previousSibling permettent d'acc\u00e9der au noeud suivant et pr\u00e9c\u00e9dent","title":"Autres propri\u00e9t\u00e9s"},{"location":"modelerVosPagesWeb/#attention-au-noeuds-vides","text":"<div> <p>Paragraphe 1</p> <p>Paragraphe 2</p> <p>Paragraphe 3</p> </div> <div><p>Paragraphe 1</p><p>Paragraphe 2</p><p>Paragraphe 3</p></div> Les espaces ou les retours \u00e0 la ligne sont consid\u00e9r\u00e9s comme des noeuds textuels dans certains navigateurs. Dans le premier exemple, on a donc 7 noeuds enfants dans la <div> : un #text vide suivi d'un <p> suivi d'un #text vide... alors que dans le deuxi\u00e8me exemple, on a 3 noeuds enfants qui sont des <p> . Pour \u00e9viter ces noeuds textuels vides, il faut utiliser les attributs firstElementChild , lastElementChild , nextElementSibling et previousElementSibling qui ne retournent que les \u00e9l\u00e9ments HTML et ignorent donc les noeuds textuels.","title":"Attention au noeuds vides"},{"location":"modelerVosPagesWeb/#creer-et-inserer-des-elements","text":"Pour ajouter des \u00e9l\u00e9ments HTML avec le DOM il faut : - cr\u00e9er l'\u00e9l\u00e9ment - se fait avec la m\u00e9thode createElement() - var newLink = document.createElement('a'); cr\u00e9e un \u00e9l\u00e9ment <a> mais celui-ci n'est pas ins\u00e9r\u00e9 dans le document, il n'est donc pas visible - lui affecter des attributs - on d\u00e9finit des attributs soit avec setAttribute() , soit directement avec les propri\u00e9t\u00e9s ad\u00e9quates - newLink.id = 'sdz_link'; ou newLink.setAttribute('tabindex', '10'); - l'ins\u00e9rer dans le document - se fait avec la m\u00e9thode appendChild() - par exemple document.getElementById('myP').appendChild(newLink); ajoute notre \u00e9l\u00e9ment <a> dans l'\u00e9l\u00e9ment <p> portant l'ID myP en tant que dernier enfant Ajouter des noeuds textuels La m\u00e9thode createTextNode() sert \u00e0 cr\u00e9er un noeud de type #text . Il faut ensuite l'ins\u00e9rer avec la m\u00e9thode appendChild() sur l'\u00e9l\u00e9ment newLink . var newLinkText = document.createTextNode(\"Le Site du Z\u00e9ro\"); newLink.appendChild(newLinkText);","title":"Cr\u00e9er et ins\u00e9rer des \u00e9l\u00e9ments"},{"location":"modelerVosPagesWeb/#notions-sur-les-references","text":"En JavaScript, le contenu des variables est pass\u00e9 par valeur , c'est-\u00e0-dire que si on affecte la valeur d'une variable \u00e0 une autre variable, la valeur est copi\u00e9e dans une nouvelle, on a donc deux variables distinctes. Si on change la valeur d'une deux deux variables, l'autre reste inchang\u00e9. JavaScript poss\u00e8de aussi aussi un passage par r\u00e9f\u00e9rence , c'est-\u00e0-dire qu'on transmet l'adresse de la valeur, on peut donc avoir plusieurs variables qui pointent sur une m\u00eame valeur. On verra des exemples avec la cr\u00e9ation d'objets. Le concept de r\u00e9f\u00e9rence se retrouve avec le DOM : deux variables peuvent acc\u00e9der au m\u00eame \u00e9l\u00e9ment. Dans l'exemple suivant, la variable newLink contient une r\u00e9f\u00e9rence vers l'\u00e9l\u00e9ment <a> cr\u00e9\u00e9 (une adresse qui pointe vers <a> ). Une fois l'\u00e9l\u00e9ment HTML ins\u00e9r\u00e9 dans la page, on peut y acc\u00e9der de nombreuses fa\u00e7ons, comme avec getElementById . var newLink = document.createElement('a'); var newLinkText = document.createTextNode('Le Site du Z\u00e9ro'); newLink.id = 'sdz_link'; newLink.href = 'http://www.siteduzero.com'; newLink.appendChild(newLinkText); document.getElementById('myP').appendChild(newLink); Il faut retenir que les objets du DOM sont toujours accessibles par r\u00e9f\u00e9rence. On ne peut donc pas copier un \u00e9l\u00e9ment de la mani\u00e8re suivante, car les deux variables pointent vers le m\u00eame \u00e9l\u00e9ment. Pour duppliquer un \u00e9l\u00e9ment, il va faloir le cl\u00f4ner. var newDiv1 = document.createElement('div'); var newDiv2 = newDiv1; // On tente de copier le <div>","title":"Notions sur les r\u00e9f\u00e9rences"},{"location":"modelerVosPagesWeb/#cloner-remplacer-supprimer","text":"cloneNode() permet de cloner un \u00e9l\u00e9ment, avec un param\u00e8tre \u00e0 renseigner \u00e0 true ou false si on souhaite cl\u00f4ner le noeud avec ou sans ses enfants et ses diff\u00e9rents attributs. Attention, les \u00e9v\u00e9nements ne sont pas copi\u00e9s. // On va cloner un \u00e9l\u00e9ment cr\u00e9\u00e9 : var hr1 = document.createElement('hr'); var hr2 = hr1.cloneNode(false); // Il n'a pas d'enfants\u2026 // Ici, on clone un \u00e9l\u00e9ment existant : var paragraph1 = document.getElementById('myP'); var paragraph2 = paragraph1.cloneNode(true); // Et attention, l'\u00e9l\u00e9ment est clon\u00e9, mais pas \u00ab ins\u00e9r\u00e9 \u00bb tant que l'on n'a pas appel\u00e9 appendChild() : paragraph1.parentNode.appendChild(paragraph2); replaceChild() permet de remplacer un \u00e9l\u00e9ment par un autre. Il y a deux param\u00e8tres : le nouvel \u00e9l\u00e9ment et l'\u00e9l\u00e9ment \u00e0 remplacer <body> <div> <p id=\"myP\">Un peu de texte <a>et un lien</a></p> </div> <script> var link = document.querySelector('a'); var newLabel = document.createTextNode('et un hyperlien'); link.replaceChild(newLabel, link.firstChild); </script> </body> removeChild() permet de supprimer un \u00e9l\u00e9ment. La m\u00e9thode prend en param\u00e8tre le noeud enfant \u00e0 retirer. La m\u00e9thode retourne l'\u00e9l\u00e9ment supprim\u00e9, il est donc possible de supprimer un \u00e9l\u00e9ment HTML et de la r\u00e9int\u00e9grer ensuite. var link = document.querySelector('a'); link.parentNode.removeChild(link);","title":"Cl\u00f4ner, remplacer, supprimer"},{"location":"modelerVosPagesWeb/#autres-actions","text":"hasChildNodes appliqu\u00e9e sur un \u00e9l\u00e9ment renvoie true si l'\u00e9l\u00e9ment poss\u00e8de au moins un enfant, false sinon insertBefore permet d'ins\u00e9rer un \u00e9l\u00e9ment avant un autre, avec en param\u00e8tre l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer et l'\u00e9l\u00e9ment avant lequel ins\u00e9rer l'\u00e9l\u00e9ment","title":"Autres actions"},{"location":"modelerVosPagesWeb/#-","text":"","title":"----"},{"location":"modelerVosPagesWeb/#les-evenements","text":"","title":"Les \u00e9v\u00e9nements"},{"location":"modelerVosPagesWeb/#que-sont-les-evenements","text":"Les \u00e9v\u00e9nements permettent de d\u00e9clencher une fonction selon qu'une action s'est produite ou non, par exemple faire appara\u00eetre une fen\u00eatre alert() au survol d'une zone d'un \u00e9l\u00e9ment.","title":"Que sont les \u00e9v\u00e9nements"},{"location":"modelerVosPagesWeb/#liste-des-evenements","text":"click : cliquer (appuyer puis rel\u00e2cher) sur l'\u00e9l\u00e9ment dblclick : double-cliquer sur l'\u00e9l\u00e9ment mouseover : faire entrer le curseur sur l'\u00e9l\u00e9ment mouseout : faire sortir le curseur de l'\u00e9l\u00e9ment mousedown : appuyer (sans rel\u00e2cher) sur le bouton gauche de la souris sur l'\u00e9l\u00e9ment mouseup : rel\u00e2cher le bouton gauche de la souris sur l'\u00e9l\u00e9ment mousemove : faire d\u00e9placer le curseur sur l'\u00e9l\u00e9ment keydown : appuyer (sans rel\u00e2cher) sur une touche de clavier sur l'\u00e9l\u00e9ment keyup : rel\u00e2cher une touche de clavier sur l'\u00e9l\u00e9ment keypress : frapper (appuyer puis rel\u00e2cher) une touche de clavier sur l'\u00e9l\u00e9ment focus : cibler l'\u00e9l\u00e9ment, pour qu'il re\u00e7oive tous les \u00e9v\u00e9nement du clavier blur : annuler le ciblage de l'\u00e9l\u00e9ment input : taper un caract\u00e8re dans un champ texte (support incomplet selon les navigateurs) select : s\u00e9lectionner le contenu d'un champ de texte (input, textarea...) Il existe aussi deux \u00e9v\u00e9n\u00e9ments sp\u00e9cifiques \u00e0 l'\u00e9l\u00e9ment form - submit pour envoyer le formulaire - reset pour r\u00e9initialiser le formulaire","title":"Liste des \u00e9v\u00e9nements"},{"location":"modelerVosPagesWeb/#utiliser-les-evenements-sans-le-dom","text":"l'\u00e9v\u00e9nement click . Dans l'exemple, il permet en cliquant sur le texte d'afficher la boite de dialogue <span onclick=\"alert('Hello !');\">Cliquez-moi !</span> le mot cl\u00e9 this est une propri\u00e9t\u00e9 pointant sur l'objet courant. L'appel \u00e0 ce mot-cl\u00e9 lors d'un \u00e9v\u00e9nement fait que l'objet point\u00e9 est l'\u00e9l\u00e9ment qui a d\u00e9clanch\u00e9 l'\u00e9v\u00e9nement <span onclick=\"alert('Voici le contenu de l\\'\u00e9l\u00e9ment que vous avez cliqu\u00e9 :\\n\\n' + this.innerHTML);\">Cliquez-moi !</span> le focus. Dans l'exemple, lorsqu'on clique sur l'input, il poss\u00e8de le focus et ex\u00e9cute l'\u00e9v\u00e9nement focus . Lorsque l'input perd le focus, cela d\u00e9clenche l'\u00e9v\u00e9nement blur <input id=\"input\" type=\"text\" size=\"50\" value=\"Cliquez ici !\" onfocus=\"this.value='Appuyez maintenant sur votre touche de tabulation.';\" onblur=\"this.value='Cliquez ici !';\"/> <br /><br/> <a href=\"#\" onfocus=\"document.getElementById('input').value = 'Vous avez maintenant le focus sur le lien, bravo !';\">Un lien bidon</a> bloquer l'action par d\u00e9faut. Par exemple, ne pas rediriger vers l'URL indiqu\u00e9 lorsqu'on clique sur un lien, en ajoutant dans return false; dans l'\u00e9v\u00e9n\u00e9ment . On peut \u00e9ventuellement mettre \"#\" dans le href, ce qui redirige en haut de la page Web <a href=\"http://www.siteduzero.com\" onclick=\"alert('Vous avez cliqu\u00e9 !'); return false;\">Cliquez-moi !</a> Par ailleurs, la balise <a> est con\u00e7ue pour rediriger vers une page Web et non pour servir de d\u00e9clencheur. Pour cela, utiliser une balise <button> a\u00e0 laquelle on retire le style CSS","title":"Utiliser les \u00e9v\u00e9n\u00e9ments sans le DOM"},{"location":"modelerVosPagesWeb/#les-evenements-au-travers-du-dom","text":"","title":"Les \u00e9v\u00e9nements au travers du DOM"},{"location":"modelerVosPagesWeb/#le-dom-0","text":"interface ancienne impl\u00e9ment\u00e9e par Netscape, appel\u00e9e DOM-0 on d\u00e9finit les \u00e9v\u00e9nements non plus dans le code HTML mais directement en JavaScript. Chaque \u00e9v\u00e9nement standard poss\u00e8de une propri\u00e9t\u00e9 dont le nom est pr\u00e9c\u00e9d\u00e9 des deux lettres \"on\". Cette propri\u00e9t\u00e9 prend pour valeur une fonction ou une fonction anonyme pour supprimer un \u00e9v\u00e9nement avec le DOM-0, il fait lui attribuer une fonction anonyme vide element.onclick = function() {}; <span id=\"clickme\">Cliquez-moi !</span> <script> var element = document.getElementById('clickme'); element.onclick = function() { alert(\"Vous m'avez cliqu\u00e9 !\"); }; </script>","title":"Le DOM-0"},{"location":"modelerVosPagesWeb/#le-dom-2","text":"la m\u00e9thode sans le DOM ne permet pas d'acc\u00e9der \u00e0 l'objet Event qui contient beaucoup d'informations sur l'\u00e9v\u00e9nement d\u00e9clench\u00e9 le DOM-0 est vieux et ne permet pas de cr\u00e9er plusieurs fois le m\u00eame \u00e9v\u00e9nement le DOM-2 permet la cr\u00e9ation multiple d'un m\u00eame \u00e9v\u00e9nement et g\u00e8re aussi l'objet Event <span id=\"clickme\">Cliquez-moi !</span> <script> var element = document.getElementById('clickme'); element.addEventListener('click', function() { alert(\"Vous m'avez cliqu\u00e9 !\"); }); </script> Dans cet exemple, ce qui change par rapport au DOM-0 et qu'on n'utilise plus une propri\u00e9t\u00e9 mais la m\u00e9thode addEventListener() qui prend 3 param\u00e8tres : le nom de l'\u00e9v\u00e9n\u00e9ment sans \"on, la fonction \u00e0 ex\u00e9cuter, et un bool\u00e9en optionnel pour sp\u00e9cifier si on souhaite utiliser la phase de capture ou de bouillennement (cf ci-apr\u00e8s) On peut cr\u00e9er deux \u00e9v\u00e9nements identiques pour un m\u00eame \u00e9l\u00e9ment. Ainsi, lors du d\u00e9clenchement, les 2 \u00e9v\u00e9nements seront ex\u00e9cut\u00e9s. <span id=\"clickme\">Cliquez-moi !</span> <script> var element = document.getElementById('clickme'); // Premier \u00e9v\u00e9nement click element.addEventListener('click', function() { alert(\"Et de un !\"); }); // Deuxi\u00e8me \u00e9v\u00e9nement click element.addEventListener('click', function() { alert(\"Et de deux !\"); }); </script> Pour supprimer un \u00e9v\u00e9nement, il faut utiliser la m\u00e9thode removeEventListener() avec les m\u00eames param\u00e8tres utilis\u00e9s lors de sa cr\u00e9ation element.addEventListener('click', myFunction); // On cr\u00e9e l'\u00e9v\u00e9nement element.removeEventListener('click', myFunction); // On supprime l'\u00e9v\u00e9nement en lui repassant les m\u00eames param\u00e8tres","title":"Le DOM-2"},{"location":"modelerVosPagesWeb/#les-phases-de-capture-et-de-bouillonnement","text":"Ce sont deux \u00e9tapes distinctes de l'ex\u00e9cution d'un \u00e9v\u00e9nement. La capture s'ex\u00e9cute avant le d\u00e9clenchement de l'\u00e9v\u00e9nement tandis que le bouillonnement s'ex\u00e9cute apr\u00e8s le d\u00e9clenchement de l'\u00e9v\u00e9nement. Elles permettent de d\u00e9finir le sens de propagation des \u00e9v\u00e9nements <div> <span>Du texte !</span> </div> Dans cet exemple, si on attribue une fonction \u00e0 l'\u00e9v\u00e9nement click de chacun de ces deux \u00e9l\u00e9ments, quel \u00e9v\u00e9nement va se d\u00e9clencher en premier ? Avec la capture, l'\u00e9v\u00e9nement du <div> se d\u00e9clenchera en premier suivi de celui du <span> . Avec le bouillonnement, l'\u00e9v\u00e9nement du <span> se d\u00e9clenchera d'abord. La phase de bouillonnement est d\u00e9finie par d\u00e9faut et celle qu'on utilise le plus souvent.","title":"Les phases de capture et de bouillonnement"},{"location":"modelerVosPagesWeb/#lobjet-event","text":"L'objet Event fournit une multitude d'informations sur l'\u00e9v\u00e9nement actuellement d\u00e9clench\u00e9, comme les touches actuellement enfonc\u00e9s, les coordonn\u00e9es du curseur, l'\u00e9l\u00e9ment qui a d\u00e9clench\u00e9 l'\u00e9v\u00e9nement... Cet objet n'est accessible que lorsqu'on \u00e9v\u00e9nement est d\u00e9clench\u00e9, dans une fonction ex\u00e9cut\u00e9e par un \u00e9v\u00e9nement element.addEventListener('click', function(e) { // L'argument \u00ab e \u00bb va r\u00e9cup\u00e9rer une r\u00e9f\u00e9rence vers l'objet \u00ab Event \u00bb alert(e.type); // Ceci affiche le type de l'\u00e9v\u00e9nement (click, mouseover, etc.) }); la propri\u00e9t\u00e9 type permet de savoir quel type d'\u00e9v\u00e9nement s'est d\u00e9clench\u00e9 la propri\u00e9t\u00e9 target permet de r\u00e9cup\u00e9rer l'\u00e9l\u00e9ment de l'\u00e9v\u00e9nement actuellement d\u00e9clench\u00e9, pour par exemple modifier le contenu d'un \u00e9l\u00e9ment cliqu\u00e9 <span id=\"clickme\">Cliquez-moi !</span> <script> var clickme = document.getElementById('clickme'); clickme.addEventListener('click', function(e) { e.target.innerHTML = 'Vous avez cliqu\u00e9 !'; }); </script> la propri\u00e9t\u00e9 currentTarget permet de conna\u00eetre l'\u00e9l\u00e9ment \u00e0 l'origine de l'\u00e9v\u00e9nement, alors que target permet de conna\u00eetre l'\u00e9l\u00e9ment d\u00e9clencheur qui peut \u00eatre un \u00e9l\u00e9ment enfant. Il s'utilise de la m\u00eame mani\u00e8re que target r\u00e9cup\u00e9rer la position du curseur, g\u00e9n\u00e9ralement par raport au coin sup\u00e9rieur gauche de la page Web, ou aussi au coin sup\u00e9rieur gauche de l'\u00e9cran. Il faut utiliser les propri\u00e9t\u00e9s clientX et clientY pour les positons horizontales et verticales. Souvent combin\u00e9 avec l'\u00e9v\u00e9nement mousemove car la position change \u00e0 chaque d\u00e9placement de la souris <div id=\"position\"></div> <script> var position = document.getElementById('position'); document.addEventListener('mousemove', function(e) { position.innerHTML = 'Position X : ' + e.clientX + 'px<br />Position Y : ' + e.clientY + 'px'; }); </script> la propri\u00e9t\u00e9 relatedTarget permet de r\u00e9cup\u00e9rer l'\u00e9l\u00e9ment en relation avec un \u00e9v\u00e9nement de souris. Elle ne s'utilise qu'avec les \u00e9v\u00e9nements mouseover (objet de l'\u00e9l\u00e9ment dont le curseur vient de sortir) et mouseout (objet de l'\u00e9l\u00e9ment sur lequel le curseur vient d'entrer) r\u00e9cup\u00e9rer les touches frapp\u00e9es par l'utilisateur, se fait par le biais de trois \u00e9v\u00e9nements les \u00e9v\u00e9nements keyup et keydown servent \u00e0 capter toutes les frappes des touches, ils retournent un caract\u00e8re majuscule que la touche Maj soit press\u00e9e ou non l'\u00e9v\u00e9nement keypress sert \u00e0 capter les touches qui \u00e9crivent. En tapant Maj+A, keypress d\u00e9tectera nien un A majuscule il existe trois propri\u00e9t\u00e9s capables de fournir une valeur : keyCode , charCode et which . keyCode est suffisante bloquer l'action par d\u00e9faut de certains \u00e9v\u00e9nements avec DOM-2, avec la m\u00e9thode preventDefault() <a id=\"link\" href=\"http://www.siteduzero.com\">Cliquez-moi !</a> <script> var link = document.getElementById('link'); link.addEventListener('click', function(e) { e.preventDefault(); // On bloque l'action par d\u00e9faut de cet \u00e9v\u00e9nement alert('Vous avez cliqu\u00e9 !'); }); </script>","title":"L'objet Event"},{"location":"modelerVosPagesWeb/#resoudre-les-problemes-dheritage-des-evenements","text":"Parfois, un \u00e9v\u00e9nement appliqu\u00e9 sur un parent se propage \u00e0 ses enfants. Cet h\u00e9ritage des \u00e9v\u00e9nements peut provoquer des comportements inattendus. C'est le cas des \u00e9v\u00e9nements mouseover , mouseout , mousemove , click ... Pour r\u00e9gler cela, il faut utiliser la propri\u00e9t\u00e9 relatedTarget pour d\u00e9tecter quel est l'\u00e9l\u00e9ment vers lequel le curseur se dirige ou de quel \u00e9l\u00e9ment il provient.","title":"R\u00e9soudre les probl\u00e8mes d'h\u00e9ritage des \u00e9v\u00e9nements"},{"location":"modelerVosPagesWeb/#-_1","text":"","title":"----"},{"location":"modelerVosPagesWeb/#les-formulaires","text":"","title":"Les formulaires"},{"location":"modelerVosPagesWeb/#les-proprietes","text":"On va s'int\u00e9resser aux propri\u00e9t\u00e9s sp\u00e9cifiques aux \u00e9l\u00e9ments d'un formulaire : value , disabled , checked ...","title":"Les propri\u00e9t\u00e9s"},{"location":"modelerVosPagesWeb/#la-propriete-value","text":"Elle permet de d\u00e9finir une valeur pour diff\u00e9rents \u00e9l\u00e9ments d'un formulaire comme les <input> en lui assignant une valeur et elle est affich\u00e9e sur l'\u00e9l\u00e9ment HTML. Elle s'utilise aussi avec l'\u00e9l\u00e9ment <textarea> . Pour ce dernier, on ne peut pas utiiser innerHTML <input id=\"text\" type=\"text\" size=\"60\" value=\"Vous n'avez pas le focus !\" /> <script> var text = document.getElementById('text'); text.addEventListener('focus', function(e) { e.target.value = \"Vous avez le focus !\"; }); text.addEventListener('blur', function(e) { e.target.value = \"Vous n'avez pas le focus !\"; }); </script>","title":"La propri\u00e9t\u00e9 value"},{"location":"modelerVosPagesWeb/#les-booleens-avec-disabled-checked-et-readonly","text":"En HTML, ces 3 propri\u00e9t\u00e9s s'utilisent de la mani\u00e8re suivante : <input type=\"text\" disabled=\"disabled\" /> . En JavaScript, ces propri\u00e9t\u00e9s sont des bool\u00e9ens. <input id=\"text\" type=\"text\" /> <script> var text = document.getElementById('text'); text.disabled = true; </script> Pour les boutos de type radio, on peut utiliser la m\u00e9thode querySelectorAll() <label><input type=\"radio\" name=\"check\" value=\"1\" /> Case n\u00b01</label><br /> <label><input type=\"radio\" name=\"check\" value=\"2\" /> Case n\u00b02</label><br /> <label><input type=\"radio\" name=\"check\" value=\"3\" /> Case n\u00b03</label><br /> <label><input type=\"radio\" name=\"check\" value=\"4\" /> Case n\u00b04</label> <br /><br /> <input type=\"button\" value=\"Afficher la case coch\u00e9e\" onclick=\"check();\" /> <script> function check() { var inputs = document.querySelectorAll('input[type=radio]:checked'), inputsLength = inputs.length; for (var i = 0; i < inputsLength; i++) { alert('La case coch\u00e9e est la n\u00b0' + inputs[i].value); } } </script>","title":"Les bool\u00e9ens avec disabled, checked et readonly"},{"location":"modelerVosPagesWeb/#les-listes-deroulantes-avec-selectedindex-et-options","text":"","title":"Les listes d\u00e9roulantes avec selectedIndex et options"},{"location":"objetsEtFonctionsUtilesJavascript/","text":"Objets et fonctions utiles Javascript L'Objet Math L'objet Math est un objet natif dont les m\u00e9thodes et propri\u00e9t\u00e9s permettent l'utilisation de constantes et fonctions math\u00e9matiques. Contrairement aux autres objets globaux, Math n'est pas un constructeur. Toutes les propri\u00e9t\u00e9s et les m\u00e9thodes de Math sont statiques. Exemples de propri\u00e9t\u00e9s Math.E // nombre d'Euler, environ 2.718 Math.PI // nombre PI, environ 3.1416 Exemples de m\u00e9thodes Math.abs(x) // retourne la valeur absolue d'un nombre Math.cos(x) // retourne le cosinus d'un nombre Math.sin(x) // retourne le sinus d'un nombre Math.exp(x) // retourne l'exponentielle d'un nombre Math.log(x) // retourne le logarithme naturel (log e) d'un nombre Math.sqrt(x) // retourne la racine carr\u00e9e d'un nombre Math.pow(x,y) // retourne le calcul de x \u00e0 la puissance y Math.max(x,y,...) // retourne la plus grande valeur d'une liste de nombres, par exemple Math.max(0,-5,3,2) retourne 3 Math.min(x,y,...) // retourne la plus petite valeur d'une liste de nombres, par exemple Math.min(0,-5,3,2) retourne -5 Math.random() // retourne un nombre pseudo-al\u00e9atoire compris entre 0 (inclus) et 1 (exclu) Math.floor(x) // retourne le plus grand entier inf\u00e9rieur ou \u00e9gal \u00e0 la valeur pass\u00e9e en param\u00e8tre Math.ceil(x) // retourne le plus petit entier sup\u00e9rieur ou \u00e9gal \u00e0 la valeur pass\u00e9e en param\u00e8tre Math.round(x) // retourne l'arrondi \u00e0 l'unit\u00e9 d'un nombre Math.trunc(x) // retourne la partie enti\u00e8re d'un nombre (diff\u00e9rent de floor() pour les nombres n\u00e9gatifs) Pour arrondir \u00e0 2 chiffres apr\u00e8s la virgule, on peut faire Math.round(x * 100) / 100 . Exemple console.log(Math.round(123.45678 * 100) / 100) // affiche 123.46 Pour g\u00e9n\u00e9rer un nombre al\u00e9atoire entre 1 et 100, on peut faire : const myNumber = Math.trunc(Math.random() * 100) + 1 console.log(myNumber) L'objet Date Ce constructeur permet de cr\u00e9er des instances Date qui repr\u00e9sentent un moment pr\u00e9cis dans le temps. Les objets Date se basent sur une valeur de temps qui est le nombre de millisecondes depuis 1er janvier 1970 minuit UTC. Sans argument, le constructeur cr\u00e9e un objet Date pour la date du jour et l'heure selon l'heure locale du syst\u00e8me const date = new Date() console.log(date) // affiche : Thu Sep 06 2018 10:17:13 GMT+0200 (heure d\u2019\u00e9t\u00e9 d\u2019Europe centrale) const date2 = Date.now() // retourne la valeur num\u00e9rique correspondant au temps courant. Le nombre de millisecondes depuis le 1 janvier 1970, 00:00:00 UTC console.log(date2) // 1536222742607 On peut aussi cr\u00e9er une date avec des arguments, par exemple le 28 mars 2018 (attention, l'indice des mois commence \u00e0 0) : const date = new Date(2018,2,28) console.log(date) // affiche : Wed Mar 28 2018 00:00:00 GMT+0200 (heure d\u2019\u00e9t\u00e9 d\u2019Europe centrale) const date = new Date('2018/3/28') // \u00e9auivalent en passant une String en param\u00e8tre On peut r\u00e9cup\u00e8re des param\u00e8tres d'une date (mois, jour, heure...). Exemple : const date = new Date() console.log(date) // Thu Sep 06 2018 10:43:30 GMT+0200 (heure d\u2019\u00e9t\u00e9 d\u2019Europe centrale) console.log(date.getDate()) // 6 console.log(date.getDay()) // 4 console.log(date.getMonth()) // 8 console.log(date.getFullYear()) // 2018 console.log(date.getHours()) // 10 console.log(date.getTime()) // 1536223410659 (correspond au nombre de millisecondes depuis le 1er janvier 1970) Calculer le temps \u00e9coul\u00e9 function traitementQuiPrendBeaucoupDeTemps(){ let j = 0 for(let i =0 ; i < 1000000 ; i++){ j++ } return j } // en utilisant les objets Date const debut = Date.now() // l'\u00e9v\u00e8nement \u00e0 mesurer se trouve ici : traitementQuiPrendBeaucoupDeTemps() const fin = Date.now() const tempsEcoule = fin - debut // temps \u00e9coul\u00e9 en millisecondes console.log(tempsEcoule) // affiche 15 // en utilisant les m\u00e9thodes natives const debut2 = new Date() // l'\u00e9v\u00e8nement \u00e0 mesurer se trouve ici : traitementQuiPrendBeaucoupDeTemps() const fin2 = new Date() const tempsEcoule2 = fin2.getTime() - debut2.getTime() // temps \u00e9coul\u00e9 en millisecondes console.log(tempsEcoule2) // affiche 10 Expressions R\u00e9guli\u00e8res Les expressions r\u00e9guli\u00e8res sont des motifs utilis\u00e9s pour correspondre \u00e0 certaines combinaisons de caract\u00e8res au sein de cha\u00eenes de caract\u00e8res. En JavaScript, les expressions r\u00e9guli\u00e8res sont \u00e9galement des objets. Ces motifs sont utilis\u00e9s avec les m\u00e9thodes exec et test de la classe RegExp , et avec les m\u00e9thodes match , replace , search et split de String . Il est possible de construire une expression r\u00e9guli\u00e8re de deux fa\u00e7ons : const re1 = /ab+c/ // avec un litt\u00e9ral d'expression r\u00e9guli\u00e8re, compil\u00e9 lors du chargement du script. Plus performant si l'expression reste constante const re2 = new RegExp(\"ab+c\") // avec le constructeur de l'objet RegExp, compil\u00e9 lors de l'ex\u00e9cution console.log(re1) // affiche /ab+c/ console.log(re2) // affiche /ab+c/ Exemples d'utilisation des m\u00e9thodes : const monTemplate = /ab/ console.log(monTemplate) // affiche /ab/ // m\u00e9thodes de RegExp // ex\u00e9cute une recherche de correspondance dans une cha\u00eene de caract\u00e8res. Elle renvoie un tableau d'informations ou null lorsqu'il n'y a pas de correspondance console.log(monTemplate.exec(\"abc\")) // affiche un tableau avec l'index \u00e0 l'endroit ou commence le template dans la cha\u00eene console.log(monTemplate.exec(\"qsd\")) // affiche null // teste la pr\u00e9sence d'une correspondance dans une cha\u00eene de caract\u00e8res. Elle renvoie true ou false console.log(monTemplate.test(\"abc\")) // true console.log(monTemplate.test(\"qsd\")) // false // m\u00e9thodes de String // ex\u00e9cute une recherche de correspondance dans une cha\u00eene de caract\u00e8res. Elle renvoie un tableau d'informations ou null lorsqu'il n'y a pas de correspondance console.log(\"abc\".match(monTemplate)) // affiche un tableau comme la m\u00e9thode exec() console.log(\"qsd\".match(monTemplate)) // affiche null // teste la pr\u00e9sence d'une correspondance dans une cha\u00eene de correspondance. Elle renvoie la position de la correspondance ou -1 s'il n'y en a pas console.log(\"abc\".search(monTemplate)) // affiche 0 console.log(\"qsd\".search(monTemplate)) // affiche -1 // recherche une correspondance dans une cha\u00eene de caract\u00e8res et qui remplace la correspondance par une cha\u00eene de substitution console.log(\"abc\".replace(monTemplate, \"ZZZ\")) // affiche ZZZc // utilise une expression r\u00e9guli\u00e8re ou une cha\u00eene de caract\u00e8res pour d\u00e9couper une cha\u00eene de caract\u00e8res en un tableau comprenant les fragments r\u00e9sultants console.log(\"Bonjourabjeabm'appelleabGa\u00ebtan\".split(monTemplate)) // affiche [\"Bonjour\", \"je\", \"m'appelle\", \"Ga\u00ebtan\"] Le motif d'une expression r\u00e9guli\u00e8re est compos\u00e9 de motifs simples comme /abc/ ou de caract\u00e8res sp\u00e9ciaux comme /ab*c/ . Les motifs simples doivent avoir une correspondance directe, on doit observer exactement les caract\u00e8res 'des' ensemble et dans cet ordre pr\u00e9cis. Lorsque le motif \u00e0 trouver est plus complexe qu'une simple \u00e9galit\u00e9, le motif devra contenir des caract\u00e8res sp\u00e9ciaux. (voir la documentation en ligne pour plus de d\u00e9tail). Les expressions r\u00e9guli\u00e8res sont souvent utilis\u00e9s dans les formulaires pour v\u00e9rifier la validit\u00e9 des donn\u00e9es saisies par l'utilisateur. setTimeout et setInterval Ce sont 2 m\u00e9thodes de l'objet global window . On s'en sert beaucoup dans les animations. La m\u00e9thode setTimeout() permet de d\u00e9finir un \u00ab minuteur \u00bb (timer) qui ex\u00e9cute une fonction ou un code donn\u00e9 apr\u00e8s la fin du d\u00e9lai indiqu\u00e9. Le d\u00e9lai est exprim\u00e9e en millisecondes. function hello(){ console.log(\"hello\") } setTimeout(hello, 2000) // ex\u00e9cute 1 fois hello() au bout de 2 secondes La valeur renvoy\u00e9e par la fonction est un entier qui repr\u00e9sente un identifiant du minuteur cr\u00e9\u00e9 par l'appel \u00e0 setTimeout(). Cet identifiant pourra \u00eatre pass\u00e9 \u00e0 la m\u00e9thode clearTimeout() afin d'annuler ce minuteur donn\u00e9, par exemple avec un bouton. Il est possible d'ex\u00e9cuter plusieurs fois une fonction avec setTimeout() : function hello(){ console.log(\"hello\") setTimeout(hello, 2000) } hello() // la m\u00e9thode s'ex\u00e9cute une premi\u00e8re fois imm\u00e9diatement puis toutes les 2 secondes La m\u00e9thode setInterval() appelle une fonction de mani\u00e8re r\u00e9p\u00e9t\u00e9e, avec un certain d\u00e9lai fix\u00e9 entre chaque appel setInterval(hello, 2000) // ex\u00e9cute hello() toutes de 2 secondes au bout de 2 secondes la premi\u00e8re fois On peut arr\u00eater la m\u00e9thode setInterval() avec la m\u00e9thode clearInterval() . Il faut stocker l'interval dans une variable pour r\u00e9cup\u00e9rer l'intervalID. Dans l'exemple ci-dessous, hello() s'ex\u00e9cute 3 fois. function hello(){ console.log(\"hello\") } const monInterval = setInterval(hello, 2000) setTimeout(function(){ clearInterval(monInterval) }, 6000) Fonctions de String L'objet global String est un constructeur de cha\u00eenes de caract\u00e8res. Les objets String sont cr\u00e9\u00e9s en appelant le constructeur new String() . La fonction globale String() peut \u00e9galement \u00eatre appel\u00e9e sans l'op\u00e9rateur new pour cr\u00e9er une cha\u00eene primitive. Les objets String peuvent \u00eatre convertis en cha\u00eenes primitives \u00e0 l'aide de String.valueOf() : // cr\u00e9ation d'une cha\u00eene primitve const chainePrimitive = \"toto\"; // cr\u00e9ation d'un objet String const objetString = new String(chainePrimitive); console.log(typeof chainePrimitive); // affiche \"string\" console.log(typeof objetString); // affiche \"object\" console.log(typeof objetString.valueOf()); // affiche \"string\" \u00c9tant donn\u00e9 que JavaScript effectue automatiquement les conversions entre cha\u00eenes primitives et objets String, toute m\u00e9thode de l'objet String peut \u00eatre appel\u00e9e sur une cha\u00eene primitive. La propri\u00e9t\u00e9 length retourne la longueur de la cha\u00eene. Quelques m\u00e9thodes utiles : charAt(index) renvoie une nouvelle cha\u00eene contenant le caract\u00e8re \u00e0 la position indiqu\u00e9e en argument concat(string2,...stringN) combine le texte de plusieurs cha\u00eenes avec la cha\u00eene appelante et renvoie la nouvelle cha\u00eene ainsi form\u00e9e endsWith(cha\u00eeneRecherch\u00e9e) renvoie un bool\u00e9en indiquant si la chaine de caract\u00e8res se termine par la chaine de caract\u00e8res fournie en argument indexOf(valeurRecherch\u00e9e) renvoie l'indice de la premi\u00e8re occurence de la valeur cherch\u00e9e au sein de la cha\u00eene courante. Elle renvoie -1 si la valeur cherch\u00e9e n'est pas trouv\u00e9e lastIndexOf(valeurRecherch\u00e9e) envoie l'indice, dans la cha\u00eene courante, de la derni\u00e8re occurence de la valeur donn\u00e9e en argument. Si cette sous-cha\u00eene n'est pas trouv\u00e9e, la m\u00e9thode renvoie -1 replace() rechercher une correspondance entre une expression r\u00e9guli\u00e8re et une cha\u00eene, et remplace la sous-cha\u00eene correspondante par une nouvelle cha\u00eene search(regexp) renvoie l'indice de la premi\u00e8re correspondance pour l'expression r\u00e9guli\u00e8re au sein de la chaine de caract\u00e8res, sinon, la m\u00e9thode renvoie -1 slice(indiceDebut[, indiceFin]) extrait une section d'une chaine de caract\u00e8res et la retourne comme une nouvelle chaine de caract\u00e8res split(s\u00e9parateur) permet de diviser une cha\u00eene de caract\u00e8res \u00e0 partir d'un s\u00e9parateur pour fournir un tableau de sous-cha\u00eenes startsWith(cha\u00eeneRecherch\u00e9e) renvoie un bool\u00e9en indiquant si la chaine de caract\u00e8res commence par la deuxi\u00e8me chaine de caract\u00e8res fournie en argument substring(indiceA[, indiceB]) retourne une sous-cha\u00eene de la cha\u00eene courante, entre un indice de d\u00e9but et un indice de fin toLowerCase() retourne la cha\u00eene de caract\u00e8res courante en minuscules toString() renvoie une chaine de caract\u00e8res repr\u00e9sentant l'objet renseign\u00e9 toUpperCase() retourne la valeur de la cha\u00eene courante, convertie en majuscules trim() permet de retirer les blancs en d\u00e9but et fin de cha\u00eene valueOf() renvoie la valeur primitive de l'objet String Exemples : console.log(gaetan.length) // affiche 6 console.log(gaetan.charAt(1)) // affiche a console.log(gaetan[1]) // affiche a console.log(gaetan.concat(\" et Louis\")) // affiche Ga\u00ebtan et Louis console.log(gaetan.substring(1,3)) // affiche a\u00eb Fonctions de Array L'objet global Array est utilis\u00e9 pour cr\u00e9er des tableaux. On peut cr\u00e9er un tableau avec le constructeur Array, et aussi la syntaxe crochets. La propri\u00e9t\u00e9 length retourne la longueur de la cha\u00eene. Un tableau contient plusieurs valeurs appel\u00e9es item . Chaque item est accessible au moyen d\u2019un indice dont la num\u00e9rotation commence \u00e0 0. On acc\u00e9de \u00e0 un \u00e9l\u00e9ment d'un tableau en indiquant son indice entre crochets et on peut modifier la valeur d'un \u00e9l\u00e9m\u00e9net de cette mani\u00e8re. const myArray = [1, 2, 3, 4, 5] const myArray2 = new Array(1, 2, 3, 4, 5) console.log(myArray.length) // affiche 5 console.log(myArray[0]) // affiche 1, le premier \u00e9l\u00e9ment du tableau myArray[0]=8 // modifie la valeur du premier \u00e9l\u00e9ment du tableau console.log(myArray[0]) // affiche 8, le premier \u00e9l\u00e9ment du tableau console.log(myArray[myArray.length-1]) // affiche 5, le dernier \u00e9l\u00e9ment du tableau const myArray = [1, 2, 3, 4, 5] myArray.push(6) // ajoute l'\u00e9l\u00e9ment en param\u00e8tre \u00e0 la fin du tableau myArray.pop() // enl\u00e8ve le dernier \u00e9l\u00e9ment du tableau et le retourne myArray.shift() // enl\u00e8ve le premier \u00e9l\u00e9ment du tableau et le retourne myArray.unshift(0) // ajoute l'\u00e9l\u00e9ment en param\u00e8tre au d\u00e9but du tableau console.log(myArray) isArray() permet de d\u00e9terminer si l'objet pass\u00e9 en argument est un objet Array reverse() permet d'inverser l'ordre des \u00e9l\u00e9ments du tableau. La m\u00e9thode modifie le tableau courant et renvoie une r\u00e9f\u00e9rence \u00e0 ce tableau sort() trie les \u00e9l\u00e9ments d'un tableau, dans ce m\u00eame tableau, et renvoie le tableau splice() modifie le contenu d'un tableau en retirant des \u00e9l\u00e9ments et/ou en ajoutant de nouveaux \u00e9l\u00e9ments const mesPoissons = [\"scalaire\", \"clown\", \"mandarin\", \"chirurgien\"] // supprime 0 \u00e9l\u00e9ment \u00e0 partir de l'index 2, et ins\u00e8re \"tambour\" enleves = mesPoissons.splice(2, 0, \"tambour\") // mesPoissons est [\"scalaire\", \"clown\", \"tambour\", \"mandarin\", \"chirurgien\"] // enleves est [], aucun \u00e9l\u00e9ment supprim\u00e9 // supprime 1 \u00e9l\u00e9ment \u00e0 partir de l'index 3 enleves = mesPoissons.splice(3, 1) // mesPoissons est [\"scalaire\", \"clown\", \"tambour\", \"chirurgien\"] // enleves est [\"mandarin\"] // supprime 1 \u00e9l\u00e9ment \u00e0 partir de l'index 2, et ins\u00e8re \"trompette\" enleves = mesPoissons.splice(2, 1, \"trompette\") // mesPoissons est [\"scalaire\", \"clown\", \"trompette\", \"chirurgien\"] // enleves est [\"tambour\"] concat(array2) est utilis\u00e9e afin de fusionner un ou plusieurs tableaux en les concat\u00e9nant. Cette m\u00e9thode ne modifie pas les tableaux existants, elle renvoie un nouveau tableau qui est le r\u00e9sultat de l'op\u00e9ration includes(\u00e9l\u00e9mentRecherch\u00e9) permet de d\u00e9terminer si un tableau contient un \u00e9l\u00e9ment et renvoie true si c'est le cas, false sinon indexOf(\u00e9l\u00e9mentRecherch\u00e9) renvoie le premier indice pour lequel on trouve un \u00e9l\u00e9ment donn\u00e9 dans un tableau. Si l'\u00e9l\u00e9ment cherch\u00e9 n'est pas pr\u00e9sent dans le tableau, la m\u00e9thode renverra -1 var beasts = ['ant', 'bison', 'camel', 'duck', 'bison']; console.log(beasts.indexOf('bison')); // expected output: 1 console.log(beasts.indexOf('bison', 2)); // start from index 2, expected output: 4 console.log(beasts.indexOf('giraffe')); // expected output: -1 join(s\u00e9parateur) r\u00e9unit tous les \u00e9l\u00e9ments d'un tableau dans une chaine de caract\u00e8res et renvoie cette nouvelle cha\u00eene de caract\u00e8res lastIndexOf(\u00e9l\u00e9mentRecherch\u00e9) permet de renvoyer le dernier indice pour lequel une valeur donn\u00e9e est pr\u00e9sente dans un tableau. Si la valeur recherch\u00e9e n'est pas pr\u00e9sente, le r\u00e9sultat sera -1 slice() renvoie un objet tableau contenant une copie d'une portion du tableau d'origine. La portion est d\u00e9finie par un indice de d\u00e9but et un indice de fin exclu optionnel var animals = ['ant', 'bison', 'camel', 'duck', 'elephant']; console.log(animals.slice()); // expected output: Array ['ant', 'bison', 'camel', 'duck', 'elephant'] console.log(animals.slice(2)); // expected output: Array ['camel', 'duck', 'elephant'] console.log(animals.slice(2, 4)); // expected output: Array ['camel', 'duck'] toString() renvoie une chaine de caract\u00e8res repr\u00e9sentant le tableau sp\u00e9cifi\u00e9 et ses \u00e9l\u00e9ments const mesPoissons = [\"scalaire\", \"clown\", \"mandarin\", \"chirurgien\"] console.log(mesPoissons.toString()) // scalaire,clown,mandarin,chirurgien Les m\u00e9thodes d'it\u00e9ration La m\u00e9thode every() permet de tester si tous les \u00e9l\u00e9ments d'un tableau v\u00e9rifient une condition donn\u00e9e par une fonction en argument : function isBelowThreshold(currentValue) { return currentValue < 40; } var array1 = [1, 30, 39, 29, 10, 13]; console.log(array1.every(isBelowThreshold)); // expected output: true La m\u00e9thode forEach() permet d'ex\u00e9cuter une fonction donn\u00e9e sur chaque \u00e9l\u00e9ment du tableau. La m\u00e9thode map() cr\u00e9e un nouveau tableau avec les r\u00e9sultats de l'appel d'une fonction fournie sur chaque \u00e9l\u00e9ment du tableau appelant. La m\u00e9thode filter() cr\u00e9e et retourne un nouveau tableau contenant tous les \u00e9l\u00e9ments du tableau d'origine qui remplissent une condition d\u00e9termin\u00e9e par la fonction callback. const myArray = [1, 2, 3, 4, 5] myArray.forEach((element, index, array) => { console.log(element+\" \"+index+\" \"+array) }) // a 0 a,b,c,d,e // b 1 a,b,c,d,e ... const myArray2 = myArray.map(element => { return element * 2 }) console.log(myArray2) // [2, 4, 6, 8, 10] const myArray3 = myArray.filter(element => { return element >= 3 }) console.log(myArray3) // [3, 4, 5] La m\u00e9thode every() permet de tester si tous les \u00e9l\u00e9ments d'un tableau v\u00e9rifient une condition donn\u00e9e par une fonction en argument. function isBelowThreshold(currentValue) { return currentValue < 40; } var array1 = [1, 30, 39, 29, 10, 13]; console.log(array1.every(isBelowThreshold)); // expected output: true La m\u00e9thode some() teste si au moins un \u00e9l\u00e9ment du tableau passe le test impl\u00e9ment\u00e9 par la fonction fournie. var array = [1, 2, 3, 4, 5]; var even = function(element) { // checks whether an element is even return element % 2 === 0; }; console.log(array.some(even)); // expected output: true La m\u00e9thode reduce() applique une fonction qui est un \u00ab accumulateur \u00bb et qui traite chaque valeur d'une liste (de la gauche vers la droite) afin de la r\u00e9duire \u00e0 une seule valeur. const array1 = [1, 2, 3, 4]; const reducer = (accumulator, currentValue) => accumulator + currentValue; // 1 + 2 + 3 + 4 console.log(array1.reduce(reducer)); // expected output: 10 Parcourir un tableau avec une boucle for : const fruits = [\"Pomme\", \"Melon\", \"Fraise\"] for(let fruit of fruits){ console.log(fruit) } // affiche Pomme, puis Melon, puis Fraise La m\u00e9thode from() permet de cr\u00e9er une nouvelle instance d'Array \u00e0 partir d'un objet it\u00e9rable ou semblable \u00e0 un tableau const paragraphes = document.querySelectorAll(\"p\") // r\u00e9cup\u00e8re tous les paragraphes // paragraphes est une NodeList, qui ressemble \u00e0 un tableau // on ne peut pas appliquer toutes les m\u00e9thodes d'un tableau dessus // on peut le convertir en vrai tableau pour le manipuler comme un tableau const paragraphesArray = Array.from(paragraphes) L'Objet JSON L\u2019objet JSON contient des m\u00e9thodes pour interpr\u00e9ter du JSON (JavaScript Object Notation) et convertir des valeurs en JSON. La m\u00e9thode JSON.parse() parse une cha\u00eene de caract\u00e8res JSON et construit la valeur JavaScript ou l'objet d\u00e9crit par cette cha\u00eene. La m\u00e9thode JSON.stringify() convertit une valeur JavaScript en cha\u00eene JSON. var json = '{\"result\":true, \"count\":42}' obj = JSON.parse(json) console.log(obj.count) // expected output: 42 console.log(JSON.stringify({ x: 5, y: 6 })) // expected output: \"{\"x\":5,\"y\":6}\"","title":"Fonctions utiles"},{"location":"objetsEtFonctionsUtilesJavascript/#objets-et-fonctions-utiles-javascript","text":"","title":"Objets et fonctions utiles Javascript"},{"location":"objetsEtFonctionsUtilesJavascript/#lobjet-math","text":"L'objet Math est un objet natif dont les m\u00e9thodes et propri\u00e9t\u00e9s permettent l'utilisation de constantes et fonctions math\u00e9matiques. Contrairement aux autres objets globaux, Math n'est pas un constructeur. Toutes les propri\u00e9t\u00e9s et les m\u00e9thodes de Math sont statiques. Exemples de propri\u00e9t\u00e9s Math.E // nombre d'Euler, environ 2.718 Math.PI // nombre PI, environ 3.1416 Exemples de m\u00e9thodes Math.abs(x) // retourne la valeur absolue d'un nombre Math.cos(x) // retourne le cosinus d'un nombre Math.sin(x) // retourne le sinus d'un nombre Math.exp(x) // retourne l'exponentielle d'un nombre Math.log(x) // retourne le logarithme naturel (log e) d'un nombre Math.sqrt(x) // retourne la racine carr\u00e9e d'un nombre Math.pow(x,y) // retourne le calcul de x \u00e0 la puissance y Math.max(x,y,...) // retourne la plus grande valeur d'une liste de nombres, par exemple Math.max(0,-5,3,2) retourne 3 Math.min(x,y,...) // retourne la plus petite valeur d'une liste de nombres, par exemple Math.min(0,-5,3,2) retourne -5 Math.random() // retourne un nombre pseudo-al\u00e9atoire compris entre 0 (inclus) et 1 (exclu) Math.floor(x) // retourne le plus grand entier inf\u00e9rieur ou \u00e9gal \u00e0 la valeur pass\u00e9e en param\u00e8tre Math.ceil(x) // retourne le plus petit entier sup\u00e9rieur ou \u00e9gal \u00e0 la valeur pass\u00e9e en param\u00e8tre Math.round(x) // retourne l'arrondi \u00e0 l'unit\u00e9 d'un nombre Math.trunc(x) // retourne la partie enti\u00e8re d'un nombre (diff\u00e9rent de floor() pour les nombres n\u00e9gatifs) Pour arrondir \u00e0 2 chiffres apr\u00e8s la virgule, on peut faire Math.round(x * 100) / 100 . Exemple console.log(Math.round(123.45678 * 100) / 100) // affiche 123.46 Pour g\u00e9n\u00e9rer un nombre al\u00e9atoire entre 1 et 100, on peut faire : const myNumber = Math.trunc(Math.random() * 100) + 1 console.log(myNumber)","title":"L'Objet Math"},{"location":"objetsEtFonctionsUtilesJavascript/#lobjet-date","text":"Ce constructeur permet de cr\u00e9er des instances Date qui repr\u00e9sentent un moment pr\u00e9cis dans le temps. Les objets Date se basent sur une valeur de temps qui est le nombre de millisecondes depuis 1er janvier 1970 minuit UTC. Sans argument, le constructeur cr\u00e9e un objet Date pour la date du jour et l'heure selon l'heure locale du syst\u00e8me const date = new Date() console.log(date) // affiche : Thu Sep 06 2018 10:17:13 GMT+0200 (heure d\u2019\u00e9t\u00e9 d\u2019Europe centrale) const date2 = Date.now() // retourne la valeur num\u00e9rique correspondant au temps courant. Le nombre de millisecondes depuis le 1 janvier 1970, 00:00:00 UTC console.log(date2) // 1536222742607 On peut aussi cr\u00e9er une date avec des arguments, par exemple le 28 mars 2018 (attention, l'indice des mois commence \u00e0 0) : const date = new Date(2018,2,28) console.log(date) // affiche : Wed Mar 28 2018 00:00:00 GMT+0200 (heure d\u2019\u00e9t\u00e9 d\u2019Europe centrale) const date = new Date('2018/3/28') // \u00e9auivalent en passant une String en param\u00e8tre On peut r\u00e9cup\u00e8re des param\u00e8tres d'une date (mois, jour, heure...). Exemple : const date = new Date() console.log(date) // Thu Sep 06 2018 10:43:30 GMT+0200 (heure d\u2019\u00e9t\u00e9 d\u2019Europe centrale) console.log(date.getDate()) // 6 console.log(date.getDay()) // 4 console.log(date.getMonth()) // 8 console.log(date.getFullYear()) // 2018 console.log(date.getHours()) // 10 console.log(date.getTime()) // 1536223410659 (correspond au nombre de millisecondes depuis le 1er janvier 1970) Calculer le temps \u00e9coul\u00e9 function traitementQuiPrendBeaucoupDeTemps(){ let j = 0 for(let i =0 ; i < 1000000 ; i++){ j++ } return j } // en utilisant les objets Date const debut = Date.now() // l'\u00e9v\u00e8nement \u00e0 mesurer se trouve ici : traitementQuiPrendBeaucoupDeTemps() const fin = Date.now() const tempsEcoule = fin - debut // temps \u00e9coul\u00e9 en millisecondes console.log(tempsEcoule) // affiche 15 // en utilisant les m\u00e9thodes natives const debut2 = new Date() // l'\u00e9v\u00e8nement \u00e0 mesurer se trouve ici : traitementQuiPrendBeaucoupDeTemps() const fin2 = new Date() const tempsEcoule2 = fin2.getTime() - debut2.getTime() // temps \u00e9coul\u00e9 en millisecondes console.log(tempsEcoule2) // affiche 10","title":"L'objet Date"},{"location":"objetsEtFonctionsUtilesJavascript/#expressions-regulieres","text":"Les expressions r\u00e9guli\u00e8res sont des motifs utilis\u00e9s pour correspondre \u00e0 certaines combinaisons de caract\u00e8res au sein de cha\u00eenes de caract\u00e8res. En JavaScript, les expressions r\u00e9guli\u00e8res sont \u00e9galement des objets. Ces motifs sont utilis\u00e9s avec les m\u00e9thodes exec et test de la classe RegExp , et avec les m\u00e9thodes match , replace , search et split de String . Il est possible de construire une expression r\u00e9guli\u00e8re de deux fa\u00e7ons : const re1 = /ab+c/ // avec un litt\u00e9ral d'expression r\u00e9guli\u00e8re, compil\u00e9 lors du chargement du script. Plus performant si l'expression reste constante const re2 = new RegExp(\"ab+c\") // avec le constructeur de l'objet RegExp, compil\u00e9 lors de l'ex\u00e9cution console.log(re1) // affiche /ab+c/ console.log(re2) // affiche /ab+c/ Exemples d'utilisation des m\u00e9thodes : const monTemplate = /ab/ console.log(monTemplate) // affiche /ab/ // m\u00e9thodes de RegExp // ex\u00e9cute une recherche de correspondance dans une cha\u00eene de caract\u00e8res. Elle renvoie un tableau d'informations ou null lorsqu'il n'y a pas de correspondance console.log(monTemplate.exec(\"abc\")) // affiche un tableau avec l'index \u00e0 l'endroit ou commence le template dans la cha\u00eene console.log(monTemplate.exec(\"qsd\")) // affiche null // teste la pr\u00e9sence d'une correspondance dans une cha\u00eene de caract\u00e8res. Elle renvoie true ou false console.log(monTemplate.test(\"abc\")) // true console.log(monTemplate.test(\"qsd\")) // false // m\u00e9thodes de String // ex\u00e9cute une recherche de correspondance dans une cha\u00eene de caract\u00e8res. Elle renvoie un tableau d'informations ou null lorsqu'il n'y a pas de correspondance console.log(\"abc\".match(monTemplate)) // affiche un tableau comme la m\u00e9thode exec() console.log(\"qsd\".match(monTemplate)) // affiche null // teste la pr\u00e9sence d'une correspondance dans une cha\u00eene de correspondance. Elle renvoie la position de la correspondance ou -1 s'il n'y en a pas console.log(\"abc\".search(monTemplate)) // affiche 0 console.log(\"qsd\".search(monTemplate)) // affiche -1 // recherche une correspondance dans une cha\u00eene de caract\u00e8res et qui remplace la correspondance par une cha\u00eene de substitution console.log(\"abc\".replace(monTemplate, \"ZZZ\")) // affiche ZZZc // utilise une expression r\u00e9guli\u00e8re ou une cha\u00eene de caract\u00e8res pour d\u00e9couper une cha\u00eene de caract\u00e8res en un tableau comprenant les fragments r\u00e9sultants console.log(\"Bonjourabjeabm'appelleabGa\u00ebtan\".split(monTemplate)) // affiche [\"Bonjour\", \"je\", \"m'appelle\", \"Ga\u00ebtan\"] Le motif d'une expression r\u00e9guli\u00e8re est compos\u00e9 de motifs simples comme /abc/ ou de caract\u00e8res sp\u00e9ciaux comme /ab*c/ . Les motifs simples doivent avoir une correspondance directe, on doit observer exactement les caract\u00e8res 'des' ensemble et dans cet ordre pr\u00e9cis. Lorsque le motif \u00e0 trouver est plus complexe qu'une simple \u00e9galit\u00e9, le motif devra contenir des caract\u00e8res sp\u00e9ciaux. (voir la documentation en ligne pour plus de d\u00e9tail). Les expressions r\u00e9guli\u00e8res sont souvent utilis\u00e9s dans les formulaires pour v\u00e9rifier la validit\u00e9 des donn\u00e9es saisies par l'utilisateur.","title":"Expressions R\u00e9guli\u00e8res"},{"location":"objetsEtFonctionsUtilesJavascript/#settimeout-et-setinterval","text":"Ce sont 2 m\u00e9thodes de l'objet global window . On s'en sert beaucoup dans les animations. La m\u00e9thode setTimeout() permet de d\u00e9finir un \u00ab minuteur \u00bb (timer) qui ex\u00e9cute une fonction ou un code donn\u00e9 apr\u00e8s la fin du d\u00e9lai indiqu\u00e9. Le d\u00e9lai est exprim\u00e9e en millisecondes. function hello(){ console.log(\"hello\") } setTimeout(hello, 2000) // ex\u00e9cute 1 fois hello() au bout de 2 secondes La valeur renvoy\u00e9e par la fonction est un entier qui repr\u00e9sente un identifiant du minuteur cr\u00e9\u00e9 par l'appel \u00e0 setTimeout(). Cet identifiant pourra \u00eatre pass\u00e9 \u00e0 la m\u00e9thode clearTimeout() afin d'annuler ce minuteur donn\u00e9, par exemple avec un bouton. Il est possible d'ex\u00e9cuter plusieurs fois une fonction avec setTimeout() : function hello(){ console.log(\"hello\") setTimeout(hello, 2000) } hello() // la m\u00e9thode s'ex\u00e9cute une premi\u00e8re fois imm\u00e9diatement puis toutes les 2 secondes La m\u00e9thode setInterval() appelle une fonction de mani\u00e8re r\u00e9p\u00e9t\u00e9e, avec un certain d\u00e9lai fix\u00e9 entre chaque appel setInterval(hello, 2000) // ex\u00e9cute hello() toutes de 2 secondes au bout de 2 secondes la premi\u00e8re fois On peut arr\u00eater la m\u00e9thode setInterval() avec la m\u00e9thode clearInterval() . Il faut stocker l'interval dans une variable pour r\u00e9cup\u00e9rer l'intervalID. Dans l'exemple ci-dessous, hello() s'ex\u00e9cute 3 fois. function hello(){ console.log(\"hello\") } const monInterval = setInterval(hello, 2000) setTimeout(function(){ clearInterval(monInterval) }, 6000)","title":"setTimeout et setInterval"},{"location":"objetsEtFonctionsUtilesJavascript/#fonctions-de-string","text":"L'objet global String est un constructeur de cha\u00eenes de caract\u00e8res. Les objets String sont cr\u00e9\u00e9s en appelant le constructeur new String() . La fonction globale String() peut \u00e9galement \u00eatre appel\u00e9e sans l'op\u00e9rateur new pour cr\u00e9er une cha\u00eene primitive. Les objets String peuvent \u00eatre convertis en cha\u00eenes primitives \u00e0 l'aide de String.valueOf() : // cr\u00e9ation d'une cha\u00eene primitve const chainePrimitive = \"toto\"; // cr\u00e9ation d'un objet String const objetString = new String(chainePrimitive); console.log(typeof chainePrimitive); // affiche \"string\" console.log(typeof objetString); // affiche \"object\" console.log(typeof objetString.valueOf()); // affiche \"string\" \u00c9tant donn\u00e9 que JavaScript effectue automatiquement les conversions entre cha\u00eenes primitives et objets String, toute m\u00e9thode de l'objet String peut \u00eatre appel\u00e9e sur une cha\u00eene primitive. La propri\u00e9t\u00e9 length retourne la longueur de la cha\u00eene. Quelques m\u00e9thodes utiles : charAt(index) renvoie une nouvelle cha\u00eene contenant le caract\u00e8re \u00e0 la position indiqu\u00e9e en argument concat(string2,...stringN) combine le texte de plusieurs cha\u00eenes avec la cha\u00eene appelante et renvoie la nouvelle cha\u00eene ainsi form\u00e9e endsWith(cha\u00eeneRecherch\u00e9e) renvoie un bool\u00e9en indiquant si la chaine de caract\u00e8res se termine par la chaine de caract\u00e8res fournie en argument indexOf(valeurRecherch\u00e9e) renvoie l'indice de la premi\u00e8re occurence de la valeur cherch\u00e9e au sein de la cha\u00eene courante. Elle renvoie -1 si la valeur cherch\u00e9e n'est pas trouv\u00e9e lastIndexOf(valeurRecherch\u00e9e) envoie l'indice, dans la cha\u00eene courante, de la derni\u00e8re occurence de la valeur donn\u00e9e en argument. Si cette sous-cha\u00eene n'est pas trouv\u00e9e, la m\u00e9thode renvoie -1 replace() rechercher une correspondance entre une expression r\u00e9guli\u00e8re et une cha\u00eene, et remplace la sous-cha\u00eene correspondante par une nouvelle cha\u00eene search(regexp) renvoie l'indice de la premi\u00e8re correspondance pour l'expression r\u00e9guli\u00e8re au sein de la chaine de caract\u00e8res, sinon, la m\u00e9thode renvoie -1 slice(indiceDebut[, indiceFin]) extrait une section d'une chaine de caract\u00e8res et la retourne comme une nouvelle chaine de caract\u00e8res split(s\u00e9parateur) permet de diviser une cha\u00eene de caract\u00e8res \u00e0 partir d'un s\u00e9parateur pour fournir un tableau de sous-cha\u00eenes startsWith(cha\u00eeneRecherch\u00e9e) renvoie un bool\u00e9en indiquant si la chaine de caract\u00e8res commence par la deuxi\u00e8me chaine de caract\u00e8res fournie en argument substring(indiceA[, indiceB]) retourne une sous-cha\u00eene de la cha\u00eene courante, entre un indice de d\u00e9but et un indice de fin toLowerCase() retourne la cha\u00eene de caract\u00e8res courante en minuscules toString() renvoie une chaine de caract\u00e8res repr\u00e9sentant l'objet renseign\u00e9 toUpperCase() retourne la valeur de la cha\u00eene courante, convertie en majuscules trim() permet de retirer les blancs en d\u00e9but et fin de cha\u00eene valueOf() renvoie la valeur primitive de l'objet String Exemples : console.log(gaetan.length) // affiche 6 console.log(gaetan.charAt(1)) // affiche a console.log(gaetan[1]) // affiche a console.log(gaetan.concat(\" et Louis\")) // affiche Ga\u00ebtan et Louis console.log(gaetan.substring(1,3)) // affiche a\u00eb","title":"Fonctions de String"},{"location":"objetsEtFonctionsUtilesJavascript/#fonctions-de-array","text":"L'objet global Array est utilis\u00e9 pour cr\u00e9er des tableaux. On peut cr\u00e9er un tableau avec le constructeur Array, et aussi la syntaxe crochets. La propri\u00e9t\u00e9 length retourne la longueur de la cha\u00eene. Un tableau contient plusieurs valeurs appel\u00e9es item . Chaque item est accessible au moyen d\u2019un indice dont la num\u00e9rotation commence \u00e0 0. On acc\u00e9de \u00e0 un \u00e9l\u00e9ment d'un tableau en indiquant son indice entre crochets et on peut modifier la valeur d'un \u00e9l\u00e9m\u00e9net de cette mani\u00e8re. const myArray = [1, 2, 3, 4, 5] const myArray2 = new Array(1, 2, 3, 4, 5) console.log(myArray.length) // affiche 5 console.log(myArray[0]) // affiche 1, le premier \u00e9l\u00e9ment du tableau myArray[0]=8 // modifie la valeur du premier \u00e9l\u00e9ment du tableau console.log(myArray[0]) // affiche 8, le premier \u00e9l\u00e9ment du tableau console.log(myArray[myArray.length-1]) // affiche 5, le dernier \u00e9l\u00e9ment du tableau const myArray = [1, 2, 3, 4, 5] myArray.push(6) // ajoute l'\u00e9l\u00e9ment en param\u00e8tre \u00e0 la fin du tableau myArray.pop() // enl\u00e8ve le dernier \u00e9l\u00e9ment du tableau et le retourne myArray.shift() // enl\u00e8ve le premier \u00e9l\u00e9ment du tableau et le retourne myArray.unshift(0) // ajoute l'\u00e9l\u00e9ment en param\u00e8tre au d\u00e9but du tableau console.log(myArray) isArray() permet de d\u00e9terminer si l'objet pass\u00e9 en argument est un objet Array reverse() permet d'inverser l'ordre des \u00e9l\u00e9ments du tableau. La m\u00e9thode modifie le tableau courant et renvoie une r\u00e9f\u00e9rence \u00e0 ce tableau sort() trie les \u00e9l\u00e9ments d'un tableau, dans ce m\u00eame tableau, et renvoie le tableau splice() modifie le contenu d'un tableau en retirant des \u00e9l\u00e9ments et/ou en ajoutant de nouveaux \u00e9l\u00e9ments const mesPoissons = [\"scalaire\", \"clown\", \"mandarin\", \"chirurgien\"] // supprime 0 \u00e9l\u00e9ment \u00e0 partir de l'index 2, et ins\u00e8re \"tambour\" enleves = mesPoissons.splice(2, 0, \"tambour\") // mesPoissons est [\"scalaire\", \"clown\", \"tambour\", \"mandarin\", \"chirurgien\"] // enleves est [], aucun \u00e9l\u00e9ment supprim\u00e9 // supprime 1 \u00e9l\u00e9ment \u00e0 partir de l'index 3 enleves = mesPoissons.splice(3, 1) // mesPoissons est [\"scalaire\", \"clown\", \"tambour\", \"chirurgien\"] // enleves est [\"mandarin\"] // supprime 1 \u00e9l\u00e9ment \u00e0 partir de l'index 2, et ins\u00e8re \"trompette\" enleves = mesPoissons.splice(2, 1, \"trompette\") // mesPoissons est [\"scalaire\", \"clown\", \"trompette\", \"chirurgien\"] // enleves est [\"tambour\"] concat(array2) est utilis\u00e9e afin de fusionner un ou plusieurs tableaux en les concat\u00e9nant. Cette m\u00e9thode ne modifie pas les tableaux existants, elle renvoie un nouveau tableau qui est le r\u00e9sultat de l'op\u00e9ration includes(\u00e9l\u00e9mentRecherch\u00e9) permet de d\u00e9terminer si un tableau contient un \u00e9l\u00e9ment et renvoie true si c'est le cas, false sinon indexOf(\u00e9l\u00e9mentRecherch\u00e9) renvoie le premier indice pour lequel on trouve un \u00e9l\u00e9ment donn\u00e9 dans un tableau. Si l'\u00e9l\u00e9ment cherch\u00e9 n'est pas pr\u00e9sent dans le tableau, la m\u00e9thode renverra -1 var beasts = ['ant', 'bison', 'camel', 'duck', 'bison']; console.log(beasts.indexOf('bison')); // expected output: 1 console.log(beasts.indexOf('bison', 2)); // start from index 2, expected output: 4 console.log(beasts.indexOf('giraffe')); // expected output: -1 join(s\u00e9parateur) r\u00e9unit tous les \u00e9l\u00e9ments d'un tableau dans une chaine de caract\u00e8res et renvoie cette nouvelle cha\u00eene de caract\u00e8res lastIndexOf(\u00e9l\u00e9mentRecherch\u00e9) permet de renvoyer le dernier indice pour lequel une valeur donn\u00e9e est pr\u00e9sente dans un tableau. Si la valeur recherch\u00e9e n'est pas pr\u00e9sente, le r\u00e9sultat sera -1 slice() renvoie un objet tableau contenant une copie d'une portion du tableau d'origine. La portion est d\u00e9finie par un indice de d\u00e9but et un indice de fin exclu optionnel var animals = ['ant', 'bison', 'camel', 'duck', 'elephant']; console.log(animals.slice()); // expected output: Array ['ant', 'bison', 'camel', 'duck', 'elephant'] console.log(animals.slice(2)); // expected output: Array ['camel', 'duck', 'elephant'] console.log(animals.slice(2, 4)); // expected output: Array ['camel', 'duck'] toString() renvoie une chaine de caract\u00e8res repr\u00e9sentant le tableau sp\u00e9cifi\u00e9 et ses \u00e9l\u00e9ments const mesPoissons = [\"scalaire\", \"clown\", \"mandarin\", \"chirurgien\"] console.log(mesPoissons.toString()) // scalaire,clown,mandarin,chirurgien Les m\u00e9thodes d'it\u00e9ration La m\u00e9thode every() permet de tester si tous les \u00e9l\u00e9ments d'un tableau v\u00e9rifient une condition donn\u00e9e par une fonction en argument : function isBelowThreshold(currentValue) { return currentValue < 40; } var array1 = [1, 30, 39, 29, 10, 13]; console.log(array1.every(isBelowThreshold)); // expected output: true La m\u00e9thode forEach() permet d'ex\u00e9cuter une fonction donn\u00e9e sur chaque \u00e9l\u00e9ment du tableau. La m\u00e9thode map() cr\u00e9e un nouveau tableau avec les r\u00e9sultats de l'appel d'une fonction fournie sur chaque \u00e9l\u00e9ment du tableau appelant. La m\u00e9thode filter() cr\u00e9e et retourne un nouveau tableau contenant tous les \u00e9l\u00e9ments du tableau d'origine qui remplissent une condition d\u00e9termin\u00e9e par la fonction callback. const myArray = [1, 2, 3, 4, 5] myArray.forEach((element, index, array) => { console.log(element+\" \"+index+\" \"+array) }) // a 0 a,b,c,d,e // b 1 a,b,c,d,e ... const myArray2 = myArray.map(element => { return element * 2 }) console.log(myArray2) // [2, 4, 6, 8, 10] const myArray3 = myArray.filter(element => { return element >= 3 }) console.log(myArray3) // [3, 4, 5] La m\u00e9thode every() permet de tester si tous les \u00e9l\u00e9ments d'un tableau v\u00e9rifient une condition donn\u00e9e par une fonction en argument. function isBelowThreshold(currentValue) { return currentValue < 40; } var array1 = [1, 30, 39, 29, 10, 13]; console.log(array1.every(isBelowThreshold)); // expected output: true La m\u00e9thode some() teste si au moins un \u00e9l\u00e9ment du tableau passe le test impl\u00e9ment\u00e9 par la fonction fournie. var array = [1, 2, 3, 4, 5]; var even = function(element) { // checks whether an element is even return element % 2 === 0; }; console.log(array.some(even)); // expected output: true La m\u00e9thode reduce() applique une fonction qui est un \u00ab accumulateur \u00bb et qui traite chaque valeur d'une liste (de la gauche vers la droite) afin de la r\u00e9duire \u00e0 une seule valeur. const array1 = [1, 2, 3, 4]; const reducer = (accumulator, currentValue) => accumulator + currentValue; // 1 + 2 + 3 + 4 console.log(array1.reduce(reducer)); // expected output: 10 Parcourir un tableau avec une boucle for : const fruits = [\"Pomme\", \"Melon\", \"Fraise\"] for(let fruit of fruits){ console.log(fruit) } // affiche Pomme, puis Melon, puis Fraise La m\u00e9thode from() permet de cr\u00e9er une nouvelle instance d'Array \u00e0 partir d'un objet it\u00e9rable ou semblable \u00e0 un tableau const paragraphes = document.querySelectorAll(\"p\") // r\u00e9cup\u00e8re tous les paragraphes // paragraphes est une NodeList, qui ressemble \u00e0 un tableau // on ne peut pas appliquer toutes les m\u00e9thodes d'un tableau dessus // on peut le convertir en vrai tableau pour le manipuler comme un tableau const paragraphesArray = Array.from(paragraphes)","title":"Fonctions de Array"},{"location":"objetsEtFonctionsUtilesJavascript/#lobjet-json","text":"L\u2019objet JSON contient des m\u00e9thodes pour interpr\u00e9ter du JSON (JavaScript Object Notation) et convertir des valeurs en JSON. La m\u00e9thode JSON.parse() parse une cha\u00eene de caract\u00e8res JSON et construit la valeur JavaScript ou l'objet d\u00e9crit par cette cha\u00eene. La m\u00e9thode JSON.stringify() convertit une valeur JavaScript en cha\u00eene JSON. var json = '{\"result\":true, \"count\":42}' obj = JSON.parse(json) console.log(obj.count) // expected output: 42 console.log(JSON.stringify({ x: 5, y: 6 })) // expected output: \"{\"x\":5,\"y\":6}\"","title":"L'Objet JSON"},{"location":"vraimentBienComprendreJavaScript/","text":"Vraiment bien comprendre JavaScript Les variables Les diff\u00e9rents types de variables console.log(true); console.log(typeof true) // boolean console.log(1); console.log(typeof 1) // number console.log(\"Louis\"); console.log(typeof \"Louis\") // string console.log({name: \"Louis\"}); console.log(typeof {name: \"Louis\"}) // object Diff\u00e9rence entre undefined , null et is not defined : undefined : variable d\u00e9clar\u00e9e mais n'a pas re\u00e7u de valeur null : variable d\u00e9finie par l'utilisateur is not defined : variable non d\u00e9clar\u00e9e var a; console.log(a) // undefined var b = null; console.log(b) // null console.log(c) // c is not defined Le hoisting (hissage) JavaScript passe le code en revue et recherche les d\u00e9clarations de fonction et les hisse dans le haut de code, ce qui fait qu'on peut ex\u00e9cuter une fonction avant de la d\u00e9clarer. addition(1,3) function addition(a,b){ console.log(a+b) } Cela fonctionne pour les d\u00e9clarations de fonction, mais pas pour les fonctions anonymes stock\u00e9es dans une variable comme l'exemple ci-dessous. Pour que cet exemple fonctionne, il faut appeler addition() apr\u00e8s sa d\u00e9claration. addition(1,3) var addition = function(a,b){ console.log(a+b) } JavaScript hisse \u00e9galement la d\u00e9claration des variables, sans l'assignation de la valeur. console.log(x) // undefined var x = 5 console.log(y) // y is not defined C'est comme-ci on avait fait : var x console.log(x) // undefined var x = 5 Les types primitifs vs les objets Les variables de type primitif sont copi\u00e9s par valeur, les variables de type objet sont copi\u00e9s par r\u00e9f\u00e9rence. var x = 5 // 5 est stock\u00e9 en m\u00e9moire dans la variable x var y = x // 5 est stock\u00e9 en m\u00e9moire dans la variable y y = 8 // 8 est stock\u00e9 en m\u00e9moire dans la variable y console.log(x) console.log(y) var a = {name: \"Louis\"} // un espace m\u00e9moire est cr\u00e9\u00e9 pour stocker l'objet `{name:\"Louis\"}` et l'adresse de cet espace m\u00e9moire est stock\u00e9e dans l'espace m\u00e9moire de la variable a. On dit que l'espace m\u00e9moire de a est un pointeur. console.log(a) // affiche {name: \"Louis\"} var b = a // un espace m\u00e9moire est cr\u00e9e pour b qui pointe vers le m\u00eame objet que a b.name = \"Ga\u00ebtan\" // comme a et b pointe vers le m\u00eame objet, la modification de b entra\u00eene donc la modification de a console.log(a) // affiche {name: \"Ga\u00ebtan\"} console.log(b) // affiche {name: \"Ga\u00ebtan\"} var a = {name: \"Louis\"} console.log(a) // affiche {name: \"Louis\"} var b = a b = {name: \"Ga\u00ebtan\"} // cr\u00e9e un nouvel objet qui est stock\u00e9 dans un nouvel espace m\u00e9moire. b ne pointe donc plus vers le m\u00eame objet que a console.log(a) // affiche {name: \"Louis\"} console.log(b) // affiche {name: \"Ga\u00ebtan\"} La d\u00e9claration des variables Avec l'ES6, en plus du mot cl\u00e9 var , on peut utiliser les mots-cl\u00e9s let et const . var a = 5 console.log(a) // 5 let b = 6 console.log(b) // 6 const c = 7 console.log(c) // 7 Une constante doit avoir une valeur d\u00e8s sa d\u00e9claration et ne pas peut \u00eatre modifi\u00e9e. On ne peut pas faire : const a; // ERREUR const b = 1; b=2; // ERREUR On ne peut pas assigner un nouvel objet \u00e0 une variable const mais on peut modifier les propri\u00e9t\u00e9s d'un objet const a = {name: \"Louis\"} a.name = \"Ga\u00ebtan\" console.log(a) // {name: \"Ga\u00ebtan\"} const b = {name: \"Louis\"} b = {name: \"Ga\u00ebtan\"} // Erreur : on ne peut pas modifier la valeur d'une const Il n'y a pas de hissage avec const et let comme avec var console.log(a) // undefined var a = 5 console.log(b) // b is not defined let b = 5 Quand utiliser let , const et var ne plus utiliser le var toujours utiliser le const si on r\u00e9assigne une valeur \u00e0 la variable, utiliser le let Les scopes Contexte d'ex\u00e9cution Un contexte d'ex\u00e9cution est un contexte dans lequel un certain bout de code est ex\u00e9cut\u00e9. Cela concerne les infos sur les variables qu'il va d\u00e9finir, auquel il va pouvoir acc\u00e9der... A chaque fois qu'une fonction est ex\u00e9cut\u00e9e , un nouveau contexte d'ex\u00e9cution est cr\u00e9\u00e9. Pour le code qui n'est pas dans une fonction, il appartient au contexte d'ex\u00e9cution global. Un contexte d'ex\u00e9cution est compos\u00e9 de 3 choses : l'objet des variables : fonctions et variables qui sont d\u00e9finies dans ce bout de code la cha\u00eene des scopes : variables auquel peut acc\u00e9der ce bout de code le this : l'objet associ\u00e9 \u00e0 ce bout de code L'objet des variables L'objet des variables, ou Variable Objet (VO) , est cr\u00e9\u00e9 et initialis\u00e9 pendant la phase de cr\u00e9ation du contexte d'ex\u00e9cution. Il contient : les arguments de la fonction les d\u00e9clarations de fonctions avec le hoisting les d\u00e9clarations de variables avec le hoisting (les variables d\u00e9clar\u00e9es avec var ) La cha\u00eene des scopes Le scope veut dire port\u00e9e en fran\u00e7ais. Cela permet de savoir \u00e0 quel endroit du code il est possible d'acc\u00e9der \u00e0 quelle variable. Le code qui n'appartient \u00e0 aucune fonction appartient au scope global. A chaque fois qu'une fonction est ex\u00e9cut\u00e9e, un scope local est cr\u00e9\u00e9, on parle de scope de fonction . Pour les variables cr\u00e9\u00e9es avec let et const , un scope de bloc est cr\u00e9\u00e9 (cf ci-apr\u00e8s). Une r\u00e8gle de base sur les scopes est qu'une fonction enfant peut acc\u00e9der au scope de ses parents, c'est-\u00e0-dire \u00e0 son objet des variables ainsi qu'\u00e0 l'objet des variables de ses parents. Si on d\u00e9clare une variable dans une fonction alors qu'une variable avec le m\u00eame nom existe d\u00e9j\u00e0 dans un scope sup\u00e9rieur, une nouvelle variable est d\u00e9finie, dans un espace m\u00e9moire diff\u00e9rent, et c'est celle du scope local qui est utilis\u00e9e. Lorsqu'on cherche une variable, on cherche d'abord la variable dans le scope local et si elle n'existe pas, on remonte la cha\u00eene des scopes jusqu'\u00e0 trouver notre variable. Le scope de bloc (ES6) Chaque fonction cr\u00e9e un nouvdau scope. Jusqu'\u00e0 l'arriv\u00e9e d'ES6, il n'y avait que le scope de fonction. Lorsqu'on d\u00e9clare des variables avec let et const , les variables ne respectent pas les scopes de fonction mais les scopes de bloc. Un bloc est tout ce qui est entre accolades. Par exemple, le code suivant ne fonctionne pas alors que \u00e7a aurait fonctionn\u00e9 avec le mot cl\u00e9 var . if(true){ let a = 5; } console.log(a) // a is not defined L'exemple suivant fonctionne car la variable est d\u00e9finie dans le m\u00eame scope qu'on souhaite l'afficher let a if(true){ a = 5; } console.log(a) // affiche 5 Il faut \u00e9viter d'utiliser le mot cl\u00e9 var et privil\u00e9gier const et let pour \u00e9viter les mauvaises surprises. Par exemple : var i = 62 for(i = 0 ; i < 10 ; i++){ console.log(i) } console.log(i) // affiche 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 et 10 let i = 62 for(let i = 0 ; i < 10 ; i++){ console.log(i) } console.log(i) // affiche 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 et 62 Les fonctions Fonction Premi\u00e8re Classe Les fonctions sont des objets de premi\u00e8re classe, c'est-\u00e0-dire que ce sont des objets comme les autres. une fonction peut prendre une fonction en argument function addTwo(numberToAdd){ return numberToAdd + 2 } function myFunction(argFunction, number){ const x = argFunction(number) console.log(x) } myFunction(addTwo, 5) // affiche 7 une fonction peut retourner une autre fonction function myFunction(){ return function(number){ return number * 2 } } console.log(myFunction) // affiche la d\u00e9claration de myFonction console.log(myFunction()) // affiche la d\u00e9claration de la fonction anonyme : \u0192unction(number){return number * 2} console.log(myFunction()(3)) // affiche 6 on peut assigner une fonction \u00e0 une variable const returnedFunction = function(){ return 5+2 } console.log(returnedFunction()) // affiche 7 function myFunction(){ return 5+2 } const returnedFunction = myFunction() console.log(returnedFunction) // affiche 7 Les closures Une closure, est une fermeture. C'est une fonction qui a enferm\u00e9 avec elle des variables qui lui sont externes, provenant d'un scope parent. function multiplyBy(number){ const closedVariable = number return function(anotherNumber){ return closedVariable * anotherNumber } } const multiplyByFive = multiplyBy(5) const multiplyByThree = multiplyBy(3) console.log(multiplyByFive) // function(anotherNumber){return closedVariable * anotherNumber} console.log(multiplyByFive(2)) // 10 console.log(multiplyByThree(2)) // 6 Dans cet exemple, mutilyByFive utilise la variable closedVariable lors de son ex\u00e9cution avec le param\u00e8tre 2, alors que closedVariable fait parti du contexte d'ex\u00e9cution de multiplyBy(5) qui a disparu apr\u00e8s l'ex\u00e9cution de la fonction, donc closedVariable devrait avoir disparu, mais il est toujours disponible dans multiplyByFive, c'est ce qu'on appelle une closure car la fonction a captur\u00e9 une variable d'un scope parent. C'est la m\u00eame chose pour multiplyByThree. M\u00e9fiez-vous des scopes Il faut prot\u00e9ger ses variables pour \u00e9viter qu'elles soient \"pirat\u00e9es\" par un autre script. Exemple avec une page HTML qui charge 3 scripts : <!DOCTYPE html> <html> <head> <script src=\"script1.js\"></script> <script src=\"script2.js\"></script> <script src=\"script3.js\"></script> </head> // script1.js var myPassword = \"12345\" function setPassword(newPassword){ myPassword = newPassword } function getPassword(){ return myPassword } // script2.js var myPassword = \"000\" // script3.js console.log(getPassword()) // affiche 000 alors qu'on voulait 12345 Dans le script 3, on veut r\u00e9cup\u00e9rer myPassword de script 1 mais elle a \u00e9t\u00e9 \u00e9cras\u00e9 par myPassword du script 2 car les variables ont le m\u00eame nom et elles sont toutes les 2 dans le scope global. Il faut \u00e9viter au maximum de rattacher les variables au scope global. Il faut d\u00e9finir ce qu'on souhaite rendre priv\u00e9 (uniquement utilisable dans le script courant) et ce qu'on veut rendre public, c'est-\u00e0-dire rendre accessible aux autres scripts. Pour cela on va utiliser les IIFEs IIFEs Les fonctions imm\u00e9diatement ex\u00e9cut\u00e9es se nomment des Immediatly-Invoked Function Expression , abr\u00e9g\u00e9es IIFE. L'id\u00e9e est d\u00e9clarer la fonction et de l'ex\u00e9cuter en m\u00eame temps. En utilisant une IIFE, tout le code ex\u00e9cut\u00e9 dedans sera priv\u00e9 et non accessible de l'ext\u00e9rieur. // fonction classique function myFunction(){ // code de la fonction } // IIFE (function(){ // code de la fonction })() Pour revenir \u00e0 notre exemple pr\u00e9c\u00e9dent o\u00f9 l'on veut rendre public getPassword() et rendre priv\u00e9 myPassword et setPassword , on peut utiliser les IIFEs et les closures pour r\u00e9soudre ce probl\u00e8me. const getPassword = (function(){ var myPassword = \"12345\" function setPassword(newPassword){ myPassword = newPassword } return function(){ return myPassword } })() Cet exemple permet de rendre accessible la fonction getPassword uniquement de ce script. Cependant, cela permet uniquement d'exposer une variable ou une fonction. Il est possible de rendre public plusieurs \u00e9l\u00e9ments public en retournant un objet : const script1 = (function(){ var myPassword = \"12345\" function setPassword(newPassword){ myPassword = newPassword } function getPassword(){ return myPassword } return { getPassword: getPassword, setPassword: setPassword, } })() // appel dans le script 3 console.log(script1.getPassword()) Le mot cl\u00e9 THIS A chaque contexte d'ex\u00e9cution est associ\u00e9 un objet. this permet d'acc\u00e9der \u00e0 cet objet. console.log(this) // donne Window qui est l'objet global dans le navigateur. JavaScript ex\u00e9cut\u00e9 dans un autre environnement comme un serveur aurait donn\u00e9 un autre objet global. Le this est l'objet qui a ex\u00e9cut\u00e9 la m\u00e9thode, sinon ce sera l'objet global function first(){ console.log(this) } first() // Window const louis = { name: \"Louis\", present: first } louis.present() // {name: \"Louis\", present: \u0192} Choses bizarres Les d\u00e9clarations de variables avec var et les d\u00e9clarations de fonctions dans le contexte d'ex\u00e9cution global sont stock\u00e9es dans l'objet global Window. Ce n'est pas le cas pour les variables d\u00e9clar\u00e9es avec let et const . var a = 5 function allo(){ } console.log(this) // on retrouve a et allo() dans Window var myName = \"Louis\" console.log(window.myName === this.myName && window.myName === myName) // affiche true Si on oublie le mot cl\u00e9 var pour d\u00e9clarer une variable, elle est automatiquement rattach\u00e9 \u00e0 l'objet global, m\u00eame si elle est d\u00e9clar\u00e9e dans une fonction. function allo(){ b = 9 } allo() console.log(this) // on retrouve b dans l'objet Window Pour \u00e9viter cela, on peut utiliser le mode strict en ajoutant la commande 'use strict' en haut du fichier javascript et ce qui aura pour effet dans le script pr\u00e9c\u00e9dent de renvoyer une erreur en disant que b n'est pas d\u00e9fini. Bind, Call et Apply Ces m\u00e9thodes vont permettre de contr\u00f4ler la valeur du this . bind est une m\u00e9thode qui permet de changer la valeur du this en appliquant le this d'un autre objet. function first(){ console.log(this) } first() // affiche l'objet global Window const louis = { name: \"Louis\", present: function(){ console.log(this) } } const second = first.bind(louis) // fixe le this de louis sur la fonction second second() // affiche l'objet louis louis.present() // affiche l'objet louis louis.present.bind(window)() // affiche l'objet Window car on a chang\u00e9 la valeur de this en mettant Window \u00e0 la place de louis Voici quelques autres exemples var name = \"Louis\" function present(){ console.log(this.name) } const kev = { name: \"K\u00e9vin\", present: present } const thib = { name: \"Thibaut\", present: present.bind(this) } const presentKev = kev.present const presentKevBind = kev.present.bind(kev) const presentKevBind2 = kev.present.bind(this) present() // affiche Louis : comme ce n'est pas un objet qui ex\u00e9cute la fonction, c'est l'objet global Window qui l'ex\u00e9cute. Le this est donc associ\u00e9 \u00e0 Window, on cherche donc \u00e0 logguer un window.name et on a d\u00e9clar\u00e9 la variable name dans le scope global, qui est donc attach\u00e9 \u00e0 l'objet Window, donc window.name = \"John\" kev.present() // affiche K\u00e9vin : present est ex\u00e9cut\u00e9e en tant que m\u00e9thode de l'objet kev donc le this est kev presentKev() // affiche Louis : presentKev est \u00e9gale \u00e0 une m\u00e9thode d'un objet mais elle est ex\u00e9cut\u00e9e en tant que fonction et n'est pas associ\u00e9e \u00e0 un objet, le this est donc Window presentKevBind() // affiche K\u00e9vin : comme la m\u00e9thode pr\u00e9c\u00e9dente sauf que le this a \u00e9t\u00e9 bind\u00e9 avec l'objet kev presentKevBind2() // affiche Louis comme pour presentKev en bindant le this qui correspond \u00e0 Window, donc \u00e7a ne change rien de faire le bind dans ce cas thib.present() // affiche Louis : la m\u00e9thode present est bind\u00e9e avec this dans l'objet franck et le this correspond \u00e0 Window \u00e0 ce moment l\u00e0 bind permet aussi de fixer la valeur des arguments que va prendre la nouvelle fonction que l'on cr\u00e9e. function multiply(number1, number2){ return number1 * number2 } // on fixe la valeur du premier argument de multiply \u00e0 2. // multiplyByTwo prend donc un seul argument qui correspond au number2 de multiply const multiplyByTwo = multiply.bind(this, 2) console.log(multiplyByTwo(3)) // affiche 6 Les m\u00e9thodes call et apply ne cr\u00e9ent pas une nouvelle fonction qu'il faut ensuite ex\u00e9cuter comme bind , elles l'ex\u00e9cutent directement. function multiply(number1, number2){ console.log(this) console.log(number1 * number2) } const louis = { name: \"Louis\" } multiply.bind(louis, 2, 3)() // affiche louis et 6 // call ex\u00e9cute directement multiplly multiply.call(louis, 2, 3) // affiche Window et 6 comme bind // apply prend les arguments de la fonction dans un tableau multiply.apply(louis, [2, 3]) // affiche Window et 6 comme bind Les fonctions fl\u00e9ch\u00e9es (Arrow Functions) Les fonctions fl\u00e9ch\u00e9es ont 2 particularit\u00e9es : la syntaxe est plus rapide elles vont fixer la valeur du this automatiquement La syntaxe : const myFunction = arg => arg * 5 console.log(myFunction(3)) // affiche 15 const myFunction2 = () => 4 * 5 console.log(myFunction2()) // affiche 20 const myFunction3 = (nombre1, nombre2) => nombre1 * nombre2 console.log(myFunction3(3, 4)) // affiche 12 On peut utiliser des accolades si la fonction fait davantage que retourner une valeur, comme par exemple ex\u00e9cuter du code avant. const myFunction3 = (nombre1, nombre2) => { const nombreCalcule = nombre1 * nombre1 return nombreCalcule * nombre2 } console.log(myFunction3(3, 4)) // affiche 36 (3 * 3 * 4) Fonctionne aussi sur les objets louis = { name: \"Louis\", // syntaxe classique present: function(friend){ return \"Tu connais \"+friend+\" ?\" }, // nouvelle syntaxe presentArrow: friend => \"Tu connais \"+friend+\" ?\" } console.log(louis.present(\"K\u00e9vin\")) console.log(louis.presentArrow(\"Thibaut\")) Les fonctions fl\u00e9ch\u00e9es fixent la valeur du this automatiquement. Dans l'exemple ci-dessous, le this de presentClassic est l'objet louis car c'est l'objet louis qui a ex\u00e9cut\u00e9 la m\u00e9thode. Pour presentArrow , son this est Windows. Une fonction fl\u00e9ch\u00e9e capture le this du scope parent o\u00f9 elle a \u00e9tait d\u00e9clar\u00e9e. Il faut donc regarder \u00e0 quoi correspond le this de l'endroit o\u00f9 elle a \u00e9t\u00e9 d\u00e9clar\u00e9e. Cela revient au m\u00eame que l'ex\u00e9cution d'une fonction classique o\u00f9 on aurait bind\u00e9 le this. function classicFunction(){ console.log(this) } const classicFunctionBind = classicFunction.bind(this) const arrowFunction = () => { console.log(this) } const louis = { name: \"Louis\", presentClassic: classicFunction, presentClassicBind: classicFunctionBind, presentArrow: arrowFunction, } louis.presentClassic() // affiche louis louis.presentClassicBind() // affiche Window louis.presentArrow() // affiche Window Les objets Fonction constructeur Une fonction constructeur est un moule. En ex\u00e9cutant cette fonction, on cr\u00e9e des instances bas\u00e9es sur ce moule. function Person(name, age){ this.name = name this.age = age this.present = () => {console.log(\"Hello my name is \"+this.name)} } let louis = new Person(\"Louis\", 0) let thibaut = new Person(\"Thibaut\", 23) louis.present() // Hello my name is Louis thibaut.present() // Hello my name is Thibaut console.log(louis) // affiche l'objet louis console.log(thibaut) // affiche l'objet thibaut console.log(louis.present === thibaut.present) // affiche false present de louis et present de thibaut sont 2 m\u00e9thodes diff\u00e9rentes qui font la m\u00eame chose, donc elles sont stock\u00e9es deux fois en m\u00e9moire alors qu'on aurait pu les stocker qu'une fois. On va pouvoir faire cela avec les prototypes. Les prototypes On va stocker la fonction dans le prototype de Person, comme \u00e7a elle sera unique. Il faut utiliser une fonction classique au lieu d'une fonction fl\u00e9ch\u00e9e, car une fonction fl\u00e9ch\u00e9e capturerait le this de l'endroit o\u00f9 elle est d\u00e9clar\u00e9e, c'est-\u00e0-dire l'objet global. function Person(name, age){ this.name = name this.age = age //this.present = () => {console.log(\"Hello my name is \"+this.name)} } Person.prototype.present = function(){ console.log(\"Hello my name is \"+this.name) } let louis = new Person(\"Louis\", 0) let thibaut = new Person(\"Thibaut\", 23) louis.present() // Hello my name is Louis console.log(louis.present === thibaut.present) // affiche true Dans l'exemple pr\u00e9c\u00e9dent sans utiliser les prototypes, si on regarde ce que contient l'objet Person , il y a les attributs name et age , la fonction present , et l'objet __proto__ , qui contient lui-m\u00eame le constructeur de Person . En d\u00e9clarant la fonction dans le prototype, la fonction present n'est plus dans l'objet Person mais dans l'objet __proto__ . __proto__ correspond au prototype de la personne et il est accessible \u00e0 toutes les instances cr\u00e9\u00e9es avec la fonction constructeur Person . console.log(louis.__proto__ === Person.prototype) // affiche true console.log(louis.__proto__ === thibaut.__proto__) // affiche true Tout est un objet Si on rentre dans l'objet __proto__ de Person , il y a un autre __proto__ qui est celui d' Object . Object est l'objet le plus haut, il n'y a rien au dessus. Pratiquement tout en Javascript descend d' Object , comme par exemple les Array (tableaux), les String , les Number , les fonctions. Exemple en partant du code de l'exemple pr\u00e9c\u00e9dent : const myObject = {} console.log(louis.__proto__.__proto__ === myObject.__proto__) // affiche true Cela permet d'utiliser les m\u00e9thodes des objets parents, comme par exemple la m\u00e9thode hasOwnProperty qui renvoi un bool\u00e9en pour savoir si une propri\u00e9t\u00e9e pass\u00e9e en param\u00e8tre existe dans l'objet. console.log(louis.hasOwnProperty(\"name\")) // affiche true console.log(louis.hasOwnProperty(\"color\")) // affiche false La cha\u00eene des constructeurs Les objets ont acc\u00e8s aux m\u00e9thodes d\u00e9clar\u00e9es dans la fonction constructeur, dans le prototype, et aux m\u00e9thodes des prototypes parents, notamment d' Object . Si une m\u00e9thode \u00e0 le m\u00eame nom dans la fonction constructeur et dans le prototype, c'est celle dans la fonction constructeur qui sera ex\u00e9cut\u00e9e car il y a un ordre de pr\u00e9f\u00e9rence. C'est ce qu'on appelle la cha\u00eene des prototypes : la m\u00e9thode est d'abord recherch\u00e9e sur notre objet lui-m\u00eame si rien n'est trouv\u00e9, elle est cherch\u00e9e sur le prototype de notre objet si rien n'est encore trouv\u00e9, elle est cherch\u00e9e sur le prototype de l'objet parent, par exemple Object function Person(name, age){ this.name = name this.age = age } let louis = new Person(\"Louis\", 0) console.log(louis.hasOwnProperty(\"name\")) // affiche true. C'est la m\u00e9thode d'Object qui a \u00e9t\u00e9 ex\u00e9cut\u00e9e Person.prototype.hasOwnProperty = function(text){ return(text) } console.log(louis.hasOwnProperty(\"name\")) // affiche name. C'est la m\u00e9thode red\u00e9finie dans le prototype de Person qui a \u00e9t\u00e9 ex\u00e9cut\u00e9e Les classes (ES6) Avec l'arriv\u00e9e d'ES6, pour construire un objet, au lieu de faire une fonction constructeur et ajouter des m\u00e9thodes sur le prototype, on peut cr\u00e9er des classes. En ES5 : function Person(name, age){ this.name = name this.age = age } Person.prototype.present = function(){ console.log(\"Hello my name is \" + this.name) } let louis = new Person(\"Louis\", 0) louis.present() // affiche : Hello my name is Louis En ES6 avec les classes : class Person { constructor(name, age){ this.name = name this.age = age } present(){ console.log(\"Hello my name is \" + this.name) } } let louis = new Person(\"Louis\", 0) louis.present() // affiche : Hello my name is Louis Pour cr\u00e9er un objet avec les classes, c'est comme avant avec le mot cl\u00e9 new . Le changement est uniquement syntaxique pour simplifier l'\u00e9criture du code. L'objet cr\u00e9\u00e9 est exactement le m\u00eame que si on l'avait cr\u00e9\u00e9 avec la fonction constructeur et en d\u00e9clarant les m\u00e9thodes dans le prototype.","title":"Bien comprendre"},{"location":"vraimentBienComprendreJavaScript/#vraiment-bien-comprendre-javascript","text":"","title":"Vraiment bien comprendre JavaScript"},{"location":"vraimentBienComprendreJavaScript/#les-variables","text":"","title":"Les variables"},{"location":"vraimentBienComprendreJavaScript/#les-differents-types-de-variables","text":"console.log(true); console.log(typeof true) // boolean console.log(1); console.log(typeof 1) // number console.log(\"Louis\"); console.log(typeof \"Louis\") // string console.log({name: \"Louis\"}); console.log(typeof {name: \"Louis\"}) // object Diff\u00e9rence entre undefined , null et is not defined : undefined : variable d\u00e9clar\u00e9e mais n'a pas re\u00e7u de valeur null : variable d\u00e9finie par l'utilisateur is not defined : variable non d\u00e9clar\u00e9e var a; console.log(a) // undefined var b = null; console.log(b) // null console.log(c) // c is not defined","title":"Les diff\u00e9rents types de variables"},{"location":"vraimentBienComprendreJavaScript/#le-hoisting-hissage","text":"JavaScript passe le code en revue et recherche les d\u00e9clarations de fonction et les hisse dans le haut de code, ce qui fait qu'on peut ex\u00e9cuter une fonction avant de la d\u00e9clarer. addition(1,3) function addition(a,b){ console.log(a+b) } Cela fonctionne pour les d\u00e9clarations de fonction, mais pas pour les fonctions anonymes stock\u00e9es dans une variable comme l'exemple ci-dessous. Pour que cet exemple fonctionne, il faut appeler addition() apr\u00e8s sa d\u00e9claration. addition(1,3) var addition = function(a,b){ console.log(a+b) } JavaScript hisse \u00e9galement la d\u00e9claration des variables, sans l'assignation de la valeur. console.log(x) // undefined var x = 5 console.log(y) // y is not defined C'est comme-ci on avait fait : var x console.log(x) // undefined var x = 5","title":"Le hoisting (hissage)"},{"location":"vraimentBienComprendreJavaScript/#les-types-primitifs-vs-les-objets","text":"Les variables de type primitif sont copi\u00e9s par valeur, les variables de type objet sont copi\u00e9s par r\u00e9f\u00e9rence. var x = 5 // 5 est stock\u00e9 en m\u00e9moire dans la variable x var y = x // 5 est stock\u00e9 en m\u00e9moire dans la variable y y = 8 // 8 est stock\u00e9 en m\u00e9moire dans la variable y console.log(x) console.log(y) var a = {name: \"Louis\"} // un espace m\u00e9moire est cr\u00e9\u00e9 pour stocker l'objet `{name:\"Louis\"}` et l'adresse de cet espace m\u00e9moire est stock\u00e9e dans l'espace m\u00e9moire de la variable a. On dit que l'espace m\u00e9moire de a est un pointeur. console.log(a) // affiche {name: \"Louis\"} var b = a // un espace m\u00e9moire est cr\u00e9e pour b qui pointe vers le m\u00eame objet que a b.name = \"Ga\u00ebtan\" // comme a et b pointe vers le m\u00eame objet, la modification de b entra\u00eene donc la modification de a console.log(a) // affiche {name: \"Ga\u00ebtan\"} console.log(b) // affiche {name: \"Ga\u00ebtan\"} var a = {name: \"Louis\"} console.log(a) // affiche {name: \"Louis\"} var b = a b = {name: \"Ga\u00ebtan\"} // cr\u00e9e un nouvel objet qui est stock\u00e9 dans un nouvel espace m\u00e9moire. b ne pointe donc plus vers le m\u00eame objet que a console.log(a) // affiche {name: \"Louis\"} console.log(b) // affiche {name: \"Ga\u00ebtan\"}","title":"Les types primitifs vs les objets"},{"location":"vraimentBienComprendreJavaScript/#la-declaration-des-variables","text":"Avec l'ES6, en plus du mot cl\u00e9 var , on peut utiliser les mots-cl\u00e9s let et const . var a = 5 console.log(a) // 5 let b = 6 console.log(b) // 6 const c = 7 console.log(c) // 7 Une constante doit avoir une valeur d\u00e8s sa d\u00e9claration et ne pas peut \u00eatre modifi\u00e9e. On ne peut pas faire : const a; // ERREUR const b = 1; b=2; // ERREUR On ne peut pas assigner un nouvel objet \u00e0 une variable const mais on peut modifier les propri\u00e9t\u00e9s d'un objet const a = {name: \"Louis\"} a.name = \"Ga\u00ebtan\" console.log(a) // {name: \"Ga\u00ebtan\"} const b = {name: \"Louis\"} b = {name: \"Ga\u00ebtan\"} // Erreur : on ne peut pas modifier la valeur d'une const Il n'y a pas de hissage avec const et let comme avec var console.log(a) // undefined var a = 5 console.log(b) // b is not defined let b = 5","title":"La d\u00e9claration des variables"},{"location":"vraimentBienComprendreJavaScript/#quand-utiliser-let-const-et-var","text":"ne plus utiliser le var toujours utiliser le const si on r\u00e9assigne une valeur \u00e0 la variable, utiliser le let","title":"Quand utiliser let, const et var"},{"location":"vraimentBienComprendreJavaScript/#les-scopes","text":"","title":"Les scopes"},{"location":"vraimentBienComprendreJavaScript/#contexte-dexecution","text":"Un contexte d'ex\u00e9cution est un contexte dans lequel un certain bout de code est ex\u00e9cut\u00e9. Cela concerne les infos sur les variables qu'il va d\u00e9finir, auquel il va pouvoir acc\u00e9der... A chaque fois qu'une fonction est ex\u00e9cut\u00e9e , un nouveau contexte d'ex\u00e9cution est cr\u00e9\u00e9. Pour le code qui n'est pas dans une fonction, il appartient au contexte d'ex\u00e9cution global. Un contexte d'ex\u00e9cution est compos\u00e9 de 3 choses : l'objet des variables : fonctions et variables qui sont d\u00e9finies dans ce bout de code la cha\u00eene des scopes : variables auquel peut acc\u00e9der ce bout de code le this : l'objet associ\u00e9 \u00e0 ce bout de code","title":"Contexte d'ex\u00e9cution"},{"location":"vraimentBienComprendreJavaScript/#lobjet-des-variables","text":"L'objet des variables, ou Variable Objet (VO) , est cr\u00e9\u00e9 et initialis\u00e9 pendant la phase de cr\u00e9ation du contexte d'ex\u00e9cution. Il contient : les arguments de la fonction les d\u00e9clarations de fonctions avec le hoisting les d\u00e9clarations de variables avec le hoisting (les variables d\u00e9clar\u00e9es avec var )","title":"L'objet des variables"},{"location":"vraimentBienComprendreJavaScript/#la-chaine-des-scopes","text":"Le scope veut dire port\u00e9e en fran\u00e7ais. Cela permet de savoir \u00e0 quel endroit du code il est possible d'acc\u00e9der \u00e0 quelle variable. Le code qui n'appartient \u00e0 aucune fonction appartient au scope global. A chaque fois qu'une fonction est ex\u00e9cut\u00e9e, un scope local est cr\u00e9\u00e9, on parle de scope de fonction . Pour les variables cr\u00e9\u00e9es avec let et const , un scope de bloc est cr\u00e9\u00e9 (cf ci-apr\u00e8s). Une r\u00e8gle de base sur les scopes est qu'une fonction enfant peut acc\u00e9der au scope de ses parents, c'est-\u00e0-dire \u00e0 son objet des variables ainsi qu'\u00e0 l'objet des variables de ses parents. Si on d\u00e9clare une variable dans une fonction alors qu'une variable avec le m\u00eame nom existe d\u00e9j\u00e0 dans un scope sup\u00e9rieur, une nouvelle variable est d\u00e9finie, dans un espace m\u00e9moire diff\u00e9rent, et c'est celle du scope local qui est utilis\u00e9e. Lorsqu'on cherche une variable, on cherche d'abord la variable dans le scope local et si elle n'existe pas, on remonte la cha\u00eene des scopes jusqu'\u00e0 trouver notre variable.","title":"La cha\u00eene des scopes"},{"location":"vraimentBienComprendreJavaScript/#le-scope-de-bloc-es6","text":"Chaque fonction cr\u00e9e un nouvdau scope. Jusqu'\u00e0 l'arriv\u00e9e d'ES6, il n'y avait que le scope de fonction. Lorsqu'on d\u00e9clare des variables avec let et const , les variables ne respectent pas les scopes de fonction mais les scopes de bloc. Un bloc est tout ce qui est entre accolades. Par exemple, le code suivant ne fonctionne pas alors que \u00e7a aurait fonctionn\u00e9 avec le mot cl\u00e9 var . if(true){ let a = 5; } console.log(a) // a is not defined L'exemple suivant fonctionne car la variable est d\u00e9finie dans le m\u00eame scope qu'on souhaite l'afficher let a if(true){ a = 5; } console.log(a) // affiche 5 Il faut \u00e9viter d'utiliser le mot cl\u00e9 var et privil\u00e9gier const et let pour \u00e9viter les mauvaises surprises. Par exemple : var i = 62 for(i = 0 ; i < 10 ; i++){ console.log(i) } console.log(i) // affiche 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 et 10 let i = 62 for(let i = 0 ; i < 10 ; i++){ console.log(i) } console.log(i) // affiche 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 et 62","title":"Le scope de bloc (ES6)"},{"location":"vraimentBienComprendreJavaScript/#les-fonctions","text":"","title":"Les fonctions"},{"location":"vraimentBienComprendreJavaScript/#fonction-premiere-classe","text":"Les fonctions sont des objets de premi\u00e8re classe, c'est-\u00e0-dire que ce sont des objets comme les autres. une fonction peut prendre une fonction en argument function addTwo(numberToAdd){ return numberToAdd + 2 } function myFunction(argFunction, number){ const x = argFunction(number) console.log(x) } myFunction(addTwo, 5) // affiche 7 une fonction peut retourner une autre fonction function myFunction(){ return function(number){ return number * 2 } } console.log(myFunction) // affiche la d\u00e9claration de myFonction console.log(myFunction()) // affiche la d\u00e9claration de la fonction anonyme : \u0192unction(number){return number * 2} console.log(myFunction()(3)) // affiche 6 on peut assigner une fonction \u00e0 une variable const returnedFunction = function(){ return 5+2 } console.log(returnedFunction()) // affiche 7 function myFunction(){ return 5+2 } const returnedFunction = myFunction() console.log(returnedFunction) // affiche 7","title":"Fonction Premi\u00e8re Classe"},{"location":"vraimentBienComprendreJavaScript/#les-closures","text":"Une closure, est une fermeture. C'est une fonction qui a enferm\u00e9 avec elle des variables qui lui sont externes, provenant d'un scope parent. function multiplyBy(number){ const closedVariable = number return function(anotherNumber){ return closedVariable * anotherNumber } } const multiplyByFive = multiplyBy(5) const multiplyByThree = multiplyBy(3) console.log(multiplyByFive) // function(anotherNumber){return closedVariable * anotherNumber} console.log(multiplyByFive(2)) // 10 console.log(multiplyByThree(2)) // 6 Dans cet exemple, mutilyByFive utilise la variable closedVariable lors de son ex\u00e9cution avec le param\u00e8tre 2, alors que closedVariable fait parti du contexte d'ex\u00e9cution de multiplyBy(5) qui a disparu apr\u00e8s l'ex\u00e9cution de la fonction, donc closedVariable devrait avoir disparu, mais il est toujours disponible dans multiplyByFive, c'est ce qu'on appelle une closure car la fonction a captur\u00e9 une variable d'un scope parent. C'est la m\u00eame chose pour multiplyByThree.","title":"Les closures"},{"location":"vraimentBienComprendreJavaScript/#mefiez-vous-des-scopes","text":"Il faut prot\u00e9ger ses variables pour \u00e9viter qu'elles soient \"pirat\u00e9es\" par un autre script. Exemple avec une page HTML qui charge 3 scripts : <!DOCTYPE html> <html> <head> <script src=\"script1.js\"></script> <script src=\"script2.js\"></script> <script src=\"script3.js\"></script> </head> // script1.js var myPassword = \"12345\" function setPassword(newPassword){ myPassword = newPassword } function getPassword(){ return myPassword } // script2.js var myPassword = \"000\" // script3.js console.log(getPassword()) // affiche 000 alors qu'on voulait 12345 Dans le script 3, on veut r\u00e9cup\u00e9rer myPassword de script 1 mais elle a \u00e9t\u00e9 \u00e9cras\u00e9 par myPassword du script 2 car les variables ont le m\u00eame nom et elles sont toutes les 2 dans le scope global. Il faut \u00e9viter au maximum de rattacher les variables au scope global. Il faut d\u00e9finir ce qu'on souhaite rendre priv\u00e9 (uniquement utilisable dans le script courant) et ce qu'on veut rendre public, c'est-\u00e0-dire rendre accessible aux autres scripts. Pour cela on va utiliser les IIFEs","title":"M\u00e9fiez-vous des scopes"},{"location":"vraimentBienComprendreJavaScript/#iifes","text":"Les fonctions imm\u00e9diatement ex\u00e9cut\u00e9es se nomment des Immediatly-Invoked Function Expression , abr\u00e9g\u00e9es IIFE. L'id\u00e9e est d\u00e9clarer la fonction et de l'ex\u00e9cuter en m\u00eame temps. En utilisant une IIFE, tout le code ex\u00e9cut\u00e9 dedans sera priv\u00e9 et non accessible de l'ext\u00e9rieur. // fonction classique function myFunction(){ // code de la fonction } // IIFE (function(){ // code de la fonction })() Pour revenir \u00e0 notre exemple pr\u00e9c\u00e9dent o\u00f9 l'on veut rendre public getPassword() et rendre priv\u00e9 myPassword et setPassword , on peut utiliser les IIFEs et les closures pour r\u00e9soudre ce probl\u00e8me. const getPassword = (function(){ var myPassword = \"12345\" function setPassword(newPassword){ myPassword = newPassword } return function(){ return myPassword } })() Cet exemple permet de rendre accessible la fonction getPassword uniquement de ce script. Cependant, cela permet uniquement d'exposer une variable ou une fonction. Il est possible de rendre public plusieurs \u00e9l\u00e9ments public en retournant un objet : const script1 = (function(){ var myPassword = \"12345\" function setPassword(newPassword){ myPassword = newPassword } function getPassword(){ return myPassword } return { getPassword: getPassword, setPassword: setPassword, } })() // appel dans le script 3 console.log(script1.getPassword())","title":"IIFEs"},{"location":"vraimentBienComprendreJavaScript/#le-mot-cle-this","text":"A chaque contexte d'ex\u00e9cution est associ\u00e9 un objet. this permet d'acc\u00e9der \u00e0 cet objet. console.log(this) // donne Window qui est l'objet global dans le navigateur. JavaScript ex\u00e9cut\u00e9 dans un autre environnement comme un serveur aurait donn\u00e9 un autre objet global. Le this est l'objet qui a ex\u00e9cut\u00e9 la m\u00e9thode, sinon ce sera l'objet global function first(){ console.log(this) } first() // Window const louis = { name: \"Louis\", present: first } louis.present() // {name: \"Louis\", present: \u0192}","title":"Le mot cl\u00e9 THIS"},{"location":"vraimentBienComprendreJavaScript/#choses-bizarres","text":"Les d\u00e9clarations de variables avec var et les d\u00e9clarations de fonctions dans le contexte d'ex\u00e9cution global sont stock\u00e9es dans l'objet global Window. Ce n'est pas le cas pour les variables d\u00e9clar\u00e9es avec let et const . var a = 5 function allo(){ } console.log(this) // on retrouve a et allo() dans Window var myName = \"Louis\" console.log(window.myName === this.myName && window.myName === myName) // affiche true Si on oublie le mot cl\u00e9 var pour d\u00e9clarer une variable, elle est automatiquement rattach\u00e9 \u00e0 l'objet global, m\u00eame si elle est d\u00e9clar\u00e9e dans une fonction. function allo(){ b = 9 } allo() console.log(this) // on retrouve b dans l'objet Window Pour \u00e9viter cela, on peut utiliser le mode strict en ajoutant la commande 'use strict' en haut du fichier javascript et ce qui aura pour effet dans le script pr\u00e9c\u00e9dent de renvoyer une erreur en disant que b n'est pas d\u00e9fini.","title":"Choses bizarres"},{"location":"vraimentBienComprendreJavaScript/#bind-call-et-apply","text":"Ces m\u00e9thodes vont permettre de contr\u00f4ler la valeur du this . bind est une m\u00e9thode qui permet de changer la valeur du this en appliquant le this d'un autre objet. function first(){ console.log(this) } first() // affiche l'objet global Window const louis = { name: \"Louis\", present: function(){ console.log(this) } } const second = first.bind(louis) // fixe le this de louis sur la fonction second second() // affiche l'objet louis louis.present() // affiche l'objet louis louis.present.bind(window)() // affiche l'objet Window car on a chang\u00e9 la valeur de this en mettant Window \u00e0 la place de louis Voici quelques autres exemples var name = \"Louis\" function present(){ console.log(this.name) } const kev = { name: \"K\u00e9vin\", present: present } const thib = { name: \"Thibaut\", present: present.bind(this) } const presentKev = kev.present const presentKevBind = kev.present.bind(kev) const presentKevBind2 = kev.present.bind(this) present() // affiche Louis : comme ce n'est pas un objet qui ex\u00e9cute la fonction, c'est l'objet global Window qui l'ex\u00e9cute. Le this est donc associ\u00e9 \u00e0 Window, on cherche donc \u00e0 logguer un window.name et on a d\u00e9clar\u00e9 la variable name dans le scope global, qui est donc attach\u00e9 \u00e0 l'objet Window, donc window.name = \"John\" kev.present() // affiche K\u00e9vin : present est ex\u00e9cut\u00e9e en tant que m\u00e9thode de l'objet kev donc le this est kev presentKev() // affiche Louis : presentKev est \u00e9gale \u00e0 une m\u00e9thode d'un objet mais elle est ex\u00e9cut\u00e9e en tant que fonction et n'est pas associ\u00e9e \u00e0 un objet, le this est donc Window presentKevBind() // affiche K\u00e9vin : comme la m\u00e9thode pr\u00e9c\u00e9dente sauf que le this a \u00e9t\u00e9 bind\u00e9 avec l'objet kev presentKevBind2() // affiche Louis comme pour presentKev en bindant le this qui correspond \u00e0 Window, donc \u00e7a ne change rien de faire le bind dans ce cas thib.present() // affiche Louis : la m\u00e9thode present est bind\u00e9e avec this dans l'objet franck et le this correspond \u00e0 Window \u00e0 ce moment l\u00e0 bind permet aussi de fixer la valeur des arguments que va prendre la nouvelle fonction que l'on cr\u00e9e. function multiply(number1, number2){ return number1 * number2 } // on fixe la valeur du premier argument de multiply \u00e0 2. // multiplyByTwo prend donc un seul argument qui correspond au number2 de multiply const multiplyByTwo = multiply.bind(this, 2) console.log(multiplyByTwo(3)) // affiche 6 Les m\u00e9thodes call et apply ne cr\u00e9ent pas une nouvelle fonction qu'il faut ensuite ex\u00e9cuter comme bind , elles l'ex\u00e9cutent directement. function multiply(number1, number2){ console.log(this) console.log(number1 * number2) } const louis = { name: \"Louis\" } multiply.bind(louis, 2, 3)() // affiche louis et 6 // call ex\u00e9cute directement multiplly multiply.call(louis, 2, 3) // affiche Window et 6 comme bind // apply prend les arguments de la fonction dans un tableau multiply.apply(louis, [2, 3]) // affiche Window et 6 comme bind","title":"Bind, Call et Apply"},{"location":"vraimentBienComprendreJavaScript/#les-fonctions-flechees-arrow-functions","text":"Les fonctions fl\u00e9ch\u00e9es ont 2 particularit\u00e9es : la syntaxe est plus rapide elles vont fixer la valeur du this automatiquement La syntaxe : const myFunction = arg => arg * 5 console.log(myFunction(3)) // affiche 15 const myFunction2 = () => 4 * 5 console.log(myFunction2()) // affiche 20 const myFunction3 = (nombre1, nombre2) => nombre1 * nombre2 console.log(myFunction3(3, 4)) // affiche 12 On peut utiliser des accolades si la fonction fait davantage que retourner une valeur, comme par exemple ex\u00e9cuter du code avant. const myFunction3 = (nombre1, nombre2) => { const nombreCalcule = nombre1 * nombre1 return nombreCalcule * nombre2 } console.log(myFunction3(3, 4)) // affiche 36 (3 * 3 * 4) Fonctionne aussi sur les objets louis = { name: \"Louis\", // syntaxe classique present: function(friend){ return \"Tu connais \"+friend+\" ?\" }, // nouvelle syntaxe presentArrow: friend => \"Tu connais \"+friend+\" ?\" } console.log(louis.present(\"K\u00e9vin\")) console.log(louis.presentArrow(\"Thibaut\")) Les fonctions fl\u00e9ch\u00e9es fixent la valeur du this automatiquement. Dans l'exemple ci-dessous, le this de presentClassic est l'objet louis car c'est l'objet louis qui a ex\u00e9cut\u00e9 la m\u00e9thode. Pour presentArrow , son this est Windows. Une fonction fl\u00e9ch\u00e9e capture le this du scope parent o\u00f9 elle a \u00e9tait d\u00e9clar\u00e9e. Il faut donc regarder \u00e0 quoi correspond le this de l'endroit o\u00f9 elle a \u00e9t\u00e9 d\u00e9clar\u00e9e. Cela revient au m\u00eame que l'ex\u00e9cution d'une fonction classique o\u00f9 on aurait bind\u00e9 le this. function classicFunction(){ console.log(this) } const classicFunctionBind = classicFunction.bind(this) const arrowFunction = () => { console.log(this) } const louis = { name: \"Louis\", presentClassic: classicFunction, presentClassicBind: classicFunctionBind, presentArrow: arrowFunction, } louis.presentClassic() // affiche louis louis.presentClassicBind() // affiche Window louis.presentArrow() // affiche Window","title":"Les fonctions fl\u00e9ch\u00e9es (Arrow Functions)"},{"location":"vraimentBienComprendreJavaScript/#les-objets","text":"","title":"Les objets"},{"location":"vraimentBienComprendreJavaScript/#fonction-constructeur","text":"Une fonction constructeur est un moule. En ex\u00e9cutant cette fonction, on cr\u00e9e des instances bas\u00e9es sur ce moule. function Person(name, age){ this.name = name this.age = age this.present = () => {console.log(\"Hello my name is \"+this.name)} } let louis = new Person(\"Louis\", 0) let thibaut = new Person(\"Thibaut\", 23) louis.present() // Hello my name is Louis thibaut.present() // Hello my name is Thibaut console.log(louis) // affiche l'objet louis console.log(thibaut) // affiche l'objet thibaut console.log(louis.present === thibaut.present) // affiche false present de louis et present de thibaut sont 2 m\u00e9thodes diff\u00e9rentes qui font la m\u00eame chose, donc elles sont stock\u00e9es deux fois en m\u00e9moire alors qu'on aurait pu les stocker qu'une fois. On va pouvoir faire cela avec les prototypes.","title":"Fonction constructeur"},{"location":"vraimentBienComprendreJavaScript/#les-prototypes","text":"On va stocker la fonction dans le prototype de Person, comme \u00e7a elle sera unique. Il faut utiliser une fonction classique au lieu d'une fonction fl\u00e9ch\u00e9e, car une fonction fl\u00e9ch\u00e9e capturerait le this de l'endroit o\u00f9 elle est d\u00e9clar\u00e9e, c'est-\u00e0-dire l'objet global. function Person(name, age){ this.name = name this.age = age //this.present = () => {console.log(\"Hello my name is \"+this.name)} } Person.prototype.present = function(){ console.log(\"Hello my name is \"+this.name) } let louis = new Person(\"Louis\", 0) let thibaut = new Person(\"Thibaut\", 23) louis.present() // Hello my name is Louis console.log(louis.present === thibaut.present) // affiche true Dans l'exemple pr\u00e9c\u00e9dent sans utiliser les prototypes, si on regarde ce que contient l'objet Person , il y a les attributs name et age , la fonction present , et l'objet __proto__ , qui contient lui-m\u00eame le constructeur de Person . En d\u00e9clarant la fonction dans le prototype, la fonction present n'est plus dans l'objet Person mais dans l'objet __proto__ . __proto__ correspond au prototype de la personne et il est accessible \u00e0 toutes les instances cr\u00e9\u00e9es avec la fonction constructeur Person . console.log(louis.__proto__ === Person.prototype) // affiche true console.log(louis.__proto__ === thibaut.__proto__) // affiche true","title":"Les prototypes"},{"location":"vraimentBienComprendreJavaScript/#tout-est-un-objet","text":"Si on rentre dans l'objet __proto__ de Person , il y a un autre __proto__ qui est celui d' Object . Object est l'objet le plus haut, il n'y a rien au dessus. Pratiquement tout en Javascript descend d' Object , comme par exemple les Array (tableaux), les String , les Number , les fonctions. Exemple en partant du code de l'exemple pr\u00e9c\u00e9dent : const myObject = {} console.log(louis.__proto__.__proto__ === myObject.__proto__) // affiche true Cela permet d'utiliser les m\u00e9thodes des objets parents, comme par exemple la m\u00e9thode hasOwnProperty qui renvoi un bool\u00e9en pour savoir si une propri\u00e9t\u00e9e pass\u00e9e en param\u00e8tre existe dans l'objet. console.log(louis.hasOwnProperty(\"name\")) // affiche true console.log(louis.hasOwnProperty(\"color\")) // affiche false","title":"Tout est un objet"},{"location":"vraimentBienComprendreJavaScript/#la-chaine-des-constructeurs","text":"Les objets ont acc\u00e8s aux m\u00e9thodes d\u00e9clar\u00e9es dans la fonction constructeur, dans le prototype, et aux m\u00e9thodes des prototypes parents, notamment d' Object . Si une m\u00e9thode \u00e0 le m\u00eame nom dans la fonction constructeur et dans le prototype, c'est celle dans la fonction constructeur qui sera ex\u00e9cut\u00e9e car il y a un ordre de pr\u00e9f\u00e9rence. C'est ce qu'on appelle la cha\u00eene des prototypes : la m\u00e9thode est d'abord recherch\u00e9e sur notre objet lui-m\u00eame si rien n'est trouv\u00e9, elle est cherch\u00e9e sur le prototype de notre objet si rien n'est encore trouv\u00e9, elle est cherch\u00e9e sur le prototype de l'objet parent, par exemple Object function Person(name, age){ this.name = name this.age = age } let louis = new Person(\"Louis\", 0) console.log(louis.hasOwnProperty(\"name\")) // affiche true. C'est la m\u00e9thode d'Object qui a \u00e9t\u00e9 ex\u00e9cut\u00e9e Person.prototype.hasOwnProperty = function(text){ return(text) } console.log(louis.hasOwnProperty(\"name\")) // affiche name. C'est la m\u00e9thode red\u00e9finie dans le prototype de Person qui a \u00e9t\u00e9 ex\u00e9cut\u00e9e","title":"La cha\u00eene des constructeurs"},{"location":"vraimentBienComprendreJavaScript/#les-classes-es6","text":"Avec l'arriv\u00e9e d'ES6, pour construire un objet, au lieu de faire une fonction constructeur et ajouter des m\u00e9thodes sur le prototype, on peut cr\u00e9er des classes. En ES5 : function Person(name, age){ this.name = name this.age = age } Person.prototype.present = function(){ console.log(\"Hello my name is \" + this.name) } let louis = new Person(\"Louis\", 0) louis.present() // affiche : Hello my name is Louis En ES6 avec les classes : class Person { constructor(name, age){ this.name = name this.age = age } present(){ console.log(\"Hello my name is \" + this.name) } } let louis = new Person(\"Louis\", 0) louis.present() // affiche : Hello my name is Louis Pour cr\u00e9er un objet avec les classes, c'est comme avant avec le mot cl\u00e9 new . Le changement est uniquement syntaxique pour simplifier l'\u00e9criture du code. L'objet cr\u00e9\u00e9 est exactement le m\u00eame que si on l'avait cr\u00e9\u00e9 avec la fonction constructeur et en d\u00e9clarant les m\u00e9thodes dans le prototype.","title":"Les classes (ES6)"}]}