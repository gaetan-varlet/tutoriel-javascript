<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Dév moderne - Tutoriel JS</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="..">Tutoriel JS</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="..">Accueil</a>
                            </li>
                            <li >
                                <a href="../lesBasesDeJavaScript/">Les bases</a>
                            </li>
                            <li >
                                <a href="../vraimentBienComprendreJavaScript/">Bien comprendre</a>
                            </li>
                            <li class="active">
                                <a href="./">Dév moderne</a>
                            </li>
                            <li >
                                <a href="../objetsEtFonctionsUtilesJavascript/">Fonctions utiles</a>
                            </li>
                            <li >
                                <a href="../javascriptDebarqueDansLeNavigateur/">Dans le nav</a>
                            </li>
                            <li >
                                <a href="../frameworksJavascript/">Les bib</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="../vraimentBienComprendreJavaScript/">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="../objetsEtFonctionsUtilesJavascript/">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#developpement-moderne-javascript">Développement Moderne JavaScript</a></li>
            <li><a href="#-">----</a></li>
        <li class="main "><a href="#nouveautes-es6">Nouveautés ES6</a></li>
            <li><a href="#rappels">Rappels</a></li>
            <li><a href="#les-parametres-par-defaut">Les paramètres par défaut</a></li>
            <li><a href="#les-parametres-rest">Les paramètres Rest</a></li>
            <li><a href="#loperation-spread">L'opération Spread</a></li>
            <li><a href="#for-of">for of</a></li>
            <li><a href="#les-template-literals-ou-template-string">Les Template Literals ou Template String</a></li>
            <li><a href="#destructuring-arrays">Destructuring Arrays</a></li>
            <li><a href="#destructuring-objects">Destructuring Objects</a></li>
            <li><a href="#-_1">----</a></li>
        <li class="main "><a href="#les-classes-es6">Les classes (ES6)</a></li>
            <li><a href="#la-notion-de-classe">La notion de classe</a></li>
            <li><a href="#lheritage-inheritance">L'héritage (Inheritance)</a></li>
            <li><a href="#etendre-les-objets-integres-extend-built-in-objects">Etendre les objets intégrés (Extend Built-In Objects)</a></li>
            <li><a href="#methodes-statiques">Méthodes Statiques</a></li>
            <li><a href="#get-et-set">Get et Set</a></li>
            <li><a href="#-_2">----</a></li>
        <li class="main "><a href="#les-modules-es6">Les modules (ES6)</a></li>
            <li><a href="#loperateur-dexponentiation-operateur-de-puissance">L'opérateur d'exponentiation (opérateur de puissance)</a></li>
            <li><a href="#-_3">----</a></li>
        <li class="main "><a href="#developpement-moderne-javascript_1">Développement moderne JavaScript</a></li>
            <li><a href="#-_4">----</a></li>
        <li class="main "><a href="#npm">Npm</a></li>
            <li><a href="#les-bases-de-npm">Les bases de Npm</a></li>
            <li><a href="#le-fichier-packagejson">Le fichier package.json</a></li>
            <li><a href="#-_5">----</a></li>
        <li class="main "><a href="#webpack">Webpack</a></li>
            <li><a href="#quest-ce-que-webpack">Qu'est-ce que Webpack</a></li>
            <li><a href="#executer-webpack">Exécuter Webpack</a></li>
            <li><a href="#serveur-local-webpack">Serveur local Webpack</a></li>
            <li><a href="#architecture-des-fichiers">Architecture des fichiers</a></li>
            <li><a href="#-_6">----</a></li>
        <li class="main "><a href="#babel">Babel</a></li>
            <li><a href="#quest-ce-que-babel">Qu'est-ce que Babel</a></li>
            <li><a href="#babel-loader">Babel loader</a></li>
            <li><a href="#babel-polyfill">Babel polyfill</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="developpement-moderne-javascript">Développement Moderne JavaScript</h1>
<h2 id="-">----</h2>
<h1 id="nouveautes-es6">Nouveautés ES6</h1>
<hr />
<h2 id="rappels">Rappels</h2>
<p>Dans la partie précédente ont déjà été vu des nouveautés ES6 :
- les nouveaux mots clés <code>let</code> et <code>var</code> pour déclarer une variable
- les scopes de bloc
- quand utiliser <code>var</code>, <code>let</code> et <code>const</code>
- les fonctions fléchés
- le concept de classe</p>
<hr />
<h2 id="les-parametres-par-defaut">Les paramètres par défaut</h2>
<p>On peut maintenant utiliser des paramètres par défaut dans les fonctions.</p>
<p>Quand il y a une valeur par défaut à un paramètre, si on renseigne une valeur pour ce paramètre, la valeur spécifiée sera prise en compte. Si aucune valeur n'est spécifée, la valeur par défaut est prise en compte.</p>
<pre><code class="js">function nomComplet(prenom, nom){
    console.log(prenom + &quot; &quot; + nom)
}
nomComplet(&quot;Brad&quot;,&quot;Pitt&quot;) // affiche Brad Pitt

function nomComplet(prenom, nom){
    console.log(prenom + &quot; &quot; + nom)
}
nomComplet(&quot;Brad&quot;) // affiche Brad undefined

function nomComplet(prenom, nom=&quot;Cruise&quot;){
    console.log(prenom + &quot; &quot; + nom)
}
nomComplet(&quot;Brad&quot;) // affiche Brad Cruise
nomComplet(&quot;Brad&quot;,&quot;Pitt&quot;) // affiche Brad Pitt
</code></pre>

<p>Les arguments sont évalués de gauche à droite, il faut donc mettre les paramètres avec des valeurs par défaut en dernier.</p>
<pre><code class="js">function nomComplet(prenom=&quot;Brad&quot;, nom){
    console.log(prenom + &quot; &quot; + nom)
}
nomComplet(&quot;Pitt&quot;) // affiche Pitt undefined

function nomComplet(nom, prenom=&quot;Brad&quot;){
    console.log(prenom + &quot; &quot; + nom)
}
nomComplet(&quot;Pitt&quot;) // affiche Brad Pitt
</code></pre>

<p>On peut utiliser des variables définies dans le scope global dans les paramètres par défaut</p>
<pre><code class="js">const nomActeur = &quot;Pitt&quot;
function nomComplet(prenom, nom=nomActeur){
    console.log(prenom + &quot; &quot; + nom)
}
nomComplet(&quot;Brad&quot;) // affiche Brad Pitt
</code></pre>

<hr />
<h2 id="les-parametres-rest">Les paramètres Rest</h2>
<p>L'idée est de spécifier des paramètres à une fonction et que ces paramètres soient stockées dans un tableau. Le nombre de ces paramètres est libre. Il faut pour cela utiliser <code>...</code></p>
<p>Exemple sans les paramètres Rest où il faut donner un tableau</p>
<pre><code class="js">const mesNombres = [1, 2, 3, 4]

function faireSomme(nombres){
    let somme = 0
    for(let i =0 ; i &lt; nombres.length ; i++){
        somme += nombres[i]
    }
    return somme
}

console.log(faireSomme(mesNombres)) // affiche 10
</code></pre>

<p>Exemple avec les paramètres Rest où l'on peut fournir des valeurs libres qui sont stockées dans un tableau grâce aux <code>...</code></p>
<pre><code class="js">function faireSomme(...nombres){
    console.log(nombres) // affiche [1, 2, 3, 4]
    let somme = 0
    for(let i =0 ; i &lt; nombres.length ; i++){
        somme += nombres[i]
    }
    return somme
}

console.log(faireSomme(1, 2, 3, 4)) // affiche 10
</code></pre>

<hr />
<h2 id="loperation-spread">L'opération Spread</h2>
<p>L'opérateur Spread est l'inverse des paramètres Rest. Les paramètres Rest prennent des valeurs libres et les transforment en tableau. L'opérateur Spread prend un tableau et le transforme en valeurs libres. Il s'utilise comme pour les paramètres Rest avec <code>...</code>. Ce qui va les différencier est quand on les utilise : si on lui donne des valeurs libres, il va les regrouper dans un tableau, et inversement.</p>
<pre><code class="js">const mesNombres = [1, 2, 3]

function faireSomme3Nombres(nb1, nb2, nb3){
    console.log(nb1) // affiche [1, 2, 3]
    console.log(nb2) // affiche undefined
    console.log(nb3) // affiche undefined
    return nb1 + nb2 + nb3
}

console.log(faireSomme3Nombres(mesNombres))
</code></pre>

<p>Cet exemple ne fonctionne pas, il faudrait fournir chaque élément du tableau à la fonction en faisant :</p>
<pre><code class="js">console.log(faireSomme3Nombres(mesNombres[0], mesNombres[1], mesNombres[2]))
</code></pre>

<p>On peut le faire plus simplement en utilisant l'opérateur Spread :</p>
<pre><code class="js">const mesNombres = [1, 2, 3]

function faireSomme3Nombres(nb1, nb2, nb3){
    console.log(nb1) // affiche 1
    console.log(nb2) // affiche 2
    console.log(nb3) // affiche 3
    return nb1 + nb2 + nb3
}

console.log(faireSomme3Nombres(...mesNombres)) // affiche 6
</code></pre>

<p>On peut aussi utiliser l'opérateur Spread ailleurs que dans une fonction, par exemple pour regrouper deux tableaux en un.</p>
<pre><code class="js">const fruits = [&quot;Pomme&quot;, &quot;Melon&quot;]
const legumes = [&quot;Tomate&quot;, &quot;Concombre&quot;]

// en faisant ça, on aura un tableau qui contient 2 tableaux de 2 éléments et pas un seul tableau de 4 éléments.
const fruitsEtLegumes = [fruits, legumes]
console.log(fruitsEtLegumes)

// ici, on éclate nos 2 tableaux en valeurs libres pour recréer un unique tableau
const fruitsEtLegumesSpread = [...fruits, ...legumes]
console.log(fruitsEtLegumesSpread) // affiche [&quot;Pomme&quot;, &quot;Melon&quot;, &quot;Tomate&quot;, &quot;Concombre&quot;]

// on peut aussi ajouter une valeur libre au milieu
const fruitsEtLegumesSpread2 = [...fruits, &quot;Banane&quot;, ...legumes]
console.log(fruitsEtLegumesSpread2) // affiche [&quot;Pomme&quot;, &quot;Melon&quot;, &quot;Banane&quot;, &quot;Tomate&quot;, &quot;Concombre&quot;]
</code></pre>

<p>L'opérateur Spread est utile pour créer un nouveau tableau à partir d'un ancien en changeant la référence de celui-ci.
Sans l'opérateur Spread, en faisant comme ça, ajouter un élément à un deux deux tableaux l'ajoute aux deux tableaux car <em>fruits</em> et <em>fruits2</em> poitent vers le même tableau.</p>
<pre><code class="js">const fruits = [&quot;Pomme&quot;, &quot;Melon&quot;]
const fruits2 = fruits

fruits2.push(&quot;Banane&quot;)

console.log(fruits) // affiche [&quot;Pomme&quot;, &quot;Melon&quot;, &quot;Banane&quot;]
console.log(fruits2) // affiche [&quot;Pomme&quot;, &quot;Melon&quot;, &quot;Banane&quot;]
</code></pre>

<p>Avec l'opérateur Spread, un nouveau tableau <em>fruits2</em> est créé qui a une référence différente que le premier tableau. Un changement sur l'un n'impactera pas l'autre.</p>
<pre><code class="js">const fruits = [&quot;Pomme&quot;, &quot;Melon&quot;]
const fruits2 = [...fruits]

fruits2.push(&quot;Banane&quot;)

console.log(fruits) // affiche [&quot;Pomme&quot;, &quot;Melon&quot;]
console.log(fruits2) // affiche [&quot;Pomme&quot;, &quot;Melon&quot;, &quot;Banane&quot;]
</code></pre>

<hr />
<h2 id="for-of">for of</h2>
<p>Pour passer sur les éléments d'un tableau, on peut utiliser une boucle for classique. Avec ES6, une nouvelle syntaxe permet de parcourir les tableaux : le <strong>for of</strong>.</p>
<p>Exemple en ES5 :</p>
<pre><code class="js">const fruits = [&quot;Pomme&quot;, &quot;Melon&quot;, &quot;Fraise&quot;]

for(let i = 0 ; i &lt; fruits.length ; i++){
  console.log(fruits[i])
}
// affiche Pomme, puis Melon, puis Fraise
</code></pre>

<p>Exemple avec <em>for of</em> qui fait exactement la même chose. Il faut nommer une variable qui correspond à la valeur courante du tableau que l'on parcourt.</p>
<pre><code class="js">const fruits = [&quot;Pomme&quot;, &quot;Melon&quot;, &quot;Fraise&quot;]

for(let fruit of fruits){
  console.log(fruit)
}
// affiche Pomme, puis Melon, puis Fraise
</code></pre>

<hr />
<h2 id="les-template-literals-ou-template-string">Les Template Literals ou Template String</h2>
<p>Les template literals permettent de simplifier la concaténation. Il faut utiliser les back tilt (Alt Gr + 7) à la place des guillemets dans le <code>console.log()</code> et mettre la variable entre accolades avec un dollar devant à la place des plus.</p>
<p>Exemple de concaténation classique :</p>
<pre><code class="js">const nom = &quot;Louis&quot;
console.log(&quot;Je m'appelle &quot; + nom + &quot; !&quot;)
</code></pre>

<p>Exemple avec le template literal :</p>
<pre><code class="js">const nom = &quot;Louis&quot;
console.log(`Je m'appelle ${nom} !!!`)
</code></pre>

<p>L'avantage est que l'on peut aussi créer des string multiligne :</p>
<pre><code class="js">const maString = `Je suis sur la ligne 1


Je suis sur la ligne 3
Je suis sur la ligne 4`
console.log(maString)
</code></pre>

<hr />
<h2 id="destructuring-arrays">Destructuring Arrays</h2>
<p>Si on veut créer des variables à partir des valeurs d'un tableau, il faut préciser pour chaque variable quel élément du tableau on souhaite récupérer. Avec l'ES6, il est possible de déstructurer le tableau pour simplifier la récupération des valeurs d'un tableau.</p>
<p>Exemple en ES5 :</p>
<pre><code class="js">const nombres = [1, 2, 3]
const a = nombres[0]
const b = nombres[1]

console.log(a) // affiche 1
console.log(b) // affiche 2
</code></pre>

<p>Exemple en ES6 qui fait la même chose :</p>
<pre><code class="js">const nombres = [1, 2, 3]
const [a,b] = nombres

console.log(a)
console.log(b)
</code></pre>

<p>Il est possible de faire d'autres choses :</p>
<pre><code class="js">const nombres = [1, 2, 3]
const [a,b,c,d] = nombres

console.log(a)
console.log(b)
console.log(c)
console.log(d) // affiche undefined
</code></pre>

<pre><code class="js">const nombres = [1, 2, 3]
const [a,b,c,d=10] = nombres

console.log(a)
console.log(b)
console.log(c)
console.log(d) // affiche 10
</code></pre>

<pre><code class="js">const nombres = [1, 2, 3]
const [a, ...b] = nombres

console.log(a) // affiche 1
console.log(b) // affiche [2, 3]
</code></pre>

<pre><code class="js">const nombres = [1, 2, 3]
const [a, ,b] = nombres

console.log(a) // affiche 1
console.log(b) // affiche 3
</code></pre>

<p>On peut aussi intervertir la valeur de 2 variables sans passer par une troisième variable (ne fonctionne pas sur mon poste) :</p>
<pre><code class="js">let a = 1
let b = 2
[b,a] = [a,b]
console.log(a) //affiche 2
console.log(b) // affiche 1
</code></pre>

<hr />
<h2 id="destructuring-objects">Destructuring Objects</h2>
<p>Il aussi possible de déstructurer un objet. La différence avec le destructuring de tableau est qu'il est basé sur l'ordre des valeurs dans le tableau alors qu'avec les objets, il faut que les variables aient le même nom que les propriétés de l'objet, sinon la variable ne sera pas renseignée.</p>
<pre><code class="js">const myObject ={
    name:&quot;Louis&quot;,
    age: 0
}
const {name, age} = myObject
console.log(name) // affiche Louis
console.log(age) // affiche 0

const {name1, age1} = myObject
console.log(name1) // affiche undefined
console.log(age1) // affiche undefined
</code></pre>

<p>Si on veut donner un nom différent que le nom des propriétés de l'objet, il faut utiliser les alias :</p>
<pre><code class="js">const myObject ={
    name:&quot;Louis&quot;,
    age: 0,
    present: function(){console.log(&quot;Hello&quot;)}
}
const {name, age:age1, present:hello} = myObject
console.log(name) // affiche Louis
console.log(age1) // affiche 0
hello() // affiche  Hello
</code></pre>

<h2 id="-_1">----</h2>
<h1 id="les-classes-es6">Les classes (ES6)</h1>
<hr />
<h2 id="la-notion-de-classe">La notion de classe</h2>
<p>Comme vu dans la partie précédente, pour construire un objet, au lieu de faire une fonction constructeur et ajouter des méthodes sur le prototype, on peut créer une classe.</p>
<hr />
<h2 id="lheritage-inheritance">L'héritage (Inheritance)</h2>
<p>Si on veut définir une classe qui a les mêmes propriétés qu'une autre classe avec une propriété en plus, on peut hériter de cette classe plutôt que de la redéfinir de zéro, ce qui évitera une duplication de code.
- le mot clé <code>extends</code> permet de dire de quelle clase on hérite
- le mot clé <code>super</code> dans le constructeur permet d'exécuter le constructeur de la classe parent
- il est aussi possible d'exécuter une méthode parent dans une méthode enfant avec <code>super</code> en faisant <code>super.nomMethodeParent()</code>
- il est possible d'utiliser les méthodes parent sans les définir dans la classe enfant</p>
<pre><code class="js">class Person {
    constructor(name, age){
        this.name = name
        this.age = age
    }
    present(){
        console.log(`Hello my name is ${this.name}`)
    }
}

class Hero extends Person{
    constructor(name, age, power){
        super(name, age) // exécute le constructeur de la classe parent avec ses paramètres
        this.power = power
    }
    usePower(){
        console.log(`I am using my power ${this.power}`)
    }
    presentHero(){
        super.present()
        console.log(`My power is ${this.power}`)
    }
}

let louis = new Person(&quot;Louis&quot;, 0)
louis.present() // affiche : Hello my name is Louis
//louis.usePower() // il y aura une erreur car on ne peut utiliser la méthode de Hero avec un objet Person

let superman = new Hero(&quot;Superman&quot;, 30, &quot;fly&quot;)
superman.present() // affiche : Hello my name is Superman
superman.usePower() // affiche : I am using my power fly
superman.presentHero() // affiche : Hello my name is Superman, puis affiche : My power is fly
</code></pre>

<hr />
<h2 id="etendre-les-objets-integres-extend-built-in-objects">Etendre les objets intégrés (Extend Built-In Objects)</h2>
<p>Depuis ES6, on peut aussi étendre des objets intégrés à JavaScript comme <em>Array</em> ou <em>Function</em></p>
<p>Par exemple, on va créer une classe qui hérite d'<em>Array</em> et qui définit une méthode qui renvoit un tableau avec tous les éléments en majuscules :</p>
<pre><code class="js">class UpperCaseArray extends Array{
    upperCase(){
        let newArray = []
        this.forEach(element =&gt; {newArray.push(element.toUpperCase())})
        return newArray
    }
}
const myArray = new UpperCaseArray()
myArray.push(&quot;louis&quot;)
myArray.push(&quot;kévin&quot;)
myArray.push(&quot;Thibaut&quot;)

console.log(myArray.upperCase()) // affiche : [&quot;LOUIS&quot;, &quot;KÉVIN&quot;, &quot;THIBAUT&quot;]
</code></pre>

<hr />
<h2 id="methodes-statiques">Méthodes Statiques</h2>
<p>On peut aussi utiliser les classes pour regrouper les fonctions qui concernent un même sujet.</p>
<p>Par exemple, on peut faire une classe <em>Mathematiques</em> :</p>
<pre><code class="js">class Mathematique{
    addition(number1, number2){
        return number1 + number2
    }
    multiplication(number1, number2){
        return number1 * number2
    }
}

const myMath = new Mathematique()
console.log(myMath.addition(2,3)) // affiche 5
console.log(myMath.multiplication(2,3)) // affiche 6
</code></pre>

<p>C'est inutile dans ce cas de créer une instance de classe pour utiliser les méthodes, car rien n'est lié à une méthode spécifique. Pour faire cela, on va déclarer nos méthodes <code>static</code> et on pourra utiliser les méthodes sans instancier la classe.</p>
<pre><code class="js">class Mathematique{
    static addition(number1, number2){
        return number1 + number2
    }
    static multiplication(number1, number2){
        return number1 * number2
    }
}

console.log(Mathematique.addition(2,3))
console.log(Mathematique.multiplication(2,3))
</code></pre>

<hr />
<h2 id="get-et-set">Get et Set</h2>
<p>De base, rien n'empêche d'accéder et de modifier les propriétés de nos objets :</p>
<pre><code class="js">class Person{
    constructor(name){
        this.name = name
    }
}

let louis = new Person(&quot;Louis&quot;)
console.log(louis.name) // affiche : Louis

louis.name = &quot;Loulou&quot; // modifie le nom de l'objet louis
console.log(louis.name) // affiche : Loulou
</code></pre>

<p>Pour éviter cela, on peut utiliser <em>get</em> et <em>set</em> pour contrôler l'accès aux propriétés de nos objets, choisir ce qu'on renvoit et dans quelle condition la propriété peut être modifiée :</p>
<pre><code class="js">class Person{
    constructor(name){
        this._name = name // par convention, on met un _ devant les propriétés que l'on veut rendre &quot;semi privé&quot;
    }
    get name(){
        return `bébé ${this._name}`
    }
    set name(value){
        if(value.length &gt; 2){
            this._name = value
        }
    }
}

let louis = new Person(&quot;Louis&quot;)
console.log(louis.name) // affiche : bébé Louis
louis.name = &quot;Lo&quot;
console.log(louis.name) // affiche : bébé Louis, la modification n'a pas eu lieu car la taille du nom soumis n'est pas supérieur à 2
louis.name = &quot;Loulou&quot;
console.log(louis.name) // affiche : bébé Loulou

// On peut toujours accéder à la propriété _name et la modifier directement
console.log(louis._name) // affiche : Loulou
louis._name = &quot;az&quot;
console.log(louis._name) // affiche : az
console.log(louis.name) // affiche : bébé az
</code></pre>

<h2 id="-_2">----</h2>
<h1 id="les-modules-es6">Les modules (ES6)</h1>
<hr />
<p>## Modules</p>
<p>Sur des gros projets, il faut organiser le code JavaScript en plusieurs fichiers. Pour charger les différents fichiers JavaScript, on peut les charger chacun un tag <code>&lt;script src="script.js"&gt;&lt;/script&gt;</code> dans la page html.</p>
<pre><code class="js"> // script1.js
const myLog = message =&gt; console.log(`** My Log ** : ${message}`)

// script2.js
myLog(&quot;Hello !&quot;)

// index.html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Modules JavaScript&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;script1.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;script2.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
// affiche dans la console : ** My Log ** : Hello ! 
</code></pre>

<p>Cette solution n'est pas idéale pour plusieurs raisons :
 - à chaque tag <code>script</code>, une nouvelle requête est faite au serveur pour récupérer le fichier
 - il faut faire attention à l'ordre des fichiers en mettant d'abord les fichiers avec du code qui sert dans les fichiers suivant, sinon ça ne fonctionnera pas
 - tous les fichiers partagent le même scope global, on s'expose donc aux accidents de variables si par exemple des variables ont le même nom dans différents fichiers ce qui fait que des variables vont s'écraser</p>
<p>Pour répondre à ces problèmes, ES6 a amené <strong>les modules</strong>. Chaque module peut exporter certaines de ces fonctionnalités et importer des fonctionnalités d'autres modules. La problème est que la plupart des navigateurs ne supportent pas encore les modules ES6. Avec Chrome, il faut au moins la version 60 et aller dans l'url <code>chrome://flags/</code> et activer <code>Experimental Web Platform features</code>. Avec Firefox en version 61 (et peut-être les versions plus anciennes ?), les modules sont pris en charge nativement.</p>
<p>Dans le script 1, il faut exporter la fonction avec le mot clé <code>export</code> et dans le script 2, il faut l'importer. Dans le fichier html, on laisse qu'un seul script JavaScript, notre fichier point d'entrée script2.js et on ajoute le type module dans la balise script. Le résultat sera le même.</p>
<pre><code class="js"> // script1.js
export const myLog = message =&gt; console.log(`** My Log ** : ${message}`)

// script2.js
import {myLog} from &quot;./script1.js&quot;
myLog(&quot;Hello !&quot;)

// index.html

&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Modules JavaScript&lt;/title&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script type=&quot;module&quot; src=&quot;script2.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<hr />
<p>## Import et Export</p>
<p>Avec les modules, l'import et l'export se fait par référence, c'est-à-dire qu'on ne crée pas une nouvelle variable mais on importe la variable de l'autre module.</p>
<p>Pour exporter plusieurs choses d'un même module, on fait deux exports et on fait les deux imports sur une seule ligne
  <code>``js
 // script1.js
export const myLog = message =&gt; console.log(</code><strong> My Log </strong> : ${message}`)
export let myVariable = "Coucou !"</p>
<p>// script2.js
import {myLog, myVariable} from "./script1.js"
myLog(myVariable)</p>
<pre><code>
On peut aussi faire l'export à la fin du fichier au lieu de le faire au moment de la déclaration.
  ```js
 // script1.js
const myLog = message =&gt; console.log(`** My Log ** : ${message}`)
let myVariable = &quot;Coucou !&quot;
export {myLog, myVariable}
</code></pre>

<p>Une variante de l'export et l'<code>export default</code>. Il ne peut y en avoir qu'un par fichier. Lorsqu'on l'importe, on ne met pas les accolades et on lui donne le nom qu'on veut car lorsqu'on ne met pas les accolades, c'est forcément lque ça correspond à l'export default.</p>
<pre><code class="js"> // script1.js
const myLog = message =&gt; console.log(`** My Log ** : ${message}`)
let myVariable = &quot;Coucou !&quot;
let myVariable2 = &quot;Important&quot;
export {myLog, myVariable}
export default myVariable2

// script2.js
import {myLog, myVariable} from &quot;./script1.js&quot;
import myVariable2 from &quot;./script1.js&quot;
myLog(myVariable)
myLog(myVariable2)
</code></pre>

<p>Exemple en renommant la variable de l'export default dans l'import :</p>
<pre><code class="js">// script2.js
import toto, {myLog, myVariable} from &quot;./script1.js&quot;
myLog(myVariable)
myLog(toto) // correspond à l'export default de myVariable2
</code></pre>

<p>On peut aussi utiliser des alias pour renommer les export classiques :</p>
<pre><code class="js">// script2.js
import toto, {myLog as myLogImported, myVariable} from &quot;./script1.js&quot;
myLogImported(myVariable)
myLogImported(toto)
</code></pre>

<p>Lorsqu'il y a plusieurs éléments à importer, on peut utiliser l'étoile pour tout importer.</p>
<pre><code class="js">// script2.js
import * as external from &quot;./script1.js&quot;
external.myLog(external.myVariable)
</code></pre>

<hr />
<hr />
<p># Les nouveautés ES7</p>
<hr />
<p>## Array.prototype.includes</p>
<p>Lorsqu'on veut vérifier la présence d'un élément dans un tableau, il faut utiliser la méthode <code>indexOf()</code> qui renvoie la position de l'élément dans le tableau, ou -1 si l'élément est absent.</p>
<pre><code class="js">const fruits = [&quot;pomme&quot;, &quot;banane&quot;, &quot;orange&quot;]

console.log(fruits.indexOf(&quot;banane&quot;)) // affiche 1
console.log(fruits.indexOf(&quot;melon&quot;)) // affiche -1

const monFruit = &quot;banane&quot;
if(fruits.indexOf(monFruit)&gt;-1){
    console.log(`${monFruit} est dans le tableau`)
} else {
    console.log(`${monFruit} n'est pas dans le tableau`)
}
</code></pre>

<p>En ES7, on peut utiliser la méthode <code>includes()</code> qui renvoie <em>true</em> ou <em>false</em> si l'élément est présent ou non dans le tableau.</p>
<pre><code class="js">const fruits = [&quot;pomme&quot;, &quot;banane&quot;, &quot;orange&quot;]

console.log(fruits.includes(&quot;banane&quot;)) // affiche true
console.log(fruits.includes(&quot;melon&quot;)) // affiche false

const monFruit = &quot;banane&quot;
if(fruits.includes(monFruit)){
    console.log(`${monFruit} est dans le tableau`)
} else {
    console.log(`${monFruit} n'est pas dans le tableau`)
}
</code></pre>

<hr />
<h2 id="loperateur-dexponentiation-operateur-de-puissance">L'opérateur d'exponentiation (opérateur de puissance)</h2>
<p>l'ES7 amène un nouvel opérateur qui est la puissance qui se note avec deux étoiles sous la forme <code>x ** y</code> pour x puissance y. Avant l'ES7, il fallait utiliser l'objet Math.</p>
<pre><code class="js">const calcul = Math.pow(2,3) // 2*2*2
console.log(calcul) // affiche : 8

const newCalcul = 2 ** 3
console.log(newCalcul) // affiche : 8
</code></pre>

<p>On peut aussi utiliser ce nouvel opérateur comme les opérateurs classiques.</p>
<pre><code class="js">let myVar = 2
myVar **= 3 // équivaut à myVar = myVar ** 3
console.log(myVar) // affiche 8
</code></pre>

<h2 id="-_3">----</h2>
<h1 id="developpement-moderne-javascript_1">Développement moderne JavaScript</h1>
<p>Tous les navigateurs ne supportent pas encore ces nouveautés. Il existe des outils qui permettent de coder en ES6 et ES7 et que le code soit supporté par tous les navigateurs.</p>
<h2 id="-_4">----</h2>
<h1 id="npm">Npm</h1>
<hr />
<h2 id="les-bases-de-npm">Les bases de Npm</h2>
<p>Npm pour <em>Node Package Manager</em> va nous permettre de gérer nos paquets JavaScript. Pour l'utiliser, il faut télécharger <strong>Node.js</strong>
Pour vérifier qu'il est bien installé et vérifier la version, tpaer la commande <code>node -v</code> puis <code>npm -v</code>.</p>
<p>Jusqu'à présent, pour utiliser une bibliothèque externe comme JQuery, il faut télécharger la bibliothèque et l'ajouter dans le fichier HTML.</p>
<p>Avec Npm, il est possible de télécharger la bibliohèque très facilement, en faisant <code>npm install jquery</code>. Un dossier <em>node_modules</em> est créé avec un sous-dossier <em>jquery</em>. Il faut ensuite l'ajouter au fichier HTML en pointant dans le sous-dossier <em>dist</em> (pour distribution) et on peut utiliser <em>jquery</em> dans le projet.</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;NPM&lt;/title&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;./node_modules/jquery/dist/jquery.js&quot;&gt;&lt;/script&gt;
        &lt;script type=&quot;module&quot; src=&quot;script.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<pre><code class="js">// script.js
import {myLog} from &quot;./external.js&quot;
myLog(&quot;Hello !&quot;)

jQuery(document).ready(function(){
    console.log(&quot;jQuery est prêt !&quot;);
  });

// external.js
export const myLog = message =&gt; console.log(`** My Log ** : ${message}`)
</code></pre>

<p>On peut désinstaller la bibliothèque avec la commande <code>npm uninstall jquery</code>, ce qui supprime le dossier <em>jquery</em> du dossier <em>node_modules</em>. On peut mettre à jour la version de <em>jquery</em> avec la commande <code>npm update jquery</code>.</p>
<hr />
<h2 id="le-fichier-packagejson">Le fichier package.json</h2>
<p>Généralement on a beaucoup de dépendances, ce qui deviendrait lourd à gérer avec les commandes vues ici. Avec le fichier <strong>package.json</strong>, on va pouvoir noter toutes les dépendances ainsi que leur version. Cela permettra aussi de reproduire le projet sur un autre poste sans y inclure toutes les dépendances mais uniquement ce fichier. En lançant la commande <code>npm install</code>, toutes les dépendances inscrites dans le fichier <em>package.json</em> seront installées dans la version spécifié.</p>
<p>Ce fichier est un fichier de configuration, il sert également à d'autres choses. Pour le créer, il faut exécuter la commande <code>npm init</code>.</p>
<p>Lorsqu'on installe ou désinstalle une dépendance, elle n'est pas renseignée dans le fichier <em>package.json</em>. Pour que ce soit le cas il faut ajouter <code>--save</code>, par exemple <code>npm install jquery --save</code> et jquery sera inscrit dans les dépendances avec son numéro de version.</p>
<p>Il y a deux types de dépendances :
- les dépendances classiques dont notre code a besoin, comme par exemple <em>jquery</em>. Elles sont rensiegnées donc <em>dependencies</em>
- les dépendances de développement qui correspond aux outils de développement, par exemple <em>webpack</em> que l'on verra au prochain chapitre. Elles sont rensiegnées donc <em>devDependencies</em>. Pour cela, il faut utiliser la commande <code>--save-dev</code>, par exemple <code>npm install --save-dev webpack webpack-cli</code></p>
<p>En installant <em>webpack</em>, il y a maintenant plein de dépendances dans <em>node_modules</em> car <em>webpack</em> a besoin d'autres dépendances qui ont été installé également.</p>
<h2 id="-_5">----</h2>
<h1 id="webpack">Webpack</h1>
<hr />
<h2 id="quest-ce-que-webpack">Qu'est-ce que Webpack</h2>
<p>Il est principalement utilisé comme <em>module bundler</em>, c'est-à-dire qu'il va prendre tous nos fichiers pour faire un seul gros fichier. Ce fichier pourra être inclus dans le fichier HTML, ce qui permet d'utiliser les modules ES6 directement avec webpack tout en étant compatible avec les navigateurs anciens.</p>
<p>Il faut créer un fichier de configuration <em>webpack.config.js</em></p>
<pre><code class="js">module.exports = {
    entry: &quot;./script.js&quot;, // dit à webpack le point d'entrée de notre projet
    output: {
        filename: &quot;bundle.js&quot; // dit à webpack le nom du fichier produit
    }
}
</code></pre>

<p>Il faut ensuite indiquer dans le fichier HTML que le fichier de script à utiliser est celui créé par webpack. On peut aussi enlever la dépendance jquery du fichier HTML et l'importer dans le script où on l'utilise, webpack l'embarquera dans le fichier <em>bundle.js</em> qu'il va générer dans un dossier <em>dist</em> (pour distribution).</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;NPM&lt;/title&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<pre><code class="js">// script.js
import {myLog} from &quot;./external.js&quot;
import jQuery from &quot;jquery&quot;

myLog(&quot;Hello !&quot;)

jQuery(document).ready(function(){
    console.log(&quot;jQuery est prêt !&quot;);
});

// external.js
export const myLog = message =&gt; console.log(`** My Log ** : ${message}`)
</code></pre>

<hr />
<h2 id="executer-webpack">Exécuter Webpack</h2>
<p>On va lancer l'exécutable de webpack. Dans le dossier <em>.bin</em> de node_modules, il y a tous les exécutables. Pour lancer webpack, on va exécuter la commande <code>node_modules/.bin/webpack</code>. Le fichier *bundle.js a été créé en enpaquetant nos fichiers javscript. On peut lancer notre page HTML et ça fonctionne comme avant san utiliser les modules.</p>
<p>Pour éviter de lancer la commande <code>node_modules/.bin/webpack</code> à chaque fois, on va créer une tâche dans le fichier <em>package.json</em> que l'on pourra exécuter à la place de cette commande. Pour excécuter la tâche, on lancera la commande <code>npm run build</code></p>
<pre><code class="js">// package.json
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;build&quot;: &quot;webpack&quot; // ajout de la tâche build qui crée notre fichier bundle.js
  }
  ```

  On peut faire mieux en disant à webpack d'observer notre code et de recompiler le code pour recréer *bundle.js* quand il observe des modifications sans relancer la commande de build. Pour cela, on va ajouter une propriété dans le fichier de configuration de webpack. Lorsqu'on fait une modification et que l'on sauvegarde, il n'y a plus qu'à rafraîchir la page HTML pour voir le changement.
  ```js
  // webpack.config.js
module.exports = {
    watch: true, // ajout de cette proriété pour que webpack observe notre code et recompile lorsqu'il y a des changements
    entry: &quot;./script.js&quot;,
    output: {
        filename: &quot;bundle.js&quot;
    }
}
</code></pre>

<hr />
<h2 id="serveur-local-webpack">Serveur local Webpack</h2>
<p>Pour éviter d'avoir à recharger la page HTML à chaque modification du code JavaScript, on va mettre en place un serveur de développement local. On va installer un nouveau paquet avec la commande <code>npm install --save-dev webpack-dev-server</code>.
On va exécuter la commande <code>node_modules/.bin/webpack-dev-server</code> qui compile notre code et le met à disposition à l'adresse <strong>localhost:8080</strong>. En faisant des modifications dans le code et que l'on enregistre, la page est relancé automatiquement. On peut créer une tâche dans les scripts dans le fichier <em>package.json</em> : <code>"start": "webpack-dev-server --open"</code>. <code>--open</code> permet de lancer la page HTML dans le navigateur avec la commannde <code>npm run start</code>.</p>
<hr />
<h2 id="architecture-des-fichiers">Architecture des fichiers</h2>
<p>Pour le moment, tous les fichiers sont mis à la racine du projet. On va réorganiser tout ça
- un dossier <strong>src</strong> qui contient le code de développement, les fichiers sources JavaScript
- un dossier <strong>dist</strong> qui contient le code de distribution que voit le public, le fichier index.html et le fichier bundle.js</p>
<p>Il faut mettre à jour le fichier de configuration de webpack pour que ça fonctionne bien</p>
<pre><code class="js">// webpack.config.js
const path = require(&quot;path&quot;) // permet de créer des chemins absolus à partir des chemins relatifs car webpack attend à certains endroits des chemins absolus
module.exports = {
    watch: true,
    entry: &quot;./src/script.js&quot;, // dit à webpack le point d'entrée de notre projet
    output: {
        path: path.resolve(__dirname, &quot;dist&quot;),
        filename: &quot;bundle.js&quot; // dit à webpack le nom du fichier produit
    },
    devServer: {
        contentBase: path.resolve(__dirname, &quot;dist&quot;), // dit au serveur de nous servir ce qu'il y a dans le dossier dist au lieu de la racine du projet
        open: true // lance le navigateur automatiquement au lancement du serveur, ce qui évite de mettre --open dans la tâche
    }
}

// index.html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;NPM&lt;/title&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h2 id="-_6">----</h2>
<h1 id="babel">Babel</h1>
<hr />
<h2 id="quest-ce-que-babel">Qu'est-ce que Babel</h2>
<p>Babel est un transpileur qui va traduire notre code ES6-ES7 en ES5 équivalent, ce qui nous permettra d'être compatible avec les anciennes versions des navigateurs.</p>
<hr />
<h2 id="babel-loader">Babel loader</h2>
<p>C'est une fonctionnalité de webpack qui va permettre de transpiler le code en ES5 au moment de la création du fichier <em>bundle.js</em>.</p>
<p>Il faut commencer par installer les dépendances nécessaires <code>npm install --save-dev babel-loader babel-core babel-preset-env</code>. Il faut ensuite mettre à jour le fichier de configuration de webpack en ajoutant une partie.</p>
<pre><code class="js">// webpack.config.js
module: {
    rules: [
        {
            // on teste si c'est un fichier JS
            test: /\.js$/,
            // on ne traite pas les fichiers dans node_modules
            exclude: /node_modules/,
            use: {
                loader: &quot;babel-loader&quot;,
                options: {
                    presets: [&quot;env&quot;]
                }
            }
        }
    ]
}
</code></pre>

<hr />
<h2 id="babel-polyfill">Babel polyfill</h2>
<p>ES6-ES7 n'apportent pas que de la nouvelle syntaxe mais aussi de nouveaux éléments. Quand on utilise un nouvel élément ES6, on ne peut pas le traduire en ES5, ce qui peut poser des problèmes de compatibilité avec les anciens navigateurs. Dans ce cas, on peut utiliser un <strong>polyfill</strong>, qui est un bout de code qui contient ces nouveaux éléments, ce qui permet d'ajouter les éléments manquants au navigateur.</p>
<p>On va utiliser Babel polyfill. Il faut commencer par l'installer avec la commande <code>npm install --save babel-polyfill</code>. Il faut ensuite mettre à jour le fichier de configuration de webpack en ajoutant <em>babel-polyfill</em> dans les fichiers en entrée. Il faut aussi importer <em>babel-polyfill</em> dans le fichier d'entrée JavaScript.</p>
<pre><code class="js">// webpack.config.js
module.exports = {
    watch: true,
    entry: [&quot;babel-polyfill&quot;, &quot;./src/script.js&quot;], // dit à webpack le point d'entrée de notre projet
    output: {
        path: path.resolve(__dirname, &quot;dist&quot;),
        filename: &quot;bundle.js&quot; // dit à webpack le nom du fichier produit
    }

// script.js
import &quot;babel-polyfill&quot;
import {myLog} from &quot;./external.js&quot;

myLog(&quot;Hello !&quot;)
</code></pre></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"next": 78, "search": 83, "previous": 80, "help": 191};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
